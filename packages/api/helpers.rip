# Rip Server Helpers - Enhanced Request Data Reading & Validation
# Based on the newer Trust/Sinatra helpers.rb version
# Usage: mail = read 'email', 'email!', -> signout!  # with fallback action

# ðŸ”¥ SHOWCASING RIP'S LEGENDARY REGEX OPERATOR! ðŸ”¥
# This file demonstrates the most elegant regex matching ever created:
#
# =~ operator (match and assign to _):
#   val =~ /^(\d{3})-?(\d{2})-?(\d{4})$/  # Match and auto-assign to _
#   result = _?[1] and "#{_[1]}#{_[2]}#{_[3]}"  # Use with optional chaining
#
# Semicolon pattern for conditional transformations:
#   result = (val =~ /regex/; if _ then transform else fallback)
#
# Transform verbose JavaScript:    match = val.match(/regex/); code = match?[1]
# Into pure poetry (=~):           val =~ /regex/; code = _?[1]
# Or elegant one-liner:            code = (val =~ /regex/; if _ then _[1] else null)

# Email regex (simplified version)
emailRegex = /^[^\s@]+@[^-\s@]+\.[^\s@]+$/

# Phone formatting helper - SHOWCASING =~ ELEGANT SYNTAX!
toPhone = (val) ->
  return null unless val
  # Extract all digits and format with beautiful =~ one-liners
  digits = val.replace(/\D/g, '')
  return null if digits.length < 10
  # 10-digit format: 1234567890 -> 123-456-7890
  if digits.length == 10
    return (digits =~ /^(\d{3})(\d{3})(\d{4})$/; if _ then "#{_[1]}-#{_[2]}-#{_[3]}" else null)
  # 11-digit with country code: 11234567890 -> 123-456-7890
  if digits.length == 11
    return (digits =~ /^1(\d{3})(\d{3})(\d{4})$/; if _ then "#{_[1]}-#{_[2]}-#{_[3]}" else null)
  null

# Name formatting helper
# Capitalizes first letter of each word for names, basic formatting for addresses
toName = (val, type = 'name') ->
  return null unless val
  cleaned = val.trim().replace(/\s+/g, ' ')
  return null if cleaned.length == 0
  if type == 'name'
    # Capitalize first letter of each word
    words = cleaned.split(' ')
    capitalizedWords = words.map (word) -> word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()
    capitalizedWords.join(' ')
  else if type == 'address'
    # Basic address formatting
    cleaned
  else
    cleaned

# Boolean helpers
truthy = (val) -> val in [true, 'true', '1', 1, 'yes', 'on', 'y']
falsy = (val) -> val in [false, 'false', '0', 0, 'no', 'off', 'n']
bool = (val) -> return true if truthy(val); return false if falsy(val); null
isBlank = (val) -> not val? or val == '' or (typeof val == 'string' and val.trim() == '')

# JSON parsing helper
parseJsonSafely = (body) -> try JSON.parse(body) catch error {}

# Date parsing helpers
parseDate = (val) -> try date = new Date(val); if isNaN(date.getTime()) then null else date.toISOString().split('T')[0] catch error null
parseDateTime = (val) -> try date = new Date(val); if isNaN(date.getTime()) then null else date catch error null
parseDateUTC = (val) -> try date = new Date(val); if isNaN(date.getTime()) then null else date.toISOString() catch error null

import { requestContext } from '../../apps/labs/api/context.ts'

export read = (keyOrContext, key = null, tag = null, miss = null) ->
  ctx = requestContext?.getStore()
  c = if keyOrContext?.req?.method? then keyOrContext else ctx?.c
  data = ctx?.data or {}
  throw new Error('read() called without context') unless c
  [key, tag, miss] = [keyOrContext, key, tag] unless key and tag and miss is not undefined
  val = if key then data[key] else data
  return val unless key and tag
  originalTag = tag
  bam = false
  if typeof tag == 'string' and tag.endsWith('!')
    tag = tag.slice(0, -1)
    bam = true
  if Array.isArray(val)
    val = if tag == 'array' then val else val.join(',')
  else if typeof val == 'object' and val?
    val = if tag == 'hash' then val else String(val)
  else
    val = String(val or '')
  switch tag
    when 'id'      then val = (val =~ /^([1-9]\d{0,19})$/; if _ then parseInt(_[1]) else null); return val if val
    when 'whole'   then val = (val =~ /^(0|[1-9]\d{0,19})$/; if _ then parseInt(_[1]) else null); return val if val
    when 'decimal' then val = (val =~ /^([-+]?\d+(?:\.\d*)?|\.\d+)$/; if _ then parseFloat(_[1].replace(/\.$/, '')) else null)
    when 'money'   then val = (val =~ /^([-+]?\d+(?:\.\d*)?|\.\d+)$/; if _ then Math.round(parseFloat(_[1].replace(/\.$/, '')) * 100) / 100 else null)
    when 'string'  then val = val.replace(/\s\s+/g, ' ')
    when 'text'    then val = val.replace(/  +/g, ' ')
    when 'name'    then val = toName(val, 'name')
    when 'phone'   then val = toPhone(val)
    when 'address' then val = toName(val, 'address')
    when 'time'    then val = parseDateTime(val)
    when 'date'    then val = parseDate(val)
    when 'dateutc' then val = parseDateUTC(val)
    when 'truthy'  then val = truthy(val)
    when 'falsy'   then val = falsy(val)
    when 'email'   then val = (val =~ /^([a-zA-Z0-9._%+-]+)@([a-zA-Z0-9.-]+\.[a-zA-Z]{2,})$/; if _ then _[0].toLowerCase() else null)
    when 'state'   then val = (_[1].toUpperCase() if val =~ /^([a-z][a-z])$/i)
    when 'zip'     then val = (_[1] if val =~ /^(\d{5})/)
    when 'zipplus4' then val = ("#{_[1]}-#{_[2]}" if val =~ /^(\d{5})-?(\d{4})$/)
    when 'ssn'     then val = ("#{_[1]}#{_[2]}#{_[3]}" if val =~ /^(\d{3})-?(\d{2})-?(\d{4})$/)
    when 'sex'     then val = (_[1][0].toUpperCase() if val =~ /^(m|male|f|female|o|other)$/i)
    when 'creditcard' then val = (val =~ /^(\d{4})-?(\d{4})-?(\d{4})-?(\d{4})$/; if _ then "#{_[1]}-#{_[2]}-#{_[3]}-#{_[4]}" else null)
    when 'url'     then val = (val =~ /^(https?:\/\/)?([\da-z\.-]+)\.([a-z\.]{2,6})([\/\w \.-]*)*\/?$/; if _ then _[0] else null)
    when 'username' then val = (val =~ /^([a-zA-Z0-9_-]{3,20})$/; if _ then _[1].toLowerCase() else null)
    when 'color'   then val = (val =~ /^#?([0-9a-fA-F]{3}|[0-9a-fA-F]{6})$/; if _ then "##{_[1].toLowerCase()}" else null)
    when 'ip'      then val = (val =~ /^(\d{1,3})\.(\d{1,3})\.(\d{1,3})\.(\d{1,3})$/; if _ then (if _[1..4].every((n) -> parseInt(n) <= 255) then _[0] else null) else null)
    when 'mac'     then val = (val =~ /^([0-9a-fA-F]{2})[:-]?([0-9a-fA-F]{2})[:-]?([0-9a-fA-F]{2})[:-]?([0-9a-fA-F]{2})[:-]?([0-9a-fA-F]{2})[:-]?([0-9a-fA-F]{2})$/; if _ then "#{_[1]}:#{_[2]}:#{_[3]}:#{_[4]}:#{_[5]}:#{_[6]}".toLowerCase() else null)
    when 'semver'  then val = (val =~ /^(\d+)\.(\d+)\.(\d+)(?:-([a-zA-Z0-9-]+(?:\.[a-zA-Z0-9-]+)*))?$/; if _ then _[0] else null)
    when 'uuid'    then val = (val =~ /^([0-9a-f]{8})-?([0-9a-f]{4})-?([0-9a-f]{4})-?([0-9a-f]{4})-?([0-9a-f]{12})$/i; if _ then "#{_[1]}-#{_[2]}-#{_[3]}-#{_[4]}-#{_[5]}".toLowerCase() else null)
    when 'time24'  then val = (val =~ /^([01]?[0-9]|2[0-3]):([0-5][0-9])(?::([0-5][0-9]))?$/; if _ then _[0] else null)
    when 'time12'  then val = (val =~ /^(1[0-2]|0?[1-9]):([0-5][0-9])\s?(am|pm)$/i; if _ then _[0].toLowerCase() else null)
    when 'currency' then val = (val =~ /^\$?(\d{1,3}(?:,\d{3})*(?:\.\d{2})?)$/; if _ then parseFloat(_[1].replace(/,/g, '')) else null)
    when 'slug'    then val = (val =~ /^([a-z0-9]+(?:-[a-z0-9]+)*)$/; if _ then _[1] else null)
    when 'bool'    then val = bool(val); return val unless val?
    when 'array'   then val = if Array.isArray(data[key]) then data[key] else null
    when 'hash'    then val = if typeof data[key] == 'object' and data[key]? then data[key] else null
    when 'json'    then if typeof val == 'string' then try val = JSON.parse(val) catch error val = null else if val? and typeof val == 'object' then val = val else val = null
    when 'ids'     then if val and val.trim() then try cleanVal = val.replace(/[, ]+/g, ' ').trim(); idList = cleanVal.split(' '); validIds = []; for id in idList temp = (id =~ /^([1-9]\d{0,19})$/; if _ then parseInt(_[1]) else null); if temp then validIds.push(temp) else throw new Error("Invalid ID: #{id}"); val = validIds.filter((id, index, arr) -> arr.indexOf(id) == index).sort((a, b) -> a - b); val = null if val.length == 0 catch error val = null else val = null
    else
      if Array.isArray(originalTag)
        val = if originalTag.includes(val) then val else null
        if val == null and typeof miss == 'function' then miss()
      else if originalTag instanceof RegExp
        val = if originalTag.test(val) then val else null
        if val == null and typeof miss == 'function' then miss()
      else if typeof originalTag == 'object' and originalTag?.start? and originalTag?.end?
        numVal = parseInt(val)
        val = if !isNaN(numVal) and numVal >= originalTag.start and numVal <= originalTag.end then numVal else null
      else if Array.isArray(originalTag) and originalTag.length == 2 and typeof originalTag[0] == 'number' and typeof originalTag[1] == 'number'
        start = Math.min(originalTag[0], originalTag[1])
        end = Math.max(originalTag[0], originalTag[1])
        if tag in ['id', 'whole', 'decimal', 'money'] or (typeof val == 'number')
          numVal = parseInt(val)
          val = if !isNaN(numVal) and numVal >= start and numVal <= end then numVal else null
        else if typeof val == 'string'
          strLen = val.length
          val = if strLen >= start and strLen <= end then val else null
        else
          val = null
      else if typeof originalTag == 'object' and (originalTag?.min? or originalTag?.max?)
        minVal = originalTag.min
        maxVal = originalTag.max
        if tag in ['id', 'whole', 'decimal', 'money'] or (typeof val == 'number')
          numVal = parseInt(val)
          if !isNaN(numVal)
            valid = true
            valid = false if minVal? and numVal < minVal
            valid = false if maxVal? and numVal > maxVal
            val = if valid then numVal else null
          else
            val = null
        else if typeof val == 'string'
          strLen = val.length
          valid = true
          valid = false if minVal? and strLen < minVal
          valid = false if maxVal? and strLen > maxVal
          val = if valid then val else null
        else
          val = null
  if isBlank(val)
    if bam
      throw new Error("Missing required field: #{key}")
    else
      val = if typeof miss == 'function' then miss() else miss
  val