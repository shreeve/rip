# Rip Server Helpers - Enhanced Request Data Reading & Validation
# Based on the original helpers.rip but with working CoffeeScript syntax

# Email regex (simplified version)
emailRegex = /^[^\s@]+@[^-\s@]+\.[^\s@]+$/

# Phone formatting helper
toPhone = (val) ->
  return null unless val
  digits = val.replace(/\D/g, '')
  return null if digits.length < 10
  # 10-digit format: 1234567890 -> 123-456-7890
  if digits.length == 10
    digits =~ /^(\d{3})(\d{3})(\d{4})$/ and "#{_[1]}-#{_[2]}-#{_[3]}"
  # 11-digit with country code: 11234567890 -> 123-456-7890
  else if digits.length == 11
    digits =~ /^1(\d{3})(\d{3})(\d{4})$/ and "#{_[1]}-#{_[2]}-#{_[3]}"
  else
    null

# Name formatting helper
# Capitalizes first letter of each word for names, basic formatting for addresses
toName = (val, type = 'name') ->
  return null unless val
  cleaned = val.trim().replace(/\s+/g, ' ')
  return null if cleaned.length == 0
  if type == 'name'
    # Capitalize first letter of each word
    words = cleaned.split(' ')
    capitalizedWords = words.map (word) -> word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()
    capitalizedWords.join(' ')
  else if type == 'address'
    # Basic address formatting
    cleaned
  else
    cleaned

# Boolean helpers
truthy = (val) -> val in [true, 'true', '1', 1, 'yes', 'on', 'y']
falsy = (val) -> val in [false, 'false', '0', 0, 'no', 'off', 'n']
bool = (val) -> return true if truthy(val); return false if falsy(val); null
isBlank = (val) -> not val? or val == '' or (typeof val == 'string' and val.trim() == '')

# JSON parsing helper
parseJsonSafely = (body) -> try JSON.parse(body) catch error then {}

# Date parsing helpers
parseDate = (val) -> try date = new Date(val); if isNaN(date.getTime()) then null else date.toISOString().split('T')[0] catch error then null
parseDateTime = (val) -> try date = new Date(val); if isNaN(date.getTime()) then null else date catch error then null
parseDateUTC = (val) -> try date = new Date(val); if isNaN(date.getTime()) then null else date.toISOString() catch error then null

import { requestContext } from './context.ts'

_routeQueue = []
_currentApp = null
_currentContext = null

smartRoute = (handler) ->
  (c) ->
    _currentContext = c
    try
      result = handler(c)
      if typeof result == 'string'
        return c.text(result)
      else if typeof result == 'object' && result != null
        return c.json(result)
      else if typeof result == 'number' || typeof result == 'boolean'
        return c.text(result.toString())
      return result
    finally
      _currentContext = null

methods = ['get', 'post', 'put', 'patch', 'delete', 'options', 'head']

for method in methods
  Object.defineProperty global, method,
    value: do (method=method) -> (path, handler) ->
      if _currentApp?
        _currentApp[method](path, smartRoute(handler))
      else
        _routeQueue.push { method, path, handler }
    configurable: true

export withHelpers = (app) ->
  _currentApp = app

  for route in _routeQueue
    _currentApp[route.method](route.path, smartRoute(route.handler))

  _routeQueue = []

  return app

export read = (keyOrContext, key = null, tag = null, miss = null) ->
  ctx = requestContext?.getStore()
  c = if keyOrContext?.req?.method? then keyOrContext else ctx?.c
  data = ctx?.data or {}
  throw new Error('read() called without context') unless c
  [key, tag, miss] = [keyOrContext, key, tag] unless key and tag and miss is not undefined
  val = if key then data[key] else data
  return val unless key and tag
  originalTag = tag
  bam = false
  if typeof tag == 'string' and tag.endsWith('!')
    tag = tag.slice(0, -1)
    bam = true
  if Array.isArray(val)
    val = if tag == 'array' then val else val.join(',')
  else if typeof val == 'object' and val?
    val = if tag == 'hash' then val else String(val)
  else
    val = String(val or '')

  # Process the tag
  switch tag
    when 'id'      then val = (val =~ /^([1-9]\d{0,19})$/; if _ then parseInt(_[1]) else null); return val if val
    when 'whole'   then val = (val =~ /^(0|[1-9]\d{0,19})$/; if _ then parseInt(_[1]) else null); return val if val
    when 'decimal' then val = (val =~ /^([-+]?\d+(?:\.\d*)?|\.\d+)$/; if _ then parseFloat(_[1].replace(/\.$/, '')) else null)
    when 'money'   then val = (val =~ /^([-+]?\d+(?:\.\d*)?|\.\d+)$/; if _ then Math.round(parseFloat(_[1].replace(/\.$/, '')) * 100) / 100 else null)
    when 'string'  then val = val.replace(/\s\s+/g, ' ')
    when 'text'    then val = val.replace(/  +/g, ' ')
    when 'name'    then val = toName(val, 'name')
    when 'phone'   then val = toPhone(val)
    when 'address' then val = toName(val, 'address')
    when 'time'    then val = parseDateTime(val)
    when 'date'    then val = parseDate(val)
    when 'dateutc' then val = parseDateUTC(val)
    when 'truthy'  then val = truthy(val)
    when 'falsy'   then val = falsy(val)
    when 'email'   then val = (_[0].toLowerCase() if val =~ /^([a-zA-Z0-9._%+-]+)@([a-zA-Z0-9.-]+\.[a-zA-Z]{2,})$/)
    when 'state'   then val = (_[1].toUpperCase() if val =~ /^([a-z][a-z])$/i)
    when 'zip'     then val = (_[1] if val =~ /^(\d{5})/)
    when 'zipplus4' then val = ("#{_[1]}-#{_[2]}" if val =~ /^(\d{5})-?(\d{4})$/)
    when 'ssn'     then val = ("#{_[1]}#{_[2]}#{_[3]}" if val =~ /^(\d{3})-?(\d{2})-?(\d{4})$/)
    when 'sex'     then val = (_[1][0].toUpperCase() if val =~ /^(m|male|f|female|o|other)$/i)
    when 'creditcard' then val = (val =~ /^(\d{4})-?(\d{4})-?(\d{4})-?(\d{4})$/; if _ then "#{_[1]}-#{_[2]}-#{_[3]}-#{_[4]}" else null)
    when 'url'     then val = (val =~ /^(https?:\/\/)?([\da-z\.-]+)\.([a-z\.]{2,6})([\/\w \.-]*)*\/?$/; if _ then _[0] else null)
    when 'username' then val = (val =~ /^([a-zA-Z0-9_-]{3,20})$/; if _ then _[1].toLowerCase() else null)
    when 'color'   then val = (val =~ /^#?([0-9a-fA-F]{3}|[0-9a-fA-F]{6})$/; if _ then "##{_[1].toLowerCase()}" else null)
    when 'ip'      then val = (val =~ /^(\d{1,3})\.(\d{1,3})\.(\d{1,3})\.(\d{1,3})$/; if _ then (if _[1..4].every((n) -> parseInt(n) <= 255) then _[0] else null) else null)
    when 'mac'     then val = (val =~ /^([0-9a-fA-F]{2})[:-]?([0-9a-fA-F]{2})[:-]?([0-9a-fA-F]{2})[:-]?([0-9a-fA-F]{2})[:-]?([0-9a-fA-F]{2})[:-]?([0-9a-fA-F]{2})$/; if _ then "#{_[1]}:#{_[2]}:#{_[3]}:#{_[4]}:#{_[5]}:#{_[6]}".toLowerCase() else null)
    when 'semver'  then val = (val =~ /^(\d+)\.(\d+)\.(\d+)(?:-([a-zA-Z0-9-]+(?:\.[a-zA-Z0-9-]+)*))?$/; if _ then _[0] else null)
    when 'uuid'    then val = (val =~ /^([0-9a-f]{8})-?([0-9a-f]{4})-?([0-9a-f]{4})-?([0-9a-f]{4})-?([0-9a-f]{12})$/i; if _ then "#{_[1]}-#{_[2]}-#{_[3]}-#{_[4]}-#{_[5]}".toLowerCase() else null)
    when 'time24'  then val = (val =~ /^([01]?[0-9]|2[0-3]):([0-5][0-9])(?::([0-5][0-9]))?$/; if _ then _[0] else null)
    when 'time12'  then val = (val =~ /^(1[0-2]|0?[1-9]):([0-5][0-9])\s?(am|pm)$/i; if _ then _[0].toLowerCase() else null)
    when 'currency' then val = (val =~ /^\$?(\d{1,3}(?:,\d{3})*(?:\.\d{2})?)$/; if _ then parseFloat(_[1].replace(/,/g, '')) else null)
    when 'slug'    then val = (val =~ /^([a-z0-9]+(?:-[a-z0-9]+)*)$/; if _ then _[1] else null)
    when 'bool'    then val = bool(val); val = null unless val?
    when 'array'   then val = if Array.isArray(data[key]) then data[key] else null
    when 'hash'    then val = if typeof data[key] == 'object' and data[key]? then data[key] else null
    when 'json'    then if typeof val == 'string' then try val = JSON.parse(val) catch error then val = null else if val? and typeof val == 'object' then val = val else val = null
    when 'ids'     then if val and val.trim() then try cleanVal = val.replace(/[, ]+/g, ' ').trim(); idList = cleanVal.split(' '); validIds = []; for id in idList temp = (id =~ /^([1-9]\d{0,19})$/; if _ then parseInt(_[1]) else null); if temp then validIds.push(temp) else throw new Error("Invalid ID: #{id}"); val = validIds.filter((id, index, arr) -> arr.indexOf(id) == index).sort((a, b) -> a - b); val = null if val.length == 0 catch error then val = null else val = null
    else
      if Array.isArray(originalTag)
        val = if originalTag.includes(val) then val else null
        if val == null and typeof miss == 'function' then miss()
      else if originalTag instanceof RegExp
        val = if originalTag.test(val) then val else null
        if val == null and typeof miss == 'function' then miss()
      else if typeof originalTag == 'object' and originalTag?.start? and originalTag?.end?
        numVal = parseInt(val)
        val = if !isNaN(numVal) and numVal >= originalTag.start and numVal <= originalTag.end then numVal else null
      else if Array.isArray(originalTag) and originalTag.length == 2 and typeof originalTag[0] == 'number' and typeof originalTag[1] == 'number'
        start = Math.min(originalTag[0], originalTag[1])
        end = Math.max(originalTag[0], originalTag[1])
        if tag in ['id', 'whole', 'decimal', 'money'] or (typeof val == 'number')
          numVal = parseInt(val)
          val = if !isNaN(numVal) and numVal >= start and numVal <= end then numVal else null
        else if typeof val == 'string'
          strLen = val.length
          val = if strLen >= start and strLen <= end then val else null
        else
          val = null
      else if typeof originalTag == 'object' and (originalTag?.min? or originalTag?.max?)
        minVal = originalTag.min
        maxVal = originalTag.max
        if tag in ['id', 'whole', 'decimal', 'money'] or (typeof val == 'number')
          numVal = parseInt(val)
          if !isNaN(numVal)
            valid = true
            valid = false if minVal? and numVal < minVal
            valid = false if maxVal? and numVal > maxVal
            val = if valid then numVal else null
          else
            val = null
        else if typeof val == 'string'
          strLen = val.length
          valid = true
          valid = false if minVal? and strLen < minVal
          valid = false if maxVal? and strLen > maxVal
          val = if valid then val else null
        else
          val = null

  if isBlank(val)
    if bam
      throw new Error("Missing required field: #{key}")
    else
      val = if typeof miss == 'function' then miss() else miss
  val