# @rip/api — cohesive single-file core (DSL + read + validators + reloader)
# -----------------------------------------------------------------------------
# Public exports:
#   DSL: get, post, put, patch, del, any, use, prefix, group, startHandler, start
#   API: withHelpers, read, registerValidator, getValidator, validators
#   Dev: createReloader, resetGlobals
#
# Design notes:
# - DSL is module-scoped per worker: no global leakage across workers.
# - read() is synchronous when used with withHelpers (Sinatra vibe).
# - Validators rely on Rip's =~ coercion (no local String(...) needed).
# - Smart wrapper lets handlers "just return" strings/objects/Response.

import { Hono } from 'hono'
import { requestContext } from './context'
import { statSync, watch } from 'node:fs'

# -----------------------------------------------------------------------------
# Module-scoped state (per worker / per module instance)
# -----------------------------------------------------------------------------

_          = null # match capture holder for Rip's =~
_app       = null # real Hono app (built on demand)
_routes    = []   # queued routes & middleware (preserve declaration order)
_prefix    = ''   # current group/prefix

# -----------------------------------------------------------------------------
# withHelpers middleware (attaches per-request context for read())
# -----------------------------------------------------------------------------
export withHelpers = (c, next) ->
  data = {}
  try
    ct = c.req.header('content-type') or ''
    if c.req.method in ['POST','PUT','PATCH']
      if ct =~ /json/i
        data = c.req.json!
      else if ct =~ /x-www-form-urlencoded|form-data/i
        data = c.req.parseBody!
  catch
    data = {}

  # Merge query last for simple overrides via ?a=1
  q = Object.fromEntries(new URL(c.req.url).searchParams.entries())
  merged = { ...data, ...q }

  # Run the rest of the pipeline inside this request's ALS scope
  await new Promise (resolve, reject) ->
    requestContext.run { hono: c, data: merged }, ->
      Promise.resolve(next()).then(resolve, reject)

# -----------------------------------------------------------------------------
# String helper: non-enumerable String::sub(pat, rep, ...)
# -----------------------------------------------------------------------------
unless String::sub?
  Object.defineProperty String::, 'sub',
    value: (ary...) ->
      s = String(@)
      for i in [0...ary.length] by 2 then s = s.replace ary[i], ary[i+1] ? ''
      s
    writable: yes
    configurable: yes
    enumerable: no

# Advanced phone formatting
export toPhone = (str) ->
  return "" if isBlank(str)

  # prepare to parse - squeeze spaces and strip
  num = str.toString().replace(/\s+/g, ' ').trim()

  # pluck off extension, tries several variants
  [num, ext] = num.split(/\s*(?:, ?)?(?:ext?\.?|x|#|:|,)\s*/i, 2)
  ext = ext.replace(/\D+/g, "") if ext

  # allow international numbers (without formatting)
  if num =~ /^\+([-+#*.,\d ]+)$/
    etc = _[1].replace(/[^#*,\d]+/g, "")
    if etc.replace(/\D+/g, "").length >= 6 # minimum digits
      if etc =~ /^1(\d{10})$/
        [num, ext] = [_[1], ""]
      else
        return "+#{etc}"

  # adjust base number, allow only domestic phones
  num = num.replace(/^[^2-9]*/, "").replace(/\D+/g, "")

  # assemble final number
  if num =~ /^([2-9][0-8][0-9])([2-9]\d\d)(\d{4})$/
    num = "(#{_[1]}) #{_[2]}-#{_[3]}"
    num += ", ext. #{ext}" if ext
  else
    num = null

  num

# -----------------------------------------------------------------------------
# Validator registry (uses =~; assumes runtime sets '_' captures)
# -----------------------------------------------------------------------------
export validators =
    # Numbers & money
  id:        (v) -> v[/^([1-9]\d{0,19})$/]            and parseInt(_[1])
  whole:     (v) -> v[/^(0|[1-9]\d{0,19})$/]          and parseInt(_[1])
  decimal:   (v) -> v[/^([-+]?\d+(?:\.\d*)?|\.\d+)$/] and parseFloat(_[1])
  money:     (v) -> v[/^([-+]?\d+(?:\.\d*)?|\.\d+)$/] and Math.round(parseFloat(_[1]) * 100)

  # Strings & formatting
  string:    (v) -> v.replace(/\s\s+/g, ' ')
  text:      (v) -> v.replace(/  +/g, ' ')

  # Name/address (plug your own formatters here)
  name:      (v) -> v.replace(/\s+/g, ' ').trim()
  address:   (v) -> v.replace(/\s+/g, ' ').trim()

  # Time & date (stubs; replace with your real parsers)
  time:      (v) -> v[/^([01]?\d|2[0-3]):[0-5]\d(:[0-5]\d)?$/] and _[0]
  date:      (v) -> v[/^\d{4}-\d{2}-\d{2}$/]                   and _[0]
  dateutc:   (v) -> v[/^\d{4}-\d{2}-\d{2}Z?$/]                 and _[0]

  # Booleans
  truthy:    (v) -> (v =~ /^(true|t|1|yes|y|on)$/i)  and true
  falsy:     (v) -> (v =~ /^(false|f|0|no|n|off)$/i) and true
  bool:      (v) -> (v =~ /^(true|t|1|yes|y|on|false|f|0|no|n|off)$/i) and (v =~ /^(true|t|1|yes|y|on)$/i)

  # Contact, geo, identity
  email:     (v) -> v[/^([a-zA-Z0-9._%+-]+)@([a-zA-Z0-9.-]+\.[a-zA-Z]{2,})$/] and _[0]
  state:     (v) -> v[/^([a-z][a-z])$/i]              and _[1].toUpperCase()
  zip:       (v) -> v[/^(\d{5})/]                     and _[1]
  zipplus4:  (v) -> v[/^(\d{5})-?(\d{4})$/]           and "#{_[1]}-#{_[2]}"
  ssn:       (v) -> v[/^(\d{3})-?(\d{2})-?(\d{4})$/]  and "#{_[1]}#{_[2]}#{_[3]}"
  sex:       (v) -> v[/^(m|male|f|female|o|other)$/i] and _[1][0].toLowerCase()

  # Phone (US simple; replace with your formatter)
  phone:     (v) -> toPhone(v)

  # Web & technical
  username:  (v) -> v[/^([a-zA-Z0-9_-]{3,20})$/]        and _[1].toLowerCase()
  ip:        (v) -> v[/^(?:\d{1,3}\.){3}\d{1,3}$/]      and _[0]
  mac:       (v) -> v[/^([0-9a-fA-F]{2})(?:[:-]?)([0-9a-fA-F]{2})(?:[:-]?)([0-9a-fA-F]{2})(?:[:-]?)([0-9a-fA-F]{2})(?:[:-]?)([0-9a-fA-F]{2})(?:[:-]?)([0-9a-fA-F]{2})$/] and "#{_[1]}:#{_[2]}:#{_[3]}:#{_[4]}:#{_[5]}:#{_[6]}".toLowerCase()
  url:       (v) -> v[/^(https?:\/\/)?([\da-z\.-]+)\.([a-z\.]{2,6})([\/\w\.-]*)*\/?$/] and _[0]
  color:     (v) -> v[/^#?([0-9a-fA-F]{3}|[0-9a-fA-F]{6})$/] and "##{_[1].toLowerCase()}"
  uuid:      (v) -> v[/^([0-9a-f]{8})-?([0-9a-f]{4})-?([0-9a-f]{4})-?([0-9a-f]{4})-?([0-9a-f]{12})$/i] and "#{_[1]}-#{_[2]}-#{_[3]}-#{_[4]}-#{_[5]}".toLowerCase()
  semver:    (v) -> v[/^(\d+)\.(\d+)\.(\d+)(?:-([a-zA-Z0-9-]+(?:\.[a-zA-Z0-9-]+)*))?(?:\+([a-zA-Z0-9-]+(?:\.[a-zA-Z0-9-]+)*))?$/] and _[0]

  # Time formats & currency (alt)
  time24:    (v) -> v[/^([01]?[0-9]|2[0-3]):([0-5][0-9])(?::([0-5][0-9]))?$/] and _[0]
  time12:    (v) -> v[/^(1[0-2]|0?[1-9]):([0-5][0-9])\s?(am|pm)$/i]            and _[0].toLowerCase()
  currency:  (v) -> v[/^\$?(\d{1,3}(?:,\d{3})*(?:\.\d{2})?)$/]                 and parseFloat(_[1].replace(/,/g,''))

  # Collections & structured
  array:     (v) -> (Array.isArray(v) and v) or null
  hash:      (v) -> ((v? and typeof v == 'object') and v) or null
  json:      (v) ->
    if typeof v == 'string'
      try JSON.parse(v) catch then null
    else if typeof v == 'object' then v else null

  # Slugs & ids list
  slug:      (v) -> v[/^([a-z0-9]+(?:-[a-z0-9]+)*)$/] and _[1]
  ids:       (v) ->
    cleaned = v.replace(/[, ]+/g, ' ').trim()
    return null unless cleaned
    try
      nums = []
      for part in cleaned.split(' ')
        return null unless part[/^([1-9]\d{0,19})$/]
        nums.push parseInt(_[1])
      Array.from(new Set(nums)).sort((a,b) -> a-b)
    catch then null

export registerValidator = (name, fn) -> validators[name] = fn
export getValidator      = (name)     -> validators[name]

# -----------------------------------------------------------------------------
# read() — registry-driven, Sinatra-style ergonomics
# -----------------------------------------------------------------------------
export read = (keyOrTag = null, tagOrMiss = null, missOrNil = null) ->
  store = requestContext.getStore()
  throw new Error 'read() called outside request context — did you add withHelpers?' unless store?

  data = store.data or {}

  # resolve params
  key  = null
  tag  = null
  miss = null

  if keyOrTag? and tagOrMiss? or missOrNil? isnt null
    key  = keyOrTag
    tag  = tagOrMiss
    miss = missOrNil
  else
    # read() -> whole payload
    key  = null
    tag  = keyOrTag
    miss = tagOrMiss

  raw = if key? then data[key] else data

  # No tag? return as-is (useful for echo endpoints)
  return raw unless tag?

  # Required suffix "!"
  required = false
  if typeof tag is 'string' and tag.endsWith('!')
    required = true
    tag = tag.slice(0, -1)

  v = raw

  # 1) Named validator
  if typeof tag is 'string'
    fn = getValidator(tag)
    v = if fn then fn(v) else null

  # 2) Enumerations
  else if Array.isArray(tag)
    v = if tag.includes(String(v)) then String(v) else null

  # 3) Regex
  else if tag instanceof RegExp
    v = v[tag] or null

  # 4) Range / constraints
  else if typeof tag is 'object' and (tag?.start? or tag?.end?)
    n = parseInt(v)
    v = if not isNaN(n) and (not tag.start? or n >= tag.start) and (not tag.end? or n <= tag.end) then n else null
  else if typeof tag is 'object' and (tag?.min? or tag?.max?)
    # number or string length
    if typeof v is 'number' or (v =~ /^[-+]?\d+$/)
      n = (typeof v is 'number') and v or parseInt(String(v))
      ok = not isNaN(n)
      ok = false if tag.min? and n < tag.min
      ok = false if tag.max? and n > tag.max
      v = ok and n or null
    else
      s = String(v or '')
      ok = true
      ok = false if tag.min? and s.length < tag.min
      ok = false if tag.max? and s.length > tag.max
      v = ok and s or null

  # Required / optional behavior
  isBlank = (x) -> x is null or x is undefined or (typeof x is 'string' and x.trim() is '')
  if isBlank(v)
    if required
      return miss?() if typeof miss is 'function'
      throw new Error "Missing required field: #{key}"
    else
      return (miss?() if typeof miss is 'function') or miss or null

  v

# -----------------------------------------------------------------------------
# Smart wrapper: handlers can "just return" string/object/Response
# -----------------------------------------------------------------------------
smart = (fn) ->
  (c) ->
    try
      result = fn!
      if typeof result is 'string'
        first = result.split('\n')[0]
        type = if first =~ /html/i then 'html' else 'plain'
        return new Response(result, { headers: { 'Content-Type': "text/#{type}; charset=UTF-8" } })
      else if result? and typeof result is 'object'
        if result instanceof Response then return result
        return c.json(result)
      else if typeof result in ['number','boolean']
        return new Response(String(result), { headers: { 'Content-Type': 'text/plain; charset=UTF-8' } })
      return result
    catch err
      return new Response(err?.message or 'Internal Server Error',
        { status: 500, headers: { 'Content-Type': 'text/plain; charset=UTF-8' } })

# -----------------------------------------------------------------------------
# DSL: get/post/... , use, prefix/group, startHandler, start
# -----------------------------------------------------------------------------
ensureApp = ->
  return _app if _app?
  _app = new Hono()
  _app.use(withHelpers)
  _app

addRoute = (method, path, handler) ->
  full = "#{_prefix}#{path}"
  _routes.push { method, path: full, handler: smart(handler) }

export get    = (path, fn) -> addRoute 'get',    path, fn
export post   = (path, fn) -> addRoute 'post',   path, fn
export put    = (path, fn) -> addRoute 'put',    path, fn
export patch  = (path, fn) -> addRoute 'patch',  path, fn
export del    = (path, fn) -> addRoute 'delete', path, fn
export any    = (path, fn) -> for m in ['get','post','put','patch','delete','options'] then addRoute m, path, fn

export use    = (mw) -> _routes.push { use: true, mw }

export prefix = (base, fn) ->
  old = _prefix
  try
    _prefix = "#{_prefix}#{base}"
    fn?()
  finally
    _prefix = old

export group = prefix

# Build app & return fetch handler (no listener)
export startHandler = ->
  app = ensureApp()
  # apply middlewares first
  for r in _routes when r.use then app.use(r.mw)
  # then routes in order
  for r in _routes when not r.use then app[r.method](r.path, r.handler)
  app.fetch.bind(app)

# Convenience wrapper: define routes in a block and get a handler
export App = (fn) ->
  resetGlobals()
  fn?()
  startHandler()

# Start a listener (dev/simple mode). In prod, your Manager/LB would wrap this.
export start = (opts = {}) ->
  fetch = startHandler()
  host  = opts.host or '0.0.0.0'
  port  = opts.port or 8080
  server = Bun.serve
    hostname: host
    port: port
    fetch: fetch
  console.log "rip listening on http://#{host}:#{port}"
  server

# -----------------------------------------------------------------------------
# Dev hot-reloader (module) — for --hot-reload=module
# -----------------------------------------------------------------------------
export resetGlobals = ->
  _app = null
  _routes = []
  _prefix = ''
  return

export createReloader = (opts) ->
  entry = (opts?.entryPath) or opts
  debounceMs = opts?.debounceMs or 100
  maxReloadsBeforeHint = opts?.maxReloadsBeforeHint or 200

  currentHandler = null
  currentMtime   = 0
  loading        = null
  lastCheck      = 0
  reloads        = 0

  load = (mt = null) ->
    loading or= do ->
      try
        mt  = mt or (try statSync(entry).mtimeMs catch then 0)
        mod = await import("#{entry}?v=#{mt}")
        fresh = mod.default or mod

        # Normalize to a single callable handler
        if fresh?.fetch?
          # Explicit app export: bind fetch and clear any queued DSL routes
          resetGlobals()
          currentHandler = fresh.fetch.bind(fresh)
        else
          # Implicit assembly: build from queued DSL routes
          currentHandler = startHandler()
        currentMtime = mt
      finally
        loading = null
      currentHandler


  getHandler = ->
    now = Date.now()
    if not currentHandler
      await load()
    else if now - lastCheck >= debounceMs
      lastCheck = now
      mt = try statSync(entry).mtimeMs catch then 0
      if mt > currentMtime
        await load(mt)
    currentHandler

  if opts?.watchDir?
    watch opts.watchDir, { recursive: true }, (evt, file) ->
      lastCheck = 0  # force check soon

  { getHandler }
