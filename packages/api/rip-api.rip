# Rip Server Helpers - Enhanced Request Data Reading & Validation
#
# Features elegant regex validation using Rip's str[/regex/] syntax:
# - Simple matches: val[/regex/] returns full match or null
# - Capture groups: (val =~ /regex/) and _[1] for reliable access
# - Automatic type conversion and formatting for common data types
#
# This mixed approach ensures robust validation while showcasing Rip's
# expressive regex capabilities.

# Email regex (simplified version)
emailRegex = /^[^\s@]+@[^-\s@]+\.[^\s@]+$/

# Phone formatting helper
toPhone = (val) ->
  return null unless val
  digits = val.replace(/\D/g, '')
  return null if digits.length < 10
  # 10-digit format: 1234567890 -> 123-456-7890
  if digits.length == 10
    digits =~ /^(\d{3})(\d{3})(\d{4})$/ and "#{_[1]}-#{_[2]}-#{_[3]}"
  # 11-digit with country code: 11234567890 -> 123-456-7890
  else if digits.length == 11
    digits =~ /^1(\d{3})(\d{3})(\d{4})$/ and "#{_[1]}-#{_[2]}-#{_[3]}"
  else
    null

# Name formatting helper
# Capitalizes first letter of each word for names, basic formatting for addresses
toName = (val, type = 'name') ->
  return null unless val
  cleaned = val.trim().replace(/\s+/g, ' ')
  return null if cleaned.length == 0
  if type == 'name'
    # Capitalize first letter of each word
    words = cleaned.split(' ')
    capitalizedWords = words.map (word) -> word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()
    capitalizedWords.join(' ')
  else if type == 'address'
    # Basic address formatting
    cleaned
  else
    cleaned

# Boolean helpers
truthy = (val) -> val in [true, 'true', '1', 1, 'yes', 'on', 'y']
falsy = (val) -> val in [false, 'false', '0', 0, 'no', 'off', 'n']
bool = (val) -> return true if truthy(val); return false if falsy(val); null
isBlank = (val) -> not val? or val == '' or (typeof val == 'string' and val.trim() == '')

# JSON parsing helper
parseJsonSafely = (body) -> try JSON.parse(body) catch error then {}

# Date parsing helpers
parseDate = (val) -> try date = new Date(val); if isNaN(date.getTime()) then null else date.toISOString().split('T')[0] catch error then null
parseDateTime = (val) -> try date = new Date(val); if isNaN(date.getTime()) then null else date catch error then null
parseDateUTC = (val) -> try date = new Date(val); if isNaN(date.getTime()) then null else date.toISOString() catch error then null

import { requestContext } from './context.ts'

_routeQueue = []
_currentApp = null
_currentContext = null

smartRoute = (handler) ->
  (c) ->
    _currentContext = c

        # Extract and prepare data just like the middleware does
    data = await c.req.query() or {}
    if c.req.method in ['POST', 'PUT', 'PATCH']
      try
        body = await c.req.json()
        for own k, v of body
          data[k] = v
      catch error
        null

    # Store data on the context for read function
    c._ripData = data

    try
      result = await handler()  # Call handler without context - pure Sinatra style
      if typeof result == 'string'
        return c.text(result)
      else if typeof result == 'object' && result != null
        return c.json(result)
      else if typeof result == 'number' || typeof result == 'boolean'
        return c.text(result.toString())
      return result
    finally
      _currentContext = null

methods = ['get', 'post', 'put', 'patch', 'delete', 'options', 'head']

for method in methods
  Object.defineProperty global, method,
    value: do (method=method) -> (path, handler) ->
      if _currentApp?
        _currentApp[method](path, smartRoute(handler))
      else
        _routeQueue.push { method, path, handler }
    configurable: true

export withHelpers = (app) ->
  _currentApp = app

  for route in _routeQueue
    _currentApp[route.method](route.path, smartRoute(route.handler))

  _routeQueue = []

  return app

export read = (keyOrContext, key = null, tag = null, miss = null) ->
  # Pure Sinatra style - always use the current smartRoute context
  c = _currentContext
  throw new Error('read() called without context') unless c

  data = c._ripData or {}
  [key, tag, miss] = [keyOrContext, key, tag] unless key and tag and miss is not undefined
  val = if key then data[key] else data
  return val unless key and tag
  originalTag = tag
  bam = false
  if typeof tag == 'string' and tag.endsWith('!')
    tag = tag.slice(0, -1)
    bam = true
  if Array.isArray(val)
    val = if tag == 'array' then val else val.join(',')
  else if typeof val == 'object' and val?
    val = if tag == 'hash' then val else String(val)
  else
    val = String(val or '')

  # Early returns for simple cases (Ruby-style)
  if tag == 'id'    and val[/^([1-9]\d{0,19})$/]  then return parseInt(_[1])
  if tag == 'whole' and val[/^(0|[1-9]\d{0,19})$/] then return parseInt(_[1])

  # Process remaining tags with switch expression
  #
  # Regex validation patterns showcase Rip's elegant str[/regex/] syntax:
  # - val[/regex/]?.method()     for simple full-match validation
  # - (val =~ /regex/) and _[n]  for capture group access
  #
  val = switch tag
    when 'decimal'    then val[/^([-+]?\d+(?:\.\d*)?|\.\d+)$/] and parseFloat(_[1].replace(/\.$/, ''))
    when 'money'      then val[/^([-+]?\d+(?:\.\d*)?|\.\d+)$/] and Math.round(parseFloat(_[1].replace(/\.$/, '')) * 100) / 100
    when 'string'     then val.replace(/\s\s+/g, ' ')
    when 'text'       then val.replace(/  +/g, ' ')
    when 'name'       then toName(val, 'name')
    when 'phone'      then toPhone(val)
    when 'address'    then toName(val, 'address')
    when 'time'       then parseDateTime(val)
    when 'date'       then parseDate(val)
    when 'dateutc'    then parseDateUTC(val)
    when 'truthy'     then truthy(val)
    when 'falsy'      then falsy(val)
    when 'email'      then val[/^([a-zA-Z0-9._%+-]+)@([a-zA-Z0-9.-]+\.[a-zA-Z]{2,})$/]?.toLowerCase()
    when 'state'      then (val =~ /^([a-z][a-z])$/i) and _[1]?.toUpperCase()
    when 'zip'        then val[/^\d{5}/]
    when 'zipplus4'   then (val =~ /^(\d{5})-?(\d{4})$/) and "#{_[1]}-#{_[2]}"
    when 'ssn'        then (val =~ /^(\d{3})-?(\d{2})-?(\d{4})$/) and "#{_[1]}#{_[2]}#{_[3]}"
    when 'sex'        then (val =~ /^(m|male|f|female|o|other)$/i) and _[1]?[0]?.toUpperCase()
    when 'creditcard' then (val =~ /^(\d{4})-?(\d{4})-?(\d{4})-?(\d{4})$/) and "#{_[1]}-#{_[2]}-#{_[3]}-#{_[4]}"
    when 'url'        then val[/^(https?:\/\/)?([\da-z\.-]+)\.([a-z\.]{2,6})([\/\w \.-]*)*\/?$/]
    when 'username'   then (val =~ /^([a-zA-Z0-9_-]{3,20})$/) and _[1]?.toLowerCase()
    when 'color'      then (val =~ /^#?([0-9a-fA-F]{3}|[0-9a-fA-F]{6})$/) and "##{_[1]?.toLowerCase()}"
    when 'ip'         then (val =~ /^(\d{1,3})\.(\d{1,3})\.(\d{1,3})\.(\d{1,3})$/) and (if _[1..4]?.every((n) -> parseInt(n) <= 255) then _[0])
    when 'mac'        then (val =~ /^([0-9a-fA-F]{2})[:-]?([0-9a-fA-F]{2})[:-]?([0-9a-fA-F]{2})[:-]?([0-9a-fA-F]{2})[:-]?([0-9a-fA-F]{2})[:-]?([0-9a-fA-F]{2})$/) and "#{_[1]}:#{_[2]}:#{_[3]}:#{_[4]}:#{_[5]}:#{_[6]}".toLowerCase()
    when 'semver'     then val[/^(\d+)\.(\d+)\.(\d+)(?:-([a-zA-Z0-9-]+(?:\.[a-zA-Z0-9-]+)*))?$/]
    when 'uuid'       then (val =~ /^([0-9a-f]{8})-?([0-9a-f]{4})-?([0-9a-f]{4})-?([0-9a-f]{4})-?([0-9a-f]{12})$/i) and "#{_[1]}-#{_[2]}-#{_[3]}-#{_[4]}-#{_[5]}".toLowerCase()
    when 'time24'     then val[/^([01]?[0-9]|2[0-3]):([0-5][0-9])(?::([0-5][0-9]))?$/]
    when 'time12'     then val[/^(1[0-2]|0?[1-9]):([0-5][0-9])\s?(am|pm)$/i]?.toLowerCase()
    when 'currency'   then (val =~ /^\$?(\d{1,3}(?:,\d{3})*(?:\.\d{2})?)$/) and parseFloat(_[1]?.replace(/,/g, ''))
    when 'slug'       then (val =~ /^([a-z0-9]+(?:-[a-z0-9]+)*)$/) and _[1]
    # when 'bool'       then val = bool(val); val = null unless val?
    # when 'array'      then val = if Array.isArray(data[key]) then data[key] else null
    # when 'hash'       then val = if typeof data[key] == 'object' and data[key]? then data[key] else null
    # when 'json'       then val = if typeof val == 'string' then try JSON.parse(val) catch error then null else if val? and typeof val == 'object' then val else null
    # when 'ids'        then val = if val and val.trim() then try cleanVal = val.replace(/[, ]+/g, ' ').trim(); idList = cleanVal.split(' '); validIds = []; for id in idList temp = (id[/^([1-9]\d{0,19})$/] and parseInt(_[1])); if temp then validIds.push(temp) else throw new Error("Invalid ID: #{id}"); result = validIds.filter((id, index, arr) -> arr.indexOf(id) == index).sort((a, b) -> a - b); if result.length == 0 then null else result catch error then null
    else
      if Array.isArray(originalTag)
        val = if originalTag.includes(val) then val else null
        if val == null and typeof miss == 'function' then miss()
      else if originalTag instanceof RegExp
        val = if originalTag.test(val) then val else null
        if val == null and typeof miss == 'function' then miss()
      else if typeof originalTag == 'object' and originalTag?.start? and originalTag?.end?
        numVal = parseInt(val)
        val = if !isNaN(numVal) and numVal >= originalTag.start and numVal <= originalTag.end then numVal else null
      else if Array.isArray(originalTag) and originalTag.length == 2 and typeof originalTag[0] == 'number' and typeof originalTag[1] == 'number'
        start = Math.min(originalTag[0], originalTag[1])
        end = Math.max(originalTag[0], originalTag[1])
        if tag in ['id', 'whole', 'decimal', 'money'] or (typeof val == 'number')
          numVal = parseInt(val)
          val = if !isNaN(numVal) and numVal >= start and numVal <= end then numVal else null
        else if typeof val == 'string'
          strLen = val.length
          val = if strLen >= start and strLen <= end then val else null
        else
          val = null
      else if typeof originalTag == 'object' and (originalTag?.min? or originalTag?.max?)
        minVal = originalTag.min
        maxVal = originalTag.max
        if tag in ['id', 'whole', 'decimal', 'money'] or (typeof val == 'number')
          numVal = parseInt(val)
          if !isNaN(numVal)
            valid = true
            valid = false if minVal? and numVal < minVal
            valid = false if maxVal? and numVal > maxVal
            val = if valid then numVal else null
          else
            val = null
        else if typeof val == 'string'
          strLen = val.length
          valid = true
          valid = false if minVal? and strLen < minVal
          valid = false if maxVal? and strLen > maxVal
          val = if valid then val else null
        else
          val = null

  if isBlank(val)
    if bam
      throw new Error("Missing required field: #{key}")
    else
      val = if typeof miss == 'function' then miss() else miss
  val
