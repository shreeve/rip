# The `rip` utility. Handles command-line compilation of Rip
# into various forms: saved into `.js` files or printed to stdout
# or recompiled every time the source is saved, or printed as a token
# token stream or as the syntax tree.

# External dependencies.
import fs             from 'fs'
import path           from 'path'
import * as helpers   from './helpers'
import Rip   from './index'
import {spawn, exec}  from 'child_process'
import {EventEmitter} from 'events'

# Allow Rip to emit Node.js events.
helpers.extend Rip, new EventEmitter

printLine = (line) -> process.stdout.write line + '\n'
printWarn = (line) -> process.stderr.write line + '\n'

hidden = (file) -> /^\.|~$/.test file

# ==============================================================================
# OptionParser
# ==============================================================================

# A simple **OptionParser** class to parse option flags from the command-line.
# Use it like so:
#
#     parser  = new OptionParser switches, helpBanner
#     options = parser.parse process.argv
#
# The first non-option is considered to be the start of the file (and file
# option) list, and all subsequent arguments are left unparsed.
#
# The `rip` command uses an instance of **OptionParser** to parse its
# command-line arguments in `src/command.rip`.
class OptionParser

  # Initialize with a list of valid options, in the form:
  #
  #     [short-flag, long-flag, description]
  #
  # Along with an optional banner for the usage help.
  constructor: (ruleDeclarations, @banner) ->
    @rules = buildRules ruleDeclarations

  # Parse the list of arguments, populating an `options` object with all of the
  # specified options, and return it. Options after the first non-option
  # argument are treated as arguments. `options.arguments` will be an array
  # containing the remaining arguments. This is a simpler API than many option
  # parsers that allow you to attach callback actions for every flag. Instead,
  # you're responsible for interpreting the options object.
  parse: (args) ->
    # The Rip option parser is a little odd; options after the first
    # non-option argument are treated as non-option arguments themselves.
    # Optional arguments are normalized by expanding merged flags into multiple
    # flags. This allows you to have `-wl` be the same as `--watch --lint`.
    # Note that executable scripts with a shebang (`#!`) line should use the
    # line `#!/usr/bin/env rip`, or `#!/absolute/path/to/rip`, without a
    # `--` argument after, because that will fail on Linux (see #3946).
    {rules, positional} = normalizeArguments args, @rules.flagDict
    options = {}

    # The `argument` field is added to the rule instance non-destructively by
    # `normalizeArguments`.
    for {hasArgument, argument, isList, name} in rules
      if hasArgument
        if isList
          options[name] ?= []
          options[name].push argument
        else
          options[name] = argument
      else
        options[name] = true

    if positional[0] is '--'
      options.doubleDashed = yes
      positional = positional[1..]

    options.arguments = positional
    options

  # Return the help text for this **OptionParser**, listing and describing all
  # of the valid options, for `--help` and such.
  help: ->
    lines = []
    lines.unshift "#{@banner}\n" if @banner
    for rule in @rules.ruleList
      spaces  = 15 - rule.longFlag.length
      spaces  = if spaces > 0 then helpers.repeat ' ', spaces else ''
      letPart = if rule.shortFlag then rule.shortFlag + ', ' else '    '
      lines.push '  ' + letPart + rule.longFlag + spaces + rule.description
    "\n#{ lines.join('\n') }\n"

# Helpers for OptionParser
# ------------------------

# Regex matchers for option flags on the command line and their rules.
LONG_FLAG  = /^(--\w[\w\-]*)/
SHORT_FLAG = /^(-\w)$/
MULTI_FLAG = /^-(\w{2,})/
# Matches the long flag part of a rule for an option with an argument. Not
# applied to anything in process.argv.
OPTIONAL   = /\[(\w+(\*?))\]/

# Build and return the list of option rules. If the optional *short-flag* is
# unspecified, leave it out by padding with `null`.
buildRules = (ruleDeclarations) ->
  ruleList = for tuple in ruleDeclarations
    tuple.unshift null if tuple.length < 3
    buildRule tuple...
  flagDict = {}
  for rule in ruleList
    # `shortFlag` is null if not provided in the rule.
    for flag in [rule.shortFlag, rule.longFlag] when flag?
      if flagDict[flag]?
        throw new Error "flag #{flag} for switch #{rule.name}
          was already declared for switch #{flagDict[flag].name}"
      flagDict[flag] = rule

  {ruleList, flagDict}

# Build a rule from a `-o` short flag, a `--output [DIR]` long flag, and the
# description of what the option does.
buildRule = (shortFlag, longFlag, description) ->
  match     = longFlag.match(OPTIONAL)
  shortFlag = shortFlag?.match(SHORT_FLAG)[1]
  longFlag  = longFlag.match(LONG_FLAG)[1]
  {
    name:         longFlag.replace /^--/, ''
    shortFlag:    shortFlag
    longFlag:     longFlag
    description:  description
    hasArgument:  !!(match and match[1])
    isList:       !!(match and match[2])
  }

normalizeArguments = (args, flagDict) ->
  rules = []
  positional = []
  needsArgOpt = null
  for arg, argIndex in args
    # If the previous argument given to the script was an option that uses the
    # next command-line argument as its argument, create copy of the option's
    # rule with an `argument` field.
    if needsArgOpt?
      withArg = Object.assign {}, needsArgOpt.rule, {argument: arg}
      rules.push withArg
      needsArgOpt = null
      continue

    multiFlags = arg.match(MULTI_FLAG)?[1]
      .split('')
      .map (flagName) -> "-#{flagName}"
    if multiFlags?
      multiOpts = multiFlags.map (flag) ->
        rule = flagDict[flag]
        unless rule?
          throw new Error "unrecognized option #{flag} in multi-flag #{arg}"
        {rule, flag}
      # Only the last flag in a multi-flag may have an argument.
      [innerOpts..., lastOpt] = multiOpts
      for {rule, flag} in innerOpts
        if rule.hasArgument
          throw new Error "cannot use option #{flag} in multi-flag #{arg} except
          as the last option, because it needs an argument"
        rules.push rule
      if lastOpt.rule.hasArgument
        needsArgOpt = lastOpt
      else
        rules.push lastOpt.rule
    else if ([LONG_FLAG, SHORT_FLAG].some (pat) -> arg.match(pat)?)
      singleRule = flagDict[arg]
      unless singleRule?
        throw new Error "unrecognized option #{arg}"
      if singleRule.hasArgument
        needsArgOpt = {rule: singleRule, flag: arg}
      else
        rules.push singleRule
    else
      # This is a positional argument.
      positional = args[argIndex..]
      break

  if needsArgOpt?
    throw new Error "value required for #{needsArgOpt.flag}, but it was the last
    argument provided"
  {rules, positional}

# ==============================================================================
# Main logic here
# ==============================================================================

# The help banner that is printed in conjunction with `-h`/`--help`.
BANNER = '''
  Usage: rip [options] path/to/script.rip [args]

  If called without options, `rip` will run your script.
'''

# The list of all the valid option flags that `rip` knows how to handle.
SWITCHES = [
  [      '--ast',               'generate an abstract syntax tree of nodes']
  ['-b', '--bare',              'compile without a top-level function wrapper']
  ['-c', '--compile',           'compile to JavaScript and save as .js files']
  ['-e', '--eval',              'pass a string from the command line as input']
  ['-h', '--help',              'display this help message']
  ['-j', '--join [FILE]',       'concatenate the source Rip before compiling']
  ['-m', '--map',               'generate source map and save as .js.map files']
  ['-M', '--inline-map',        'generate source map and include it directly in output']
  ['-n', '--nodes',             'print out the parse tree that the parser produces']
  [      '--nodejs [ARGS]',     'pass options directly to the "node" binary']
  ['-H', '--no-header',         'suppress the "Generated by" header']
  ['-o', '--output [PATH]',     'set the output path or path/filename for compiled JavaScript']
  ['-p', '--print',             'print out the compiled JavaScript']
  ['-s', '--stdio',             'listen for and compile scripts over stdio']
  [      '--tokens',            'print out the tokens that the lexer/rewriter produce']
  ['-v', '--version',           'display the version number']
  ['-w', '--watch',             'watch scripts for changes and rerun commands']
]

# Top-level objects shared by all the functions.
opts         = {}
sources      = []
sourceCode   = []
notSources   = {}
watchedDirs  = {}
optionParser = null

export buildCSOptionParser = ->
  new OptionParser SWITCHES, BANNER

# Run `rip` by parsing passed options and determining what action to take.
# Many flags cause us to divert before compiling anything. Flags passed after
# `--` will be passed verbatim to your script as arguments in `process.argv`
export run = ->
  optionParser = buildCSOptionParser()
  try parseOptions()
  catch err
    console.error "option parsing error: #{err.message}"
    process.exit 1

  if (not opts.doubleDashed) and (opts.arguments[1] is '--')
    printWarn '''
      rip was invoked with '--' as the second positional argument, which is
      now deprecated. To pass '--' as an argument to a script to run, put an
      additional '--' before the path to your script.

      '--' will be removed from the argument list.
    '''
    printWarn "The positional arguments were: #{JSON.stringify opts.arguments}"
    opts.arguments = [opts.arguments[0]].concat opts.arguments[2..]

  return forkNode()                             if opts.nodejs
  return usage()                                if opts.help
  return version()                              if opts.version
  return compileStdio()                         if opts.stdio
  return compileScript null, opts.arguments[0]  if opts.eval
  return usage()                                unless opts.arguments.length
  literals = if opts.run then opts.arguments.splice 1 else []
  process.argv = process.argv[0..1].concat literals
  process.argv[0] = 'rip'

  if opts.output
    outputBasename = path.basename opts.output
    if '.' in outputBasename and
       outputBasename not in ['.', '..'] and
       not helpers.ends(opts.output, path.sep)
      # An output filename was specified, e.g. `/dist/scripts.js`.
      opts.outputFilename = outputBasename
      opts.outputPath = path.resolve path.dirname opts.output
    else
      # An output path was specified, e.g. `/dist`.
      opts.outputFilename = null
      opts.outputPath = path.resolve opts.output

  if opts.join
    opts.join = path.resolve opts.join
    console.error '''

    The --join option is deprecated and will be removed in a future version.

    If for some reason it's necessary to share local variables between files,
    replace...

        $ rip --compile --join bundle.js -- a.rip b.rip c.rip

    with...

        $ cat a.rip b.rip c.rip | rip --compile --stdio > bundle.js

    '''
  for source in opts.arguments
    source = path.resolve source
    compilePath source, yes, source

# Compile a path, which could be a script or a directory. If a directory
# is passed, recursively compile all '.rip' files, including subdirectories.
compilePath = (source, topLevel, base) ->
  return if source in sources   or
            watchedDirs[source] or
            not topLevel and (notSources[source] or hidden source)
  try
    stats = fs.statSync source
  catch err
    if err.code is 'ENOENT'
      console.error "File not found: #{source}"
      process.exit 1
    throw err
  if stats.isDirectory()
    if path.basename(source) is 'node_modules'
      notSources[source] = yes
      return
    if opts.run
      compilePath findDirectoryIndex(source), topLevel, base
      return
    watchDir source, base if opts.watch
    try
      files = fs.readdirSync source
    catch err
      if err.code is 'ENOENT' then return else throw err
    for file in files
      compilePath (path.join source, file), no, base
  else if topLevel or helpers.isRip source
    sources.push source
    sourceCode.push null
    delete notSources[source]
    watch source, base if opts.watch
    try
      code = fs.readFileSync source
    catch err
      if err.code is 'ENOENT' then return else throw err
    compileScript source, code.toString(), base
  else
    notSources[source] = yes

findDirectoryIndex = (source) ->
  for ext in Rip.FILE_EXTENSIONS
    index = path.join source, "index#{ext}"
    try
      return index if (fs.statSync index).isFile()
    catch err
      throw err unless err.code is 'ENOENT'
  console.error "Missing index.rip in #{source}"
  process.exit 1

# Compile a single source script, containing the given code, according to the
# requested options. If evaluating the script directly, set `__filename`,
# `__dirname` and `module.filename` to be correct relative to the script's path.
compileScript = (file, input, base = null) ->
  options = compileOptions file, base
  try
    task = {file, input, options}
    Rip.emit 'compile', task
    if opts.tokens
      printTokens Rip.tokens task.input, task.options
    else if opts.nodes
      printLine Rip.nodes(task.input, task.options).toString().trim()
    else if opts.ast
      compiled = Rip.compile task.input, task.options
      printLine JSON.stringify(compiled, null, 2)
    else if opts.run
      Rip.run task.input, task.options
    else if opts.join and task.file isnt opts.join
      sourceCode[sources.indexOf(task.file)] = task.input
      compileJoin()
    else
      compiled = Rip.compile task.input, task.options
      task.output = compiled
      if opts.map
        task.output = compiled.js
        task.sourceMap = compiled.v3SourceMap

      Rip.emit 'success', task
      if opts.print
        printLine task.output.trim()
      else if opts.compile or opts.map
        saveTo = if opts.outputFilename and sources.length is 1
          path.join opts.outputPath, opts.outputFilename
        else
          options.jsPath
        writeJs base, task.file, task.output, saveTo, task.sourceMap
  catch err
    Rip.emit 'failure', err, task
    return if Rip.listeners('failure').length
    message = err?.stack or "#{err}"
    if opts.watch
      printLine message + '\x07'
    else
      printWarn message
      process.exit 1

# Attach the appropriate listeners to compile scripts incoming over **stdin**,
# and write them back to **stdout**.
compileStdio = ->
  if opts.map
    console.error '--stdio and --map cannot be used together'
    process.exit 1
  buffers = []
  stdin = process.openStdin()
  stdin.on 'data', (buffer) ->
    buffers.push buffer if buffer
  stdin.on 'end', ->
    compileScript null, Buffer.concat(buffers).toString()

# If all of the source files are done being read, concatenate and compile
# them together.
joinTimeout = null
compileJoin = ->
  return unless opts.join
  unless sourceCode.some((code) -> code is null)
    clearTimeout joinTimeout
    joinTimeout = wait 100, ->
      compileScript opts.join, sourceCode.join('\n'), opts.join

# Watch a source Rip file using `fs.watch`, recompiling it every
# time the file is updated. May be used in combination with other options,
# such as `--print`.
watch = (source, base) ->
  watcher        = null
  prevStats      = null
  compileTimeout = null

  watchErr = (err) ->
    throw err unless err.code is 'ENOENT'
    return unless source in sources
    try
      rewatch()
      compile()
    catch
      removeSource source, base
      compileJoin()

  compile = ->
    clearTimeout compileTimeout
    compileTimeout = wait 25, ->
      fs.stat source, (err, stats) ->
        return watchErr err if err
        return rewatch() if prevStats and
                            stats.size is prevStats.size and
                            stats.mtime.getTime() is prevStats.mtime.getTime()
        prevStats = stats
        fs.readFile source, (err, code) ->
          return watchErr err if err
          compileScript(source, code.toString(), base)
          rewatch()

  startWatcher = ->
    watcher = fs.watch source
    .on 'change', compile
    .on 'error', (err) ->
      throw err unless err.code is 'EPERM'
      removeSource source, base

  rewatch = ->
    watcher?.close()
    startWatcher()

  try
    startWatcher()
  catch err
    watchErr err

# Watch a directory of files for new additions.
watchDir = (source, base) ->
  watcher        = null
  readdirTimeout = null

  startWatcher = ->
    watcher = fs.watch source
    .on 'error', (err) ->
      throw err unless err.code is 'EPERM'
      stopWatcher()
    .on 'change', ->
      clearTimeout readdirTimeout
      readdirTimeout = wait 25, ->
        try
          files = fs.readdirSync source
        catch err
          throw err unless err.code is 'ENOENT'
          return stopWatcher()
        for file in files
          compilePath (path.join source, file), no, base

  stopWatcher = ->
    watcher.close()
    removeSourceDir source, base

  watchedDirs[source] = yes
  try
    startWatcher()
  catch err
    throw err unless err.code is 'ENOENT'

removeSourceDir = (source, base) ->
  delete watchedDirs[source]
  sourcesChanged = no
  for file in sources when source is path.dirname file
    removeSource file, base
    sourcesChanged = yes
  compileJoin() if sourcesChanged

# Remove a file from our source list, and source code cache. Optionally remove
# the compiled JS version as well.
removeSource = (source, base) ->
  index = sources.indexOf source
  sources.splice index, 1
  sourceCode.splice index, 1
  unless opts.join
    silentUnlink outputPath source, base
    silentUnlink outputPath source, base, '.js.map'
    timeLog "removed #{source}"

silentUnlink = (path) ->
  try
    fs.unlinkSync path
  catch err
    throw err unless err.code in ['ENOENT', 'EPERM']

# Get the corresponding output JavaScript path for a source file.
outputPath = (source, base, extension=".js") ->
  basename  = helpers.baseFileName source, yes
  srcDir    = path.dirname source
  dir = unless opts.outputPath
    srcDir
  else if source is base
    opts.outputPath
  else
    path.join opts.outputPath, path.relative base, srcDir
  path.join dir, basename + extension

# Recursively mkdir, like `mkdir -p`.
mkdirp = (dir, fn) ->
  mode = 0o777 & ~process.umask()

  do mkdirs = (p = dir, fn) ->
    fs.exists p, (exists) ->
      if exists
        fn()
      else
        mkdirs path.dirname(p), ->
          fs.mkdir p, mode, (err) ->
            return fn err if err
            fn()

# Write out a JavaScript source file with the compiled code. By default, files
# are written out in `cwd` as `.js` files with the same name, but the output
# directory can be customized with `--output`.
#
# If `generatedSourceMap` is provided, this will write a `.js.map` file into the
# same directory as the `.js` file.
writeJs = (base, sourcePath, js, jsPath, generatedSourceMap = null) ->
  sourceMapPath = "#{jsPath}.map"
  jsDir  = path.dirname jsPath
  compile = ->
    if opts.compile
      js = ' ' if js.length <= 0
      if generatedSourceMap then js = "#{js}\n//# sourceMappingURL=#{helpers.baseFileName sourceMapPath}\n"
      fs.writeFile jsPath, js, (err) ->
        if err
          printLine err.message
          process.exit 1
        else if opts.compile and opts.watch
          timeLog "compiled #{sourcePath}"
    if generatedSourceMap
      fs.writeFile sourceMapPath, generatedSourceMap, (err) ->
        if err
          printLine "Could not write source map: #{err.message}"
          process.exit 1
  fs.exists jsDir, (itExists) ->
    if itExists then compile() else mkdirp jsDir, compile

# Convenience for cleaner setTimeouts.
wait = (milliseconds, func) -> setTimeout func, milliseconds

# When watching scripts, it's useful to log changes with the timestamp.
timeLog = (message) ->
  console.log "#{(new Date).toLocaleTimeString()} - #{message}"

# Pretty-print a stream of tokens, sans location data.
printTokens = (tokens) ->
  strings = for token in tokens
    tag = token[0]
    value = token[1].toString().replace(/\n/, '\\n')
    "[#{tag} #{value}]"
  printLine strings.join(' ')

# Use the [OptionParser module](optparse.html) to extract all options from
# `process.argv` that are specified in `SWITCHES`.
parseOptions = ->
  o = opts      = optionParser.parse process.argv[2..]
  o.compile     or=  !!o.output
  o.run         = not (o.compile or o.print or o.map)
  o.print       = !!  (o.print or (o.eval or o.stdio and o.compile))

# The compile-time options to pass to the Rip compiler.
compileOptions = (filename, base) ->
  answer =
    filename: filename
    bare: opts.bare
    header: opts.compile and not opts['no-header']
    sourceMap: opts.map
    inlineMap: opts['inline-map']
    ast: opts.ast

  if filename
    if base
      cwd = process.cwd()
      jsPath = outputPath filename, base
      jsDir = path.dirname jsPath
      answer = helpers.merge answer, {
        jsPath
        sourceRoot: path.relative(jsDir, cwd) + path.sep
        sourceFiles: [path.relative cwd, filename]
        generatedFile: helpers.baseFileName(jsPath)
      }
    else
      answer = helpers.merge answer,
        sourceRoot: ""
        sourceFiles: [helpers.baseFileName filename]
        generatedFile: helpers.baseFileName(filename, yes) + ".js"
  answer

# Start up a new Node.js instance with the arguments in `--nodejs` passed to
# the `node` binary, preserving the other options.
forkNode = ->
  nodeArgs = opts.nodejs.split /\s+/
  args     = process.argv[1..]
  args.splice args.indexOf('--nodejs'), 2
  p = spawn process.execPath, nodeArgs.concat(args),
    cwd:        process.cwd()
    env:        process.env
    stdio:      [0, 1, 2]
  for signal in ['SIGINT', 'SIGTERM']
    process.on signal, do (signal) ->
      -> p.kill signal
  p.on 'exit', (code) -> process.exit code

# Print the `--help` usage message and exit. Deprecated switches are not
# shown.
usage = ->
  printLine optionParser.help()

# Print the `--version` message and exit.
version = ->
  printLine "Rip version #{Rip.VERSION}"
