---
description: Guardrails for @rip/server architecture and implementation.
globs: "packages/server/**/*.{ts,tsx}, packages/bun/**/*.ts"
alwaysApply: false
---

## Core architecture
- Use per-worker Unix sockets; one-inflight-per-worker.
- Use control socket for JOIN/QUIT; no shared-socket design.
- LB retries: on 503 with `Rip-Worker-Busy: 1`, try another worker; strip internal headers.
- Queue backpressure: respect `--max-queue` and `--queue-timeout-ms`.

## Hot reload
- Support hotReload: `none | process | module`.
- Process mode: manager mtime-poller + rolling restart.
- Module mode: worker mtime check (rate-limited ~100ms) + cache-busting import; cap reloads via `maxReloads`.

## Flags/config
- Use `parseFlags()` pattern in `packages/server/utils.ts`.
- Prefer `coerceInt()` for env/flag ints; add new flags there.

## Logging/status
- Human or JSON logs only; use `--json-logging` for automation.
- Keep `/status` minimal; strip `date` header on proxied responses.

## Security defaults
- Worker responses default `Cache-Control: no-store`.
- Plan for HTTP→HTTPS redirect/HSTS via flags; do not hardcode.

## Avoid
- No shared-socket legacy patterns.
- Don’t introduce Express/Koa; prefer Hono for app code.
- Avoid global mutable state across requests.

## Testing
- Use `bun test` for any new utils/flag parsing.
- Simulate busy worker and queue timeout cases.

