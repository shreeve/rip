import { schema as Schema } from './builder'

export default Schema ->
  # Table with custom primary key (bigint) - showcasing both syntaxes
  @table 'accounts', primary_key: 'AccountNum', id: 'bigint', ->
    @string   'Description', [""]                                           # Type-based: array for default
    @integer  'AcctType!', 1, [0], unsigned: true                          # Type-based: size, default, options
    @string   'BankNumber', default: ""                                     # Named: cleaner for simple cases
    @integer  'Inactive!', size: 1, default: 0, unsigned: true             # Named: explicit and clear
    @integer  'AccountColor!', [0]                                          # Type-based: compact for simple default

  # Various column types with different default patterns
  @table 'appointments', ->
    @bigint    'PatNum!'                                      # Required bigint
    @datetime  'DateTimeLastActive!', ["0001-01-01 00:00:00"] # Array default
    @date      'AdjDate!', ["0001-01-01"]                     # Date with array default
    @float     'AdjAmt!', [0.0]                               # Float with default
    @text      'AdjNote'                                      # Optional text
    @timestamp 'SecDateTEdit!'                                       # Timestamp field
    @boolean   'RteNasCan'                                    # Optional boolean
    @time      'StartTime!', ["2000-01-01 00:00:00"]          # Time field

    # Various index patterns
    @index     'PatNum'                                 # Simple index
    @index     ['AdjDate', 'PatNum'], name: 'AdjDatePN' # Composite index with name
    @index     'Description', name: 'Description', 100  # Index with length limit

  # Binary fields with size options
  @table 'images', ->
    @binary    'Data!', size: 'long'     # Binary with size option
    @binary    'Thumbnail', size: 'long' # Binary with size option
    @string    'ImageType!', 10          # String with size

  # Complex indexes with many columns
  @table 'claims', ->
    @bigint    'ClaimNum!'
    @bigint    'PatNum!'
    @integer   'ClaimStatus!', 1
    @integer   'ClaimType!', 1
    @date      'DateSent!'
    @bigint    'PlanNum!'
    @date      'DateService!'
    @bigint    'ProvTreat!'
    @decimal   'ClaimFee!', 10, 2
    @bigint    'ClinicNum!'

    # Complex multi-column indexes
    @index     ['PatNum', 'ClaimStatus', 'ClaimType', 'DateSent'], name: 'PatStatusTypeDate'
    @index     ['PlanNum', 'ClaimStatus', 'ClaimType', 'PatNum', 'ClaimNum', 'DateService', 'ProvTreat', 'ClaimFee', 'ClinicNum'], name: 'indexOutClaimCovering'

  # Index with length constraints on specific columns
  @table 'messages', ->
    @datetime  'MsgDateTime!'
    @integer   'SentOrReceived!', 1
    @string    'RecipientAddress!', 100
    @string    'FromAddress!', 100
    @text      'MsgText!'

    @index     ['SentOrReceived', 'RecipientAddress', 'FromAddress'], name: 'MsgHistoricAddresses', length: { RecipientAddress: 50, FromAddress: 50 }
    @index     'MsgText', name: 'MsgText', 100                             # Index with length limit

  # Table with no timestamps (some tables don't have them)
  @table 'lookups', timestamps: false, ->
    @string    'Code!', 20
    @string    'Description!', 100
    @integer   'SortOrder!', [0]

  # Different string sizes and patterns
  @table 'various_strings', ->
    @string    'SmallStr', 3           # Very small string
    @string    'MediumStr', 50         # Medium string
    @string    'LargeStr', 2000        # Large string
    @string    'HugeStr', 4000         # Very large string
    @string    'DefaultEmptyStr', [""] # Default empty string
    @string    'NoSizeStr'             # No size specified

  # All numeric types with various options
  @table 'numerics', ->
    @integer   'TinyInt', 1        # 1 byte integer
    @integer   'SmallInt', 2       # 2 byte integer
    @integer   'RegularInt'        # Regular integer
    @bigint    'BigIntCol'         # Bigint
    @float     'FloatCol'          # Float (single precision)
    @double    'DoubleCol'         # Double (double precision)
    @decimal   'DecimalCol', 10, 2 # Decimal with precision and scale
    @decimal   'MoneyCol', 19, 4   # Money-like decimal

  # Different time-related fields
  @table 'schedules', ->
    @date      'SchedDate!'
    @datetime  'SchedDateTime!'
    @timestamp 'CreatedAt!'
    @time      'StartTime!'
    @time      'EndTime'

  # Foreign key relationships (implicit through naming)
  @table 'patients', ->
    @string    'FirstName!', 50
    @string    'LastName!', 50
    @bigint    'ProviderNum!' # Foreign key by convention
    @bigint    'ClinicNum!'   # Foreign key by convention

    @index     ['LastName', 'FirstName'], name: 'indexLFName'

  # Soft deletes and audit fields
  @table 'audit_logs', ->
    @bigint    'UserNum!'
    @datetime  'DateTStamp!'
    @string    'TableName!', 50
    @bigint    'FKey!'
    @integer   'FKeyType!', 1
    @text      'LogText!'

    @index     ['FKey', 'FKeyType'], name: 'FKeyAndType'

  # Table with many boolean flags
  @table 'settings', ->
    @boolean   'IsActive!', true      # Default true
    @boolean   'IsHidden!', false     # Default false
    @boolean   'AllowEdit'            # Optional boolean
    @boolean   'RequireAuth!', [true] # Array default syntax

  # Enums represented as integers with specific values
  @table 'alerts', ->
    @integer   'AlertType!', 1   # Enum as tinyint
    @integer   'Severity!', 1    # 0=Low, 1=Medium, 2=High
    @integer   'Status!', 1, [0] # 0=New, 1=Read, 2=Archived

  # Tables with unique constraints (besides primary key)
  @table 'users', ->
    @string    'Username!', 50
    @string    'Email!', 100
    @string    'PasswordHash!', 255

    @index     'Username', unique: true # Unique index
    @index     'Email', unique: true

  # Polymorphic associations pattern
  @table 'attachments', ->
    @bigint    'AttachableId!'
    @string    'AttachableType!', 50 # 'Patient', 'Appointment', etc
    @string    'FileName!', 255
    @binary    'FileData', size: 'long'

    @index     ['AttachableType', 'AttachableId'], name: 'polymorphic'

  # JSON fields for flexible data storage
  @table 'configurations', ->
    @string    'Key!', 50
    @json      'Value!', [{}]          # JSON with empty object default
    @json      'Metadata'              # Optional JSON field
    @string    'Category!', 50
    @timestamps()

    @index     'Key', unique: true
    @index     'Category'

  # Table with various JSON use cases
  @table 'events', ->
    @string    'EventType!', 50
    @json      'Payload!', [{}]        # Event data
    @json      'Headers', [{}]         # HTTP headers, etc
    @json      'Context'               # Optional context
    @json      'Tags', [[]]            # Array of tags
    @datetime  'OccurredAt!'
    @timestamps()

    @index     'EventType'
    @index     'OccurredAt'

  # Mixed column types including new ones
  @table 'documents', ->
    @string    'Title!', 255
    @text      'Content!'
    @json      'Metadata!', [{ version: 1, draft: true }]  # Complex default
    @binary    'Attachment'
    @string    'MimeType', 100
    @integer   'Version!', [1]
    @boolean   'IsPublished!', false
    @date      'PublishedDate'
    @time      'PublishTime'
    @timestamps()

    @index     'Title'
    @index     ['IsPublished', 'PublishedDate']

  # Table showcasing all field types
  @table 'kitchen_sink', ->
    # Text types
    @string    'StringField', 100
    @text      'TextField'
    @email     'EmailField!'

    # Numeric types
    @integer   'IntField', 4
    @bigint    'BigIntField'
    @float     'FloatField'
    @double    'DoubleField'
    @decimal   'DecimalField', 10, 2

    # Date/Time types
    @date      'DateField'
    @time      'TimeField'
    @datetime  'DateTimeField'
    @timestamp 'TimestampField'

    # Binary and JSON
    @binary    'BinaryField', size: 'medium'
    @json      'JsonField', [{ key: "value" }]

    # Boolean
    @boolean   'BoolField', true

    @timestamps()

    # Various index patterns
    @index     'EmailField', unique: true
    @index     ['DateField', 'TimeField']
    @index     'TextField', 50  # Index with length limit
