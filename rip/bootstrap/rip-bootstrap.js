#!/usr/bin/env bun
/**
 * Rip Bootstrap Compiler
 * A robust compiler that can properly compile .rip files to JavaScript
 * Handles the essential Rip syntax needed to bootstrap the language
 */

import fs from 'fs';
import path from 'path';

class RipBootstrapCompiler {
  constructor() {
    this.indentSize = 2;
    this.currentIndent = 0;
  }

  compile(source, options = {}) {
    const lines = source.split('\n');
    const output = [];

    // Add header
    if (options.header !== false) {
      output.push('// Generated by Rip Bootstrap Compiler');
      output.push('// ' + new Date().toISOString());
      output.push('');
    }

    // Process line by line with persistent context
    const context = {
      inClass: false,
      inObject: false,
      inFunction: false,
      objectBraceLevel: 0,
      lastLineWasEmpty: false
    };

    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      const nextLine = lines[i + 1];
      // Pass context by reference so changes persist
      const compiled = this.compileLine(line, nextLine, context);

      // Handle empty lines intelligently
      if (compiled === '') {
        if (!context.lastLineWasEmpty) {
          output.push('');
          context.lastLineWasEmpty = true;
        }
      } else if (compiled !== null) {
        output.push(compiled);
        context.lastLineWasEmpty = false;
      }
    }

    return output.join('\n');
  }

  compileLine(line, nextLine, context) {
    const trimmed = line.trim();
    const indent = this.getIndent(line);

    // Handle empty lines
    if (!trimmed) return '';

    // Handle comments
    if (trimmed.startsWith('#')) {
      // Inline comment in object? Keep on same line
      if (context.inObject && line.includes(':')) {
        const [code, comment] = line.split('#');
        return this.compileLine(code, nextLine, context) + ' //' + comment;
      }
      return indent + '//' + trimmed.substring(1);
    }

    // Pre-process @ to this conversion inline (no recursion)
    let processedLine = line;
    let processedTrimmed = trimmed;

    // Also handle inline comments early
    let inlineComment = '';
    if (trimmed.includes('#') && !trimmed.startsWith('#')) {
      const parts = trimmed.split('#');
      processedTrimmed = parts[0].trim();
      inlineComment = ' // ' + parts.slice(1).join('#').trim();
      processedLine = line.split('#')[0];
    }

    // Convert @ to this
    if (processedTrimmed.includes('@')) {
      processedLine = processedLine.replace(/@(\w+)/g, 'this.$1');
      processedTrimmed = processedTrimmed.replace(/@(\w+)/g, 'this.$1');
    }

    // Convert CoffeeScript logical operators to JavaScript
    processedTrimmed = processedTrimmed
      .replace(/\band\b/g, '&&')
      .replace(/\bor\b/g, '||')
      .replace(/\bnot\b/g, '!')
      .replace(/\bis\b/g, '===')
      .replace(/\bisnt\b/g, '!==');

    // Import statements
    if (processedTrimmed.startsWith('import ')) {
      return this.compileImport(processedTrimmed);
    }

    // Export statements
    if (processedTrimmed.startsWith('export ')) {
      return this.compileExport(processedTrimmed, context);
    }

    // Class definitions
    if (processedTrimmed.startsWith('class ')) {
      context.inClass = true;
      return this.compileClass(processedTrimmed);
    }

    // Constructor
    if (processedTrimmed.includes('constructor:')) {
      return this.compileConstructor(processedTrimmed, indent);
    }

    // Method definitions (name: -> or name: (params) ->)
    if (context.inClass && this.isMethodDefinition(processedTrimmed)) {
      return this.compileMethod(processedTrimmed, indent);
    }

    // Object literals
    if (this.isObjectStart(processedTrimmed)) {
      context.inObject = true;
      context.objectBraceLevel++;
      return this.compileObjectStart(processedTrimmed, indent);
    }

    // Object properties
    if (context.inObject && processedTrimmed.includes(':')) {
      return this.compileObjectProperty(processedTrimmed, indent);
    }

    // Arrow functions
    if (processedTrimmed.includes('->')) {
      return this.compileArrowFunction(processedTrimmed, indent, context);
    }

    // Variable assignments
    if (this.isAssignment(processedTrimmed)) {
      const result = this.compileAssignment(processedTrimmed, indent, context);
      // Check if this started an object literal
      if (processedTrimmed.endsWith('{')) {
        context.inObject = true;
        context.objectBraceLevel++;
      }
      return result + inlineComment;
    }

    // Control flow
    if (processedTrimmed.startsWith('if ')) {
      return indent + `if (${processedTrimmed.substring(3)}) {`;
    }

    if (processedTrimmed.startsWith('unless ')) {
      return indent + `if (!(${processedTrimmed.substring(7)})) {`;
    }

    if (processedTrimmed.startsWith('else if ')) {
      return indent + `} else if (${processedTrimmed.substring(8)}) {`;
    }

    if (processedTrimmed === 'else') {
      return indent + '} else {';
    }

    if (processedTrimmed.startsWith('for ')) {
      return this.compileFor(processedTrimmed, indent);
    }

    if (processedTrimmed.startsWith('while ')) {
      return indent + `while (${processedTrimmed.substring(6)}) {`;
    }

    if (processedTrimmed.startsWith('switch ')) {
      return indent + `switch (${processedTrimmed.substring(7)}) {`;
    }

    if (processedTrimmed.startsWith('when ')) {
      return this.compileWhen(processedTrimmed, indent);
    }

    if (processedTrimmed.startsWith('try')) {
      return indent + 'try {';
    }

    if (processedTrimmed.startsWith('catch')) {
      const match = processedTrimmed.match(/^catch\s*(.*)$/);
      return indent + `} catch (${match[1] || 'error'}) {`;
    }

    if (processedTrimmed === 'finally') {
      return indent + '} finally {';
    }

    if (processedTrimmed.startsWith('return')) {
      return indent + processedTrimmed + ';';
    }

    if (processedTrimmed.startsWith('throw')) {
      return indent + processedTrimmed + ';';
    }

    if (processedTrimmed.startsWith('break') || processedTrimmed.startsWith('continue')) {
      return indent + processedTrimmed + ';';
    }

    // Closing braces
    if (processedTrimmed === '}' || processedTrimmed === '},' || processedTrimmed === '};') {
      if (context.inObject && context.objectBraceLevel > 0) {
        context.objectBraceLevel--;
        if (context.objectBraceLevel === 0) {
          context.inObject = false;
        }
      }
      return indent + processedTrimmed;
    }

    // Default: return as-is
    if (processedTrimmed.endsWith('{')) {
      return indent + processedTrimmed + inlineComment;
    }

    // Add semicolon if needed
    if (this.needsSemicolon(processedTrimmed)) {
      return indent + processedTrimmed + ';' + inlineComment;
    }

    return indent + processedTrimmed + inlineComment;
  }

  compileImport(line) {
    let compiled = line;

    // Convert .rip to .js
    compiled = compiled.replace(/\.rip(['"])/g, '.js$1');

    // Fix missing quotes
    compiled = compiled.replace(/from\s+([^'"\s]+)$/g, "from '$1'");

    return compiled + ';';
  }

  compileExport(line, context) {
    // export class
    if (line.includes('class ')) {
      context.inClass = true;
      return line + ' {';
    }

    // export x = value
    const assignMatch = line.match(/^export\s+(\w+)\s*=\s*(.+)$/);
    if (assignMatch) {
      const [, name, value] = assignMatch;

      // Handle arrow functions specially
      if (value.includes('->')) {
        return `export const ${name} = ${this.convertArrowFunction(value)};`;
      }

      return `export const ${name} = ${value};`;
    }

    // export default or export { ... }
    if (line.includes('default') || line.includes('{')) {
      return line + ';';
    }

    return line + ';';
  }

  compileClass(line) {
    // class Name extends Parent
    // class Name
    return line + ' {';
  }

  compileConstructor(line, indent) {
    const match = line.match(/constructor:\s*(?:\((.*?)\))?\s*->/);
    if (match) {
      const params = match[1] || '';
      return `${indent}constructor(${params}) {`;
    }
    return `${indent}constructor() {`;
  }

  compileMethod(line, indent) {
    // methodName: -> body
    // methodName: (params) -> body
    const match = line.match(/^(\w+):\s*(?:\((.*?)\))?\s*->\s*(.*)$/);
    if (match) {
      const [, name, params, body] = match;

      if (body) {
        // Single line method
        return `${indent}${name}(${params || ''}) { return ${body}; }`;
      } else {
        // Multi-line method
        return `${indent}${name}(${params || ''}) {`;
      }
    }

    return line;
  }

  compileArrowFunction(line, indent, context) {
    // name = -> or name = (params) ->
    const assignMatch = line.match(/^(\w+)\s*=\s*(?:\((.*?)\))?\s*->\s*(.*)$/);
    if (assignMatch) {
      const [, name, params, body] = assignMatch;

      if (body) {
        return `${indent}const ${name} = (${params || ''}) => ${body};`;
      } else {
        return `${indent}const ${name} = (${params || ''}) => {`;
      }
    }

    // Standalone arrow function
    const arrowMatch = line.match(/^(?:\((.*?)\))?\s*->\s*(.*)$/);
    if (arrowMatch) {
      const [, params, body] = arrowMatch;

      if (body) {
        return `${indent}(${params || ''}) => ${body}`;
      } else {
        return `${indent}(${params || ''}) => {`;
      }
    }

    return line;
  }

  compileObjectStart(line, indent) {
    // Handle: varName = { or just {
    if (line.includes('=')) {
      const [left, right] = line.split('=').map(s => s.trim());

      // Check if it's a proper variable declaration
      if (left.match(/^\w+$/)) {
        return `${indent}const ${left} = ${right || '{'}`;
      }
    }

    return indent + line;
  }

  compileObjectProperty(line, indent) {
    // property: value
    const trimmed = line.trim();

    // Handle comments
    let code = trimmed;
    let comment = '';
    if (trimmed.includes('#')) {
      const parts = trimmed.split('#');
      code = parts[0].trim();
      comment = ' //' + parts.slice(1).join('#');
    }

    // Split property: value
    const colonIndex = code.indexOf(':');
    if (colonIndex === -1) return line;

    const property = code.substring(0, colonIndex).trim();
    let value = code.substring(colonIndex + 1).trim();

    // Handle different value types
    if (value.includes('->')) {
      // Arrow function value
      value = this.convertArrowFunction(value);
    } else if (value === '{') {
      // Nested object
      return `${indent}${property}: {${comment}`;
    }

    // Add comma if needed (check if not last property)
    const needsComma = !value.endsWith('{') && !value.endsWith(',');

    return `${indent}${property}: ${value}${needsComma ? ',' : ''}${comment}`;
  }

  compileThisAccess(line, indent) {
    // Replace @property with this.property
    let compiled = line.replace(/@(\w+)/g, 'this.$1');

    // Handle @method() calls
    compiled = compiled.replace(/this\.(\w+)\s*\(/g, 'this.$1(');

    // Add semicolon if it's a statement
    if (this.needsSemicolon(compiled.trim())) {
      compiled = compiled + ';';
    }

    return indent + compiled.trim();
  }

  compileAssignment(line, indent, context = {}) {
    const trimmed = line.trim();

    // Skip if it's already a proper declaration
    if (trimmed.startsWith('const ') || trimmed.startsWith('let ') || trimmed.startsWith('var ')) {
      return indent + trimmed + ';';
    }

    // Simple assignment: x = value
    const match = trimmed.match(/^([\w.]+)\s*=\s*(.+)$/);
    if (match) {
      const [, variable, value] = match;

      // Check if it's a property access (has dot - includes this.property)
      if (variable.includes('.')) {
        if (value === '{' || value.endsWith('{')) {
          return `${indent}${variable} = ${value}`;
        }
        return `${indent}${variable} = ${value};`;
      }

      // Check for special values
      if (value === '{' || value.endsWith('{')) {
        return `${indent}const ${variable} = ${value}`;
      }

      if (value.includes('->')) {
        return `${indent}const ${variable} = ${this.convertArrowFunction(value)};`;
      }

      return `${indent}const ${variable} = ${value};`;
    }

    return line;
  }

  compileFor(line, indent) {
    // for item in array
    // for item of array
    // for key, value of object
    const match = line.match(/^for\s+(\w+)(?:,\s*(\w+))?\s+(in|of)\s+(.+)$/);
    if (match) {
      const [, key, value, operator, collection] = match;

      if (value) {
        // for key, value of object
        return `${indent}for (const [${key}, ${value}] of Object.entries(${collection})) {`;
      } else {
        // for item in/of array
        const jsOp = operator === 'in' ? 'of' : operator;
        return `${indent}for (const ${key} ${jsOp} ${collection}) {`;
      }
    }

    return indent + line;
  }

  compileWhen(line, indent) {
    const trimmed = line.substring(5).trim(); // Remove 'when '

    // Handle multiple cases: when 'a', 'b', 'c'
    if (trimmed.includes(',')) {
      const cases = trimmed.split(',').map(c => c.trim());
      return cases.map(c => `${indent}case ${c}:`).join('\n');
    }

    // Single case
    return `${indent}case ${trimmed}:`;
  }

  convertArrowFunction(code) {
    // (params) -> body
    // -> body
    const match = code.match(/^(?:\((.*?)\))?\s*->\s*(.*)$/);
    if (match) {
      const [, params, body] = match;

      if (body) {
        return `(${params || ''}) => ${body}`;
      } else {
        return `(${params || ''}) => {`;
      }
    }

    return code;
  }

  isMethodDefinition(line) {
    // Check for: methodName: -> or methodName: (params) ->
    return /^\w+:\s*(?:\(.*?\))?\s*->/.test(line);
  }

  isObjectStart(line) {
    const trimmed = line.trim();
    return trimmed === '{' || trimmed.endsWith('= {') || trimmed.endsWith(': {');
  }

  isAssignment(line) {
    const trimmed = line.trim();
    // Check for = but not ==, ===, !=, !==, <=, >=, =>
    // Include @ at the start for this.property assignments
    return /^[@\w.]+\s*=\s*(?!=|>)/.test(trimmed);
  }

  needsSemicolon(line) {
    // Don't add semicolon to lines ending with:
    // { } , : ; or to control flow statements
    if (/[{},;:]$/.test(line)) return false;
    if (/^(if|else|for|while|switch|case|try|catch|finally)/.test(line)) return false;
    if (/^(class|function|const|let|var)\s/.test(line)) return false;

    // Add semicolon to statements
    return /^(return|throw|break|continue)/.test(line) ||
           /^[\w.]+\s*\(.*\)$/.test(line) || // Function calls
           /^[\w.]+\s*=/.test(line) || // Assignments
           /^\]$/.test(line) || // Array closing
           /^[\w.]+\s*\[.*\]$/.test(line); // Array access/declaration
  }

  getIndent(line) {
    const match = line.match(/^(\s*)/);
    return match ? match[1] : '';
  }

  async compileFile(inputPath, outputPath) {
    console.log(`Compiling: ${inputPath}`);

    const source = await fs.promises.readFile(inputPath, 'utf8');
    const compiled = this.compile(source);

    await fs.promises.mkdir(path.dirname(outputPath), { recursive: true });
    await fs.promises.writeFile(outputPath, compiled, 'utf8');

    console.log(`  Output: ${outputPath}`);
  }

  async compileDirectory(srcDir, outDir) {
    const files = await fs.promises.readdir(srcDir, { withFileTypes: true });

    for (const file of files) {
      const srcPath = path.join(srcDir, file.name);

      if (file.isDirectory()) {
        const newOutDir = path.join(outDir, file.name);
        await this.compileDirectory(srcPath, newOutDir);
      } else if (file.name.endsWith('.rip')) {
        const outPath = path.join(outDir, file.name.replace('.rip', '.js'));
        await this.compileFile(srcPath, outPath);
      }
    }
  }
}

// Main function
async function main() {
  const compiler = new RipBootstrapCompiler();

  console.log('');
  console.log('Rip Bootstrap Compiler v2');
  console.log('=========================');
  console.log('');

  // Compile src directory
  await compiler.compileDirectory(
    path.join(process.cwd(), 'src'),
    path.join(process.cwd(), 'lib')
  );

  // Compile bin/rip.rip
  await compiler.compileFile(
    path.join(process.cwd(), 'bin', 'rip.rip'),
    path.join(process.cwd(), 'bin', 'rip.js')
  );

  console.log('');
  console.log('✅ Bootstrap compilation complete!');
}

// Run if executed directly
if (import.meta.url === `file://${process.argv[1]}`) {
  main().catch(error => {
    console.error('❌ Bootstrap failed:', error);
    process.exit(1);
  });
}

export default RipBootstrapCompiler;
