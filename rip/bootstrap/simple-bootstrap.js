#!/usr/bin/env bun
// Simple Bootstrap Compiler for Rip
// This is a minimal compiler that can handle basic Rip syntax
// Just enough to bootstrap the real compiler

import fs from 'fs';
import path from 'path';

class SimpleRipCompiler {
  compile(source) {
    // Very simple line-by-line transformation
    const lines = source.split('\n');
    const output = [];

    // Add header
    output.push('// Generated by Rip Simple Bootstrap Compiler');
    output.push('');

    let inClass = false;
    let inSwitch = false;

    for (const line of lines) {
      const trimmed = line.trim();
      const indent = line.match(/^(\s*)/)[1];

      // Skip comments
      if (trimmed.startsWith('#')) {
        output.push(indent + '//' + trimmed.substring(1));
        continue;
      }

      // Skip empty lines
      if (!trimmed) {
        output.push('');
        continue;
      }

      // Import statements
      if (trimmed.startsWith('import ')) {
        let compiled = trimmed.replace(/\.rip/g, '.js');
        // Fix import syntax if needed
        if (!compiled.includes('from')) {
          // Handle import x -> import x
          compiled = compiled;
        }
        output.push(compiled + ';');
        continue;
      }

      // Export statements
      if (trimmed.startsWith('export ')) {
        let compiled = trimmed.replace(/\.rip/g, '.js');

        // Handle export class
        if (compiled.includes('class ')) {
          output.push(compiled + ' {');
          inClass = true;
          continue;
        }

        // Handle export x = value
        if (compiled.includes(' = ') && !compiled.includes('=>')) {
          const parts = compiled.match(/export\s+(\w+)\s*=\s*(.+)/);
          if (parts) {
            output.push(`export const ${parts[1]} = ${parts[2]};`);
            continue;
          }
        }

        output.push(compiled + ';');
        continue;
      }

      // Class definition
      if (trimmed.startsWith('class ')) {
        output.push(indent + trimmed + ' {');
        inClass = true;
        continue;
      }

      // End of class
      if (inClass && indent === '' && !trimmed.startsWith(' ')) {
        inClass = false;
      }

      // Constructor
      if (trimmed === 'constructor:' || trimmed.startsWith('constructor:')) {
        output.push(indent + 'constructor() {');
        continue;
      }

      // Method definitions in class: methodName: ->
      if (inClass && trimmed.includes(':') && trimmed.includes('->')) {
        const match = trimmed.match(/^(\w+):\s*(?:\((.*?)\))?\s*->/);
        if (match) {
          const methodName = match[1];
          const params = match[2] || '';
          output.push(`${indent}${methodName}(${params}) {`);
          continue;
        }
      }

      // Simple arrow functions: name = ->
      if (trimmed.includes(' = ') && trimmed.includes('->')) {
        const match = trimmed.match(/^(\w+)\s*=\s*(?:\((.*?)\))?\s*->\s*(.*)$/);
        if (match) {
          const name = match[1];
          const params = match[2] || '';
          const body = match[3];

          if (body) {
            // Single line arrow function
            output.push(`${indent}const ${name} = (${params}) => ${body};`);
          } else {
            // Multi-line arrow function
            output.push(`${indent}const ${name} = (${params}) => {`);
          }
          continue;
        }
      }

      // Variable declarations with =
      if (trimmed.includes(' = ') && !trimmed.includes('=>') && !trimmed.includes('==')) {
        const match = trimmed.match(/^(\w+)\s*=\s*(.+)$/);
        if (match) {
          const varName = match[1];
          let value = match[2];

          // Handle object literals
          if (value === '{' || value.startsWith('{')) {
            output.push(`${indent}const ${varName} = ${value}`);
          } else {
            output.push(`${indent}const ${varName} = ${value};`);
          }
          continue;
        }
      }

      // Handle @ for this
      if (trimmed.includes('@')) {
        const compiled = trimmed.replace(/@(\w+)/g, 'this.$1');
        output.push(indent + compiled + (compiled.endsWith('{') || compiled.endsWith('}') ? '' : ';'));
        continue;
      }

      // Switch statement
      if (trimmed.startsWith('switch ')) {
        output.push(`${indent}switch (${trimmed.substring(7)}) {`);
        inSwitch = true;
        continue;
      }

      // When/case in switch
      if (trimmed.startsWith('when ')) {
        const cases = trimmed.substring(5).split(',').map(c => c.trim());
        for (const c of cases) {
          output.push(`${indent}  case ${c}:`);
        }
        continue;
      }

      // For loops
      if (trimmed.startsWith('for ')) {
        const match = trimmed.match(/^for\s+(\w+)\s+(in|of)\s+(.+)$/);
        if (match) {
          const op = match[2] === 'in' ? 'of' : match[2];
          output.push(`${indent}for (const ${match[1]} ${op} ${match[3]}) {`);
          continue;
        }
      }

      // While loops
      if (trimmed.startsWith('while ')) {
        output.push(`${indent}while (${trimmed.substring(6)}) {`);
        continue;
      }

      // If statements
      if (trimmed.startsWith('if ')) {
        output.push(`${indent}if (${trimmed.substring(3)}) {`);
        continue;
      }

      // Unless statements
      if (trimmed.startsWith('unless ')) {
        output.push(`${indent}if (!(${trimmed.substring(7)})) {`);
        continue;
      }

      // Else
      if (trimmed === 'else') {
        output.push(`${indent}} else {`);
        continue;
      }

      // Return statements
      if (trimmed.startsWith('return')) {
        output.push(indent + trimmed + ';');
        continue;
      }

      // Closing braces
      if (trimmed === '}' || (inClass && trimmed === '' && indent === '')) {
        output.push(indent + '}');
        if (inSwitch) inSwitch = false;
        continue;
      }

      // Try/catch/finally
      if (trimmed === 'try') {
        output.push(`${indent}try {`);
        continue;
      }
      if (trimmed.startsWith('catch')) {
        const match = trimmed.match(/^catch\s*(.*)$/);
        const param = match[1] || 'error';
        output.push(`${indent}} catch (${param}) {`);
        continue;
      }
      if (trimmed === 'finally') {
        output.push(`${indent}} finally {`);
        continue;
      }

      // Default: output as-is
      output.push(indent + trimmed);
    }

    // Close any open braces
    if (inClass) {
      output.push('}');
    }

    return output.join('\n');
  }

  async compileFile(inputPath, outputPath) {
    console.log(`Compiling ${inputPath}...`);
    const source = await fs.promises.readFile(inputPath, 'utf8');
    const compiled = this.compile(source);

    await fs.promises.mkdir(path.dirname(outputPath), { recursive: true });
    await fs.promises.writeFile(outputPath, compiled, 'utf8');
    console.log(`  -> ${outputPath}`);
  }
}

// Main
async function main() {
  const compiler = new SimpleRipCompiler();

  // Compile src files
  const srcFiles = [
    'src/lexer.rip',
    'src/nodes.rip',
    'src/parser.rip',
    'src/compiler.rip',
    'src/index.rip',
    'src/grammar.rip'
  ];

  for (const file of srcFiles) {
    const input = path.join(process.cwd(), file);
    const output = path.join(process.cwd(), file.replace('src/', 'lib/').replace('.rip', '.js'));

    if (fs.existsSync(input)) {
      await compiler.compileFile(input, output);
    }
  }

  // Compile bin/rip.rip
  const binInput = path.join(process.cwd(), 'bin/rip.rip');
  const binOutput = path.join(process.cwd(), 'bin/rip.js');

  if (fs.existsSync(binInput)) {
    await compiler.compileFile(binInput, binOutput);
  }

  console.log('\nSimple bootstrap compilation complete!');
}

if (import.meta.url === `file://${process.argv[1]}`) {
  main().catch(console.error);
}

export default SimpleRipCompiler;
