#!/usr/bin/env bun
// Bootstrap compiler for Rip
// This is a minimal JavaScript implementation that can compile basic .rip files
// Used to bootstrap the Rip compiler written in Rip

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

class RipBootstrap {
  constructor() {
    this.indentLevel = 0;
    this.indentStack = [];
  }

  compile(source, options = {}) {
    const lines = source.split('\n');
    const output = [];

    if (options.header !== false) {
      output.push('// Generated by Rip Bootstrap Compiler');
      output.push('// This is a bootstrap compilation - not feature complete');
      output.push('');
    }

    this.context = {
      inClass: false,
      inMethod: false,
      inObject: false,
      indentLevel: 0,
      braceStack: []
    };

    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      const indent = line.length - line.trimStart().length;
      this.context.indentLevel = Math.floor(indent / 2);

      const compiled = this.compileLine(line);
      if (compiled) {
        output.push(compiled);
      }
    }

    return output.join('\n');
  }

  compileLine(line) {
    const trimmed = line.trim();

    // Skip empty lines and comments
    if (!trimmed || trimmed.startsWith('#')) {
      return trimmed.startsWith('#') ? '//' + trimmed.substring(1) : '';
    }

    // Handle imports
    if (trimmed.startsWith('import ')) {
      return this.compileImport(trimmed);
    }

    // Handle exports
    if (trimmed.startsWith('export ')) {
      return this.compileExport(trimmed);
    }

    // Handle class definitions
    if (trimmed.startsWith('class ')) {
      return this.compileClass(trimmed);
    }

    // Handle constructor
    if (trimmed === 'constructor:' || trimmed.startsWith('constructor: ')) {
      return '  constructor() {';
    }

    // Handle arrow functions (->)
    if (trimmed.includes('->')) {
      return this.compileArrowFunction(trimmed);
    }

    // Handle method definitions (name: ->)
    if (trimmed.match(/^(\w+):\s*->$/)) {
      const match = trimmed.match(/^(\w+):\s*->$/);
      return `  ${match[1]}() {`;
    }

    // Handle method definitions with parameters
    if (trimmed.match(/^(\w+):\s*\((.*?)\)\s*->$/)) {
      const match = trimmed.match(/^(\w+):\s*\((.*?)\)\s*->$/);
      return `  ${match[1]}(${match[2]}) {`;
    }

    // Handle property assignments (@ prefix)
    if (trimmed.startsWith('@')) {
      return this.compileThisProperty(trimmed);
    }

    // Handle return statements
    if (trimmed.startsWith('return ')) {
      return '    ' + trimmed + ';';
    }

    // Handle variable assignments
    if (trimmed.includes(' = ')) {
      return this.compileAssignment(trimmed);
    }

    // Handle 'super()' calls
    if (trimmed === 'super()' || trimmed.startsWith('super(')) {
      return '    ' + trimmed + ';';
    }

    // Handle 'extends' for classes
    if (trimmed.includes(' extends ')) {
      return trimmed;
    }

    // Handle for...in/of loops
    if (trimmed.startsWith('for ')) {
      return this.compileForLoop(trimmed);
    }

    // Handle while loops
    if (trimmed.startsWith('while ')) {
      return this.compileWhile(trimmed);
    }

    // Handle if statements
    if (trimmed.startsWith('if ')) {
      return this.compileIf(trimmed);
    }

    // Handle unless statements
    if (trimmed.startsWith('unless ')) {
      return this.compileUnless(trimmed);
    }

    // Handle switch statements
    if (trimmed.startsWith('switch ')) {
      return this.compileSwitch(trimmed);
    }

    // Handle case/when statements
    if (trimmed.startsWith('when ')) {
      return this.compileWhen(trimmed);
    }

    // Handle else
    if (trimmed === 'else') {
      return '  } else {';
    }

    // Handle try/catch/finally
    if (trimmed === 'try') {
      return '  try {';
    }
    if (trimmed.startsWith('catch ')) {
      const match = trimmed.match(/^catch\s+(.*)$/);
      return `  } catch (${match[1]}) {`;
    }
    if (trimmed === 'finally') {
      return '  } finally {';
    }

    // Default: return as-is with proper indentation
    return '    ' + trimmed;
  }

  compileImport(line) {
    // import { x } from './file.rip' -> import { x } from './file.js'
    // import x from './file.rip' -> import x from './file.js'
    let compiled = line.replace(/from\s+['"](.*?)\.rip['"]/g, "from '$1.js'");

    // Handle import without quotes (for now, add them)
    compiled = compiled.replace(/from\s+([^'"].*?)$/g, "from '$1'");

    return compiled + ';';
  }

  compileExport(line) {
    const trimmed = line.trim();

    // export class X -> export class X {
    if (trimmed.match(/^export\s+class\s+(\w+)/)) {
      return trimmed + ' {';
    }

    // export x = value -> export const x = value;
    if (trimmed.match(/^export\s+(\w+)\s*=/)) {
      const match = trimmed.match(/^export\s+(\w+)\s*=\s*(.*)$/);
      if (match) {
        const value = this.compileExpression(match[2]);
        return `export const ${match[1]} = ${value};`;
      }
    }

    // export { x } -> export { x };
    if (trimmed.includes('{')) {
      let compiled = trimmed.replace(/from\s+['"](.*?)\.rip['"]/g, "from '$1.js'");
      return compiled + ';';
    }

    // export default -> export default
    return trimmed + ';';
  }

  compileClass(line) {
    // class X extends Y -> class X extends Y {
    // class X -> class X {
    return line + ' {';
  }

  compileArrowFunction(line) {
    // x = -> ... becomes x = () => { ...
    // x = (a, b) -> ... becomes x = (a, b) => { ...
    const match = line.match(/^(\w+)\s*=\s*(\(.*?\))?\s*->\s*(.*)$/);
    if (match) {
      const name = match[1];
      const params = match[2] || '()';
      const body = match[3];

      if (body) {
        // Single line arrow function
        return `const ${name} = ${params} => ${body};`;
      } else {
        // Multi-line arrow function
        return `const ${name} = ${params} => {`;
      }
    }

    // Method definition: name: -> becomes name() {
    const methodMatch = line.match(/^(\s*)(\w+):\s*(\(.*?\))?\s*->(.*)$/);
    if (methodMatch) {
      const indent = methodMatch[1];
      const name = methodMatch[2];
      const params = methodMatch[3] || '()';
      const body = methodMatch[4];

      if (body.trim()) {
        // Single line method
        return `${indent}${name}${params} { return ${body.trim()}; }`;
      } else {
        // Multi-line method
        return `${indent}${name}${params} {`;
      }
    }

    return line;
  }

  compileThisProperty(line) {
    // @property = value -> this.property = value
    // @property -> this.property
    return line.replace(/@(\w+)/g, 'this.$1') + ';';
  }

  compileAssignment(line) {
    const trimmed = line.trim();

    // Check if it's a const/let/var declaration
    if (trimmed.startsWith('const ') || trimmed.startsWith('let ') || trimmed.startsWith('var ')) {
      return '    ' + trimmed + ';';
    }

    // Simple assignment: x = value
    const match = trimmed.match(/^(\w+)\s*=\s*(.+)$/);
    if (match) {
      const variable = match[1];
      const value = this.compileExpression(match[2]);
      return `    const ${variable} = ${value};`;
    }

    return '    ' + trimmed + ';';
  }

  compileExpression(expr) {
    const trimmed = expr.trim();

    // Handle 'new' expressions
    if (trimmed.startsWith('new ')) {
      return trimmed;
    }

    // Handle object literals { ... }
    if (trimmed.startsWith('{') && trimmed.endsWith('}')) {
      return trimmed;
    }

    // Handle array literals [ ... ]
    if (trimmed.startsWith('[') && trimmed.endsWith(']')) {
      return trimmed;
    }

    // Handle arrow functions
    if (trimmed.includes('->')) {
      const match = trimmed.match(/^(\(.*?\))?\s*->\s*(.+)$/);
      if (match) {
        const params = match[1] || '()';
        const body = match[2];
        return `${params} => ${body}`;
      }
    }

    // Handle @property
    if (trimmed.includes('@')) {
      return trimmed.replace(/@(\w+)/g, 'this.$1');
    }

    // Handle spread operator
    if (trimmed.includes('...')) {
      return trimmed;
    }

    // Default: return as-is
    return trimmed;
  }

  compileForLoop(line) {
    // for x in array -> for (const x of array) {
    // for x of array -> for (const x of array) {
    const match = line.match(/^for\s+(\w+)\s+(in|of)\s+(.+)$/);
    if (match) {
      const variable = match[1];
      const operator = match[2] === 'in' ? 'of' : match[2]; // Convert 'in' to 'of' for arrays
      const iterable = match[3];
      return `  for (const ${variable} ${operator} ${iterable}) {`;
    }
    return '  ' + line + ' {';
  }

  compileIf(line) {
    // if condition -> if (condition) {
    const match = line.match(/^if\s+(.+)$/);
    if (match) {
      return `  if (${match[1]}) {`;
    }
    return '  ' + line + ' {';
  }

  compileUnless(line) {
    // unless condition -> if (!(condition)) {
    const match = line.match(/^unless\s+(.+)$/);
    if (match) {
      return `  if (!(${match[1]})) {`;
    }
    return '  ' + line + ' {';
  }

  compileWhile(line) {
    // while condition -> while (condition) {
    const match = line.match(/^while\s+(.+)$/);
    if (match) {
      return `  while (${match[1]}) {`;
    }
    return '  ' + line + ' {';
  }

  compileSwitch(line) {
    // switch expression -> switch (expression) {
    const match = line.match(/^switch\s+(.+)$/);
    if (match) {
      return `  switch (${match[1]}) {`;
    }
    return '  ' + line + ' {';
  }

  compileWhen(line) {
    // Handle different when patterns
    // when value then result
    // when value
    const thenMatch = line.match(/^when\s+(.+?)\s+then\s+(.+)$/);
    if (thenMatch) {
      // Single line when/then
      return `    case ${thenMatch[1]}: ${thenMatch[2]}; break;`;
    }

    // Multi-line when (just the case label)
    const simpleMatch = line.match(/^when\s+(.+)$/);
    if (simpleMatch) {
      // Handle multiple values: when 'a', 'b', 'c'
      const values = simpleMatch[1].split(',').map(v => v.trim());
      if (values.length > 1) {
        // Multiple cases
        return values.map(v => `    case ${v}:`).join('\n');
      }
      return `    case ${simpleMatch[1]}:`;
    }

    return '    case ' + line.substring(5) + ':';
  }

  async compileFile(inputPath, outputPath) {
    const source = await fs.promises.readFile(inputPath, 'utf8');
    const compiled = this.compile(source);

    // Create output directory if it doesn't exist
    const outputDir = path.dirname(outputPath);
    await fs.promises.mkdir(outputDir, { recursive: true });

    await fs.promises.writeFile(outputPath, compiled, 'utf8');
    console.log(`Compiled: ${inputPath} -> ${outputPath}`);
  }

  async compileDirectory(srcDir, outDir) {
    const files = await fs.promises.readdir(srcDir, { withFileTypes: true });

    for (const file of files) {
      const srcPath = path.join(srcDir, file.name);

      if (file.isDirectory()) {
        // Recursively compile subdirectories
        const newOutDir = path.join(outDir, file.name);
        await this.compileDirectory(srcPath, newOutDir);
      } else if (file.name.endsWith('.rip')) {
        // Compile .rip files to .js
        const outPath = path.join(outDir, file.name.replace('.rip', '.js'));
        await this.compileFile(srcPath, outPath);
      }
    }
  }
}

// Main execution
async function main() {
  const bootstrap = new RipBootstrap();

  // Compile all .rip files in src/ to lib/
  const srcDir = path.join(__dirname, '..', 'src');
  const libDir = path.join(__dirname, '..', 'lib');

  console.log('Rip Bootstrap Compiler');
  console.log('======================');
  console.log(`Source: ${srcDir}`);
  console.log(`Output: ${libDir}`);
  console.log('');

  try {
    await bootstrap.compileDirectory(srcDir, libDir);
    console.log('\nBootstrap compilation complete!');
  } catch (error) {
    console.error('Bootstrap compilation failed:', error);
    process.exit(1);
  }
}

// Run if executed directly
if (import.meta.url === `file://${__filename}`) {
  main();
}

export default RipBootstrap;
