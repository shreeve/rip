#!/usr/bin/env bun
// The Rip CLI - Compile and run .rip files!

import fs from 'fs';
import { execSync } from 'child_process';
import path from 'path';

// Fix exports for our modules
function fixExports(jsPath) {
  let js = fs.readFileSync(jsPath, 'utf-8');
  js = js.replace(/var\s+(\w+);?\s*\1\s*=\s*class\s+\1/g, 'const $1 = class $1')
         .replace(/module\.exports = (\w+);/, '');
  if (!js.includes('export default')) {
    const className = path.basename(jsPath, '.js');
    const exportName = className.charAt(0).toUpperCase() + className.slice(1);
    js += `\nexport default ${exportName};\nexport { ${exportName} };`;
  }
  fs.writeFileSync(jsPath, js);
}

// Fix all our compiled modules
['compiler', 'lexer', 'rewriter'].forEach(mod => {
  const jsPath = path.join(import.meta.dir, '..', 'lib', `${mod}.js`);
  if (fs.existsSync(jsPath)) {
    fixExports(jsPath);
  }
});

// Import our components
const Lexer = (await import('../lib/lexer.js')).default;
const Rewriter = (await import('../lib/rewriter.js')).default;
const Compiler = (await import('../lib/compiler.js')).default;

// Simple parser (enough for basic programs)
class SimpleParser {
  parse(tokens) {
    const stmts = [];
    let i = 0;

    while (i < tokens.length) {
      const token = tokens[i];

      if (token.type === 'TERMINATOR' || token.type === 'EOF') {
        i++;
        continue;
      }

      // Assignment: ID = EXPR
      if (i + 2 < tokens.length && tokens[i+1].type === '=') {
        const stmt = {
          type: 'assign',
          target: { type: 'id', name: token.value },
          value: this.parseExpr(tokens, i + 2)
        };
        stmts.push({ type: 'stmt', expr: stmt });

        while (i < tokens.length && tokens[i].type !== 'TERMINATOR' && tokens[i].type !== 'EOF') {
          i++;
        }
        continue;
      }

      // Method calls (console.log etc)
      if (token.type === 'IDENTIFIER' && i + 1 < tokens.length && tokens[i+1].type === '.') {
        let expr = { type: 'id', name: token.value };
        i++;

        while (i < tokens.length && tokens[i].type === '.') {
          i++; // skip dot
          if (tokens[i].type === 'PROPERTY' || tokens[i].type === 'IDENTIFIER') {
            expr = {
              type: 'access',
              object: expr,
              property: { type: 'prop', name: tokens[i].value },
              computed: false
            };
            i++;
          }
        }

        // Check for call
        if (i < tokens.length && tokens[i].type === 'CALL_START') {
          const args = [];
          i++; // skip CALL_START

          while (i < tokens.length && tokens[i].type !== 'CALL_END') {
            if (tokens[i].type === 'STRING') {
              args.push({ type: 'str', val: tokens[i].value.slice(1, -1) });
            } else if (tokens[i].type === 'NUMBER') {
              args.push({ type: 'num', val: tokens[i].value });
            } else if (tokens[i].type === 'IDENTIFIER') {
              args.push({ type: 'id', name: tokens[i].value });
            }
            i++;
          }
          i++; // skip CALL_END

          expr = { type: 'call', func: expr, args };
        }

        stmts.push({ type: 'stmt', expr });
        continue;
      }

      i++;
    }

    return { type: 'root', stmts };
  }

  parseExpr(tokens, start) {
    const token = tokens[start];
    if (!token) return { type: 'null' };

    if (token.type === 'NUMBER') {
      if (start + 2 < tokens.length && tokens[start + 1].type in {'+':1, '-':1, '*':1, '/':1}) {
        return {
          type: 'op',
          op: tokens[start + 1].value,
          left: { type: 'num', val: token.value },
          right: this.parseExpr(tokens, start + 2)
        };
      }
      return { type: 'num', val: token.value };
    }

    if (token.type === 'STRING') {
      return { type: 'str', val: token.value.slice(1, -1) };
    }

    if (token.type === 'IDENTIFIER') {
      if (start + 2 < tokens.length && tokens[start + 1].type in {'+':1, '-':1, '*':1, '/':1}) {
        return {
          type: 'op',
          op: tokens[start + 1].value,
          left: { type: 'id', name: token.value },
          right: this.parseExpr(tokens, start + 2)
        };
      }
      return { type: 'id', name: token.value };
    }

    return { type: 'null' };
  }
}

// Compile Rip to JavaScript
function compileRip(source) {
  // Lex
  const lexer = new Lexer();
  const rawTokens = lexer.tokenize(source);

  // Convert to object format
  const tokens = rawTokens.map(([type, value, line, column]) => ({
    type, value, line: line || 0, column: column || 0
  }));

  // Rewrite
  const rewriter = new Rewriter();
  const rewritten = rewriter.rewrite(tokens);

  // Parse
  const parser = new SimpleParser();
  const ast = parser.parse(rewritten);

  // Compile
  const compiler = new Compiler();
  return compiler.compile(ast);
}

// Main CLI
const args = process.argv.slice(2);

if (args.length === 0) {
  console.log('Usage: rip <file.rip>');
  console.log('       rip -c <file.rip>  (compile only, show JS)');
  process.exit(1);
}

const compileOnly = args[0] === '-c';
const filename = compileOnly ? args[1] : args[0];

if (!filename) {
  console.log('Error: No file specified');
  process.exit(1);
}

try {
  // Read the Rip file
  const source = fs.readFileSync(filename, 'utf-8');

  // Compile to JavaScript
  const js = compileRip(source);

  if (compileOnly) {
    // Just show the compiled JavaScript
    console.log(js);
  } else {
    // Run the JavaScript!
    eval(js);
  }
} catch (e) {
  if (e.code === 'ENOENT') {
    console.error(`Error: File '${filename}' not found`);
  } else {
    console.error(`Error: ${e.message}`);
  }
  process.exit(1);
}
