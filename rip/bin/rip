#!/usr/bin/env bun
// The Rip CLI - Compile and run .rip files!

import fs from 'fs';
import { execSync } from 'child_process';
import path from 'path';

// Get version from package.json
const packageJson = JSON.parse(fs.readFileSync(path.join(import.meta.dir, '..', 'package.json'), 'utf-8'));
const RIP_VERSION = packageJson.version;

// Fix exports for our modules
function fixExports(jsPath) {
  let js = fs.readFileSync(jsPath, 'utf-8');
  js = js.replace(/var\s+(\w+);?\s*\1\s*=\s*class\s+\1/g, 'const $1 = class $1')
         .replace(/module\.exports = (\w+);/, '');
  if (!js.includes('export default')) {
    const className = path.basename(jsPath, '.js');
    const exportName = className.charAt(0).toUpperCase() + className.slice(1);
    js += `\nexport default ${exportName};\nexport { ${exportName} };`;
  }
  fs.writeFileSync(jsPath, js);
}

// Fix all our compiled modules
['compiler', 'lexer', 'rewriter'].forEach(mod => {
  const jsPath = path.join(import.meta.dir, '..', 'lib', `${mod}.js`);
  if (fs.existsSync(jsPath)) {
    fixExports(jsPath);
  }
});

// Import our components
const Lexer = (await import('../lib/lexer.js')).default;
const Rewriter = (await import('../lib/rewriter.js')).default;
const Compiler = (await import('../lib/compiler.js')).default;

// Simple parser (enough for basic programs)
class SimpleParser {
  parse(tokens) {
    const stmts = [];
    let i = 0;

    while (i < tokens.length) {
      const token = tokens[i];

      if (token.type === 'TERMINATOR' || token.type === 'EOF') {
        i++;
        continue;
      }

      // Assignment: ID = EXPR or ID += EXPR, etc.
      if (i + 2 < tokens.length &&
          (tokens[i+1].type === '=' || tokens[i+1].type === '+=' ||
           tokens[i+1].type === '-=' || tokens[i+1].type === '*=' ||
           tokens[i+1].type === '/=')) {
        const op = tokens[i+1].type;
        const stmt = {
          type: 'assign',
          target: { type: 'id', name: token.value },
          value: this.parseExpr(tokens, i + 2)
        };
        // Add op field for compound assignments
        if (op !== '=') {
          stmt.op = op;
        }
        stmts.push({ type: 'stmt', expr: stmt });

        while (i < tokens.length && tokens[i].type !== 'TERMINATOR' && tokens[i].type !== 'EOF') {
          i++;
        }
        continue;
      }

      // Method calls (console.log etc)
      if (token.type === 'IDENTIFIER' && i + 1 < tokens.length && tokens[i+1].type === '.') {
        let expr = { type: 'id', name: token.value };
        i++;

        while (i < tokens.length && tokens[i].type === '.') {
          i++; // skip dot
          if (tokens[i].type === 'PROPERTY' || tokens[i].type === 'IDENTIFIER') {
            expr = {
              type: 'access',
              object: expr,
              property: { type: 'prop', name: tokens[i].value },
              computed: false
            };
            i++;
          }
        }

        // Check for call
        if (i < tokens.length && tokens[i].type === 'CALL_START') {
          const args = [];
          i++; // skip CALL_START

          while (i < tokens.length && tokens[i].type !== 'CALL_END') {
            if (tokens[i].type === 'STRING') {
              args.push({ type: 'str', val: tokens[i].value.slice(1, -1) });
            } else if (tokens[i].type === 'NUMBER') {
              args.push({ type: 'num', val: tokens[i].value });
            } else if (tokens[i].type === 'IDENTIFIER') {
              args.push({ type: 'id', name: tokens[i].value });
            }
            i++;
          }
          i++; // skip CALL_END

          expr = { type: 'call', func: expr, args };
        }

        stmts.push({ type: 'stmt', expr });
        continue;
      }

      i++;
    }

    return { type: 'root', stmts };
  }

  parseExpr(tokens, start) {
    const token = tokens[start];
    if (!token) return { type: 'null' };

    if (token.type === 'NUMBER') {
      if (start + 2 < tokens.length && tokens[start + 1].type in {'+':1, '-':1, '*':1, '/':1}) {
        return {
          type: 'op',
          op: tokens[start + 1].value,
          left: { type: 'num', val: token.value },
          right: this.parseExpr(tokens, start + 2)
        };
      }
      return { type: 'num', val: token.value };
    }

    if (token.type === 'STRING') {
      return { type: 'str', val: token.value.slice(1, -1) };
    }

    if (token.type === 'IDENTIFIER') {
      if (start + 2 < tokens.length && tokens[start + 1].type in {'+':1, '-':1, '*':1, '/':1}) {
        return {
          type: 'op',
          op: tokens[start + 1].value,
          left: { type: 'id', name: token.value },
          right: this.parseExpr(tokens, start + 2)
        };
      }
      return { type: 'id', name: token.value };
    }

    return { type: 'null' };
  }
}

// Compile Rip to JavaScript
function compileRip(source) {
  // Lex
  const lexer = new Lexer();
  const rawTokens = lexer.tokenize(source);

  // Convert to object format
  const tokens = rawTokens.map(([type, value, line, column]) => ({
    type, value, line: line || 0, column: column || 0
  }));

  // Rewrite
  const rewriter = new Rewriter();
  const rewritten = rewriter.rewrite(tokens);

  // Parse
  const parser = new SimpleParser();
  const ast = parser.parse(rewritten);

  // Compile
  const compiler = new Compiler();
  return compiler.compile(ast);
}

// Get AST (for --ast flag)
function getAST(source) {
  // Lex
  const lexer = new Lexer();
  const rawTokens = lexer.tokenize(source);

  // Convert to object format
  const tokens = rawTokens.map(([type, value, line, column]) => ({
    type, value, line: line || 0, column: column || 0
  }));

  // Rewrite
  const rewriter = new Rewriter();
  const rewritten = rewriter.rewrite(tokens);

  // Parse
  const parser = new SimpleParser();
  return parser.parse(rewritten);
}

// Main CLI
const args = process.argv.slice(2);

// Handle --version flag
if (args[0] === '--version' || args[0] === '-v') {
  console.log(`Rip v${RIP_VERSION}`);
  process.exit(0);
}

if (args.length === 0) {
  console.log(`Rip v${RIP_VERSION} - A modern language that compiles to JavaScript`);
  console.log('');
  console.log('Usage: rip <file.rip>           # Run the file');
  console.log('       rip -c <file.rip>         # Show compiled JavaScript');
  console.log('       rip --ast <file.rip>      # Show AST nodes');
  console.log('       rip --tokens <file.rip>   # Show token stream');
  console.log('       rip --version             # Show version');
  process.exit(1);
}

let mode = 'run';
let filename = args[0];

if (args[0].startsWith('-')) {
  switch(args[0]) {
    case '-c':
    case '--compile':
      mode = 'compile';
      break;
    case '--ast':
      mode = 'ast';
      break;
    case '--tokens':
      mode = 'tokens';
      break;
    default:
      console.log(`Unknown option: ${args[0]}`);
      process.exit(1);
  }
  filename = args[1];
}

if (!filename) {
  console.log('Error: No file specified');
  process.exit(1);
}

try {
  // Read the Rip file
  const source = fs.readFileSync(filename, 'utf-8');

  switch(mode) {
    case 'run':
      // Compile and run
      const js = compileRip(source);
      eval(js);
      break;

    case 'compile':
      // Show compiled JavaScript with header
      const jsCode = compileRip(source);
      const header = `// Generated by Rip v${RIP_VERSION}\n// Source: ${filename}\n\n`;
      console.log(header + jsCode);
      break;

    case 'ast':
      // Show AST
      const ast = getAST(source);
      console.log(JSON.stringify(ast, null, 2));
      break;

    case 'tokens':
      // Show token stream
      const lexer = new Lexer();
      const rawTokens = lexer.tokenize(source);
      const tokens = rawTokens.map(([type, value, line, column]) => ({
        type, value, line: line || 0, column: column || 0
      }));
      const rewriter = new Rewriter();
      const rewritten = rewriter.rewrite(tokens);

      console.log('Tokens after rewriter:');
      rewritten.forEach(t => {
        const gen = t.generated ? ' [generated]' : '';
        console.log(`  ${t.type}${gen}: "${t.value}"`);
      });
      break;
  }
} catch (e) {
  if (e.code === 'ENOENT') {
    console.error(`Error: File '${filename}' not found`);
  } else {
    console.error(`Error: ${e.message}`);
  }
  process.exit(1);
}
