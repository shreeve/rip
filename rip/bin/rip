#!/usr/bin/env bun
// The Rip CLI - Compile and run .rip files using the FULL Solar parser!

import fs from 'fs';
import { execSync } from 'child_process';
import path from 'path';

// Get version from package.json
const packageJson = JSON.parse(fs.readFileSync(path.join(import.meta.dir, '..', 'package.json'), 'utf-8'));
const RIP_VERSION = packageJson.version;

// Fix exports for our modules
function fixExports(jsPath) {
  let js = fs.readFileSync(jsPath, 'utf-8');
  js = js.replace(/var\s+(\w+);?\s*\1\s*=\s*class\s+\1/g, 'const $1 = class $1')
         .replace(/module\.exports = (\w+);/, '');
  if (!js.includes('export default')) {
    const className = path.basename(jsPath, '.js');
    const exportName = className.charAt(0).toUpperCase() + className.slice(1);
    js += `\nexport default ${exportName};\nexport { ${exportName} };`;
  }
  fs.writeFileSync(jsPath, js);
}

// Compile Solar if needed
function compileSolar() {
  const solarRip = path.join(import.meta.dir, '..', 'src', 'solar.rip');
  const solarJs = path.join(import.meta.dir, '..', 'lib', 'solar.js');

  if (!fs.existsSync(solarJs) || fs.statSync(solarRip).mtime > fs.statSync(solarJs).mtime) {
    console.error('Compiling solar.rip...');
    execSync(`coffee -c -b -o ${path.dirname(solarJs)} ${solarRip}`, { stdio: 'inherit' });
    fixExports(solarJs);
  }
}

// Compile grammar if needed
function compileGrammar() {
  const grammarRip = path.join(import.meta.dir, '..', 'src', 'grammar-solar.rip');
  const grammarJs = path.join(import.meta.dir, '..', 'lib', 'grammar-solar.js');

  if (!fs.existsSync(grammarJs) || fs.statSync(grammarRip).mtime > fs.statSync(grammarJs).mtime) {
    console.error('Compiling grammar-solar.rip...');
    execSync(`coffee -c -b -o ${path.dirname(grammarJs)} ${grammarRip}`, { stdio: 'inherit' });
    fixExports(grammarJs);
  }
}

// Fix all our compiled modules
['compiler', 'lexer', 'rewriter'].forEach(mod => {
  const jsPath = path.join(import.meta.dir, '..', 'lib', `${mod}.js`);
  if (fs.existsSync(jsPath)) {
    fixExports(jsPath);
  }
});

// Compile Solar and grammar if needed
compileSolar();
compileGrammar();

// Import our components
const Lexer = (await import('../lib/lexer.js')).default;
const Rewriter = (await import('../lib/rewriter.js')).default;
const Compiler = (await import('../lib/compiler.js')).default;

// Import the pre-generated parser
const parser = (await import('../lib/parser.js')).default;

// Main compilation pipeline
function compile(code, filename = 'input') {
  try {
    // Step 1: Tokenize
    const lexer = new Lexer();
    const tokens = lexer.tokenize(code);

    // Step 2: Rewrite tokens
    const rewriter = new Rewriter();
    const rewritten = rewriter.rewrite(tokens);

    // Step 3: Parse using Solar!
    // Set up lexer interface for the parser
    const lexerInterface = {
      tokens: rewritten,
      pos: 0,
      yytext: '',
      yylineno: 0,
      yylloc: {},

      setInput: function(tokens) {
        this.tokens = tokens;
        this.pos = 0;
      },

      lex: function() {
        const token = this.tokens[this.pos++];
        if (token) {
          this.yytext = token[1] || '';
          this.yylineno = token[2] || 0;
          this.yylloc = {
            first_line: token[2] || 0,
            first_column: token[3] || 0,
            last_line: token[2] || 0,
            last_column: (token[3] || 0) + (token[1]?.length || 0)
          };
          // Map token type to symbol ID
          const type = token[0];
          // Handle EOF specially - it maps to $end
          if (type === 'EOF') {
            return 1;  // $end symbol ID
          }
          return parser.symbolIds?.[type] || type;
        } else {
          return 1;  // $end when no more tokens
        }
      },

      showPosition: function() {
        return `Line ${this.yylineno}`;
      },

      upcomingInput: function() {
        return '';
      }
    };

    parser.lexer = lexerInterface;
    const ast = parser.parse(rewritten);

    // Step 4: Compile to JavaScript
    const compiler = new Compiler();
    // Wrap the AST array in a root node for the compiler
    const rootAst = { type: 'root', stmts: ast };
    const js = compiler.compile(rootAst);

    return { tokens, rewritten, ast, js };
  } catch (error) {
    console.error(`Error in ${filename}:`, error.message);
    if (error.stack) {
      console.error(error.stack);
    }
    process.exit(1);
  }
}

// Parse command line arguments
const args = process.argv.slice(2);

// Quick debug mode for tokens
if (args[0] === '--debug-tokens') {
  const file = args[1];
  if (!file || !fs.existsSync(file)) {
    console.error('File not found');
    process.exit(1);
  }
  const code = fs.readFileSync(file, 'utf-8');
  const lexer = new Lexer();
  const tokens = lexer.tokenize(code);
  const rewriter = new Rewriter();
  const rewritten = rewriter.rewrite(tokens);
  console.log('Tokens after rewriter:');
  rewritten.forEach(t => {
    console.log(' ', t[0] + ':', JSON.stringify(t[1]));
  });
  process.exit(0);
}

if (args.length === 0 || args[0] === '--help' || args[0] === '-h') {
  console.log('Rip - A clean, simple language that compiles to JavaScript');
  console.log('');
  console.log('Usage: rip <file.rip>           # Run the file');
  console.log('       rip -c <file.rip>         # Show compiled JavaScript');
  console.log('       rip --ast <file.rip>      # Show AST nodes');
  console.log('       rip --tokens <file.rip>   # Show token stream');
  console.log('       rip --version             # Show version');
  console.log('       rip --help                # Show this help');
  process.exit(0);
}

if (args[0] === '--version' || args[0] === '-v') {
  console.log(`Rip v${RIP_VERSION}`);
  process.exit(0);
}

// Determine mode and file
let mode = 'run';
let file = args[0];

if (args[0] === '-c' || args[0] === '--compile') {
  mode = 'compile';
  file = args[1];
} else if (args[0] === '--ast') {
  mode = 'ast';
  file = args[1];
} else if (args[0] === '--tokens') {
  mode = 'tokens';
  file = args[1];
}

if (!file) {
  console.error('Error: No file specified');
  process.exit(1);
}

// Read the file
if (!fs.existsSync(file)) {
  console.error(`Error: File not found: ${file}`);
  process.exit(1);
}

const code = fs.readFileSync(file, 'utf-8');
const { tokens, rewritten, ast, js } = compile(code, file);

// Execute based on mode
switch (mode) {
  case 'tokens':
    console.log('Original tokens:');
    tokens.forEach(t => {
      const [type, value] = t;
      if (type === 'TERMINATOR') {
        console.log(`  ${type}: "\\n"`);
      } else {
        console.log(`  ${type}: "${value}"`);
      }
    });
    console.log('\nTokens after rewriter:');
    rewritten.forEach(t => {
      const [type, value, , , meta] = t;
      const suffix = meta?.generated ? ' [generated]' : '';
      if (type === 'TERMINATOR') {
        console.log(`  ${type}${suffix}: "\\n"`);
      } else {
        console.log(`  ${type}${suffix}: "${value}"`);
      }
    });
    break;

  case 'ast':
    console.log('AST:', JSON.stringify(ast, null, 2));
    break;

  case 'compile':
    // Add version header
    console.log(`// Generated by Rip v${RIP_VERSION}`);
    console.log(`// Source: ${file}`);
    console.log('');
    console.log(js);
    break;

  case 'run':
  default:
    // Run the compiled JavaScript
    try {
      eval(js);
    } catch (error) {
      console.error('Runtime error:', error.message);
      if (error.stack) {
        console.error(error.stack);
      }
      process.exit(1);
    }
    break;
}