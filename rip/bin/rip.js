// Generated by Rip Simple Bootstrap Compiler

//!/usr/bin/env bun
// Rip CLI - Command-line interface for the Rip compiler
// Primary target: Bun, but falls back gracefully to other runtimes

import { compile, compileFile } from '../src/compiler.js';
import { version } from '../package.json';

class RipCLI {
  constructor() {
    this.args = this.parseArgs();
    this.runtime = this.detectRuntime();

  parseArgs() {
    // Get command-line arguments (works across runtimes)
    const args = @getRuntimeArgs();

    const options = {
      help: false
      version: false
      compile: false
      output: null
      execute: false
      bare: true
      sourceMap: false
      watch: false
      stdin: false
      files: []
    }

    const i = 0;
    while (i < args.length) {
      const arg = args[i];
      switch (arg) {
          case '-h':
          case '--help':
          options.help = true
          case '-v':
          case '--version':
          options.version = true
          case '-c':
          case '--compile':
          options.compile = true
          case '-o':
          case '--output':
          options.output = args[++i]
          case '-e':
          case '--execute':
          options.execute = true
          case '-b':
          case '--bare':
          options.bare = true
          case '--no-bare':
          options.bare = false
          case '-m':
          case '--map':
          case '--source-map':
          options.sourceMap = true
          case '-w':
          case '--watch':
          options.watch = true
          case '-s':
          case '--stdin':
          options.stdin = true
        } else {
          if (!(arg.startsWith('-'))) {
            options.files.push(arg)
      i++

    options

  getRuntimeArgs() {
    // Bun
    if (typeof Bun isnt 'undefined') {
      return Bun.argv.slice(2);

    // Deno
    if (typeof Deno isnt 'undefined') {
      return Deno.args;

    // Node.js
    if (typeof process isnt 'undefined') {
      return process.argv.slice(2);

    // Browser (shouldn't happen for CLI)
    []

  detectRuntime() {
    if (typeof Bun isnt 'undefined') {
      'bun'
    else if typeof Deno isnt 'undefined'
      'deno'
    else if typeof process isnt 'undefined'
      'node'
    } else {
      'unknown'

  run() {
    // Show help
    if this.args.help or this.args.files.length is 0 and not this.args.stdin;
      this.showHelp();
      return;

    // Show version
    if this.args.version;
      this.showVersion();
      return;

    // Read from stdin
    if this.args.stdin;
      this.compileStdin();
      return;

    // Watch mode (Bun-specific feature for now)
    if this.args.watch;
      if this.runtime is 'bun';
        this.watchFiles();
      } else {
        console.error "Watch mode is currently only supported in Bun"
        this.exit(1);
      return;

    // Compile files
    this.compileFiles();

  showHelp() {
    console.log """
    Rip - A modern programming language that compiles to ES6+

    Usage: rip [options] [files]

    Options:
      -h, --help          Show this help message
      -v, --version       Show version
      -c, --compile       Compile to JavaScript
      -o, --output FILE   Output to file (otherwise stdout)
      -e, --execute       Execute compiled JavaScript
      -b, --bare          Compile without wrapper (default)
      --no-bare           Compile with wrapper
      -m, --source-map    Generate source map
      -w, --watch         Watch files for changes (Bun only)
      -s, --stdin         Read from stdin

    Examples:
      rip -c script.rip              # Compile to stdout
      rip -c script.rip -o script.js # Compile to file
      rip -e script.rip              # Compile and execute
      echo 'x = 42' | rip -cs       # Compile from stdin

    Runtime: #{this.runtime}
    Version: #{version}
    """

  showVersion() {
    console.log "Rip v#{version} (runtime: #{this.runtime})";

  compileStdin: async ->
    const source = await @readStdin();

    try {
      const result = compile(source, {;
        filename: '<stdin>'
        bare: this.args.bare;
        sourceMap: this.args.sourceMap;
      })

      if this.args.execute;
        this.executeJS(result);
      } else {
        console.log(result)
    } catch (error) {
      console.error("Compilation error:", error.message)
      this.exit(1);

  compileFiles: async ->
    for file in this.args.files;
      try {
        const result = await compileFile(file, {;
          bare: this.args.bare;
          sourceMap: this.args.sourceMap;
        })

        if this.args.output;
          await this.writeFile(this.args.output, result);
          console.log("Compiled #{file} -> #{this.args.output}");
        else if this.args.execute;
          this.executeJS(result);
        } else {
          console.log(result)

      } catch (error) {
        console.error("Error compiling #{file}:", error.message)
        this.exit(1);

  watchFiles() {
    console.log("Watching files for changes... (Ctrl+C to stop)")

    // Bun-specific file watcher
    if (typeof Bun isnt 'undefined') {
      // This would use Bun's file watching API
      console.log("Watch mode not yet implemented")
    } else {
      console.error("Watch mode requires Bun runtime")

  readStdin() {
    // Bun
    if (typeof Bun isnt 'undefined') {
      const reader = Bun.stdin.stream().getReader();
      const chunks = [];

      loop
        { done, value } = await reader.read()
        break if done
        chunks.push(value)

      const decoder = new TextDecoder();
      return chunks.map((chunk) -> decoder.decode(chunk)).join('');

    // Deno
    if (typeof Deno isnt 'undefined') {
      const decoder = new TextDecoder();
      const data = await Deno.readAll(Deno.stdin);
      return decoder.decode(data);

    // Node.js
    if (typeof process isnt 'undefined') {
      return new Promise (resolve) ->;
        const chunks = [];
        process.stdin.on 'data', (chunk) -> chunks.push(chunk)
        process.stdin.on 'end', -> resolve(chunks.join(''))

    throw new Error("Cannot read from stdin in this environment")

  writeFile(filepath, content) {
    // Bun
    if (typeof Bun isnt 'undefined') {
      return Bun.write(filepath, content);

    // Deno
    if (typeof Deno isnt 'undefined') {
      const encoder = new TextEncoder();
      return Deno.writeFile(filepath, encoder.encode(content));

    // Node.js
    if (typeof process isnt 'undefined') {
      { promises: fs } = await import('fs')
      return fs.writeFile(filepath, content, 'utf8');

    throw new Error("Cannot write files in this environment")

  executeJS(js) {
    // For now, just eval the JavaScript
    // In a real implementation, we'd want better isolation
    try {
      eval(js)
    } catch (error) {
      console.error("Runtime error:", error.message)
      this.exit(1);

  exit(code = 0) {
    // Bun
    if (typeof Bun isnt 'undefined') {
      process.exit(code)

    // Deno
    if (typeof Deno isnt 'undefined') {
      Deno.exit(code)

    // Node.js
    if (typeof process isnt 'undefined') {
      process.exit(code)

// Run the CLI
const cli = new RipCLI();
cli.run()
