# COMPLETE MINIMAL RIP GRAMMAR
# Beautiful, simple, powerful - using Rip's own syntax!

# Helper for rules - keeps pattern/action pairs clean
o = (pattern, action) ->
  # If no action provided, default to passthrough
  action ?= -> $1
  [pattern, action]

# Binary operator helper - super DRY!
binOp = (ripOp, jsOp = ripOp) ->
  o "Expression #{ripOp} Expression", ->
    type: 'op', op: jsOp, left: $1, right: $3, pos: '@$'

# Unary operator helper
unOp = (ripOp, jsOp = ripOp) ->
  o "#{ripOp} Expression", ->
    type: 'unary', op: jsOp, expr: $2, pos: '@$'

# The grammar - clean and simple!
grammar =

  # Operator precedence (from lowest to highest)
  operators: [
    ["right", "=", "+=", "-=", "*=", "/="]
    ["left", "or", "||"]
    ["left", "and", "&&"]
    ["left", "==", "!=", "is", "isnt"]
    ["left", "<", ">", "<=", ">=", "in", "of"]
    ["left", "+", "-"]
    ["left", "*", "/", "%"]
    ["right", "!", "not", "typeof"]
    ["left", ".", "?.", "[", "]"]
    ["left", "CALL"]
  ]

  # The beautiful BNF rules
  bnf:

    # Program structure
    Root: [
      o "Body"
    ]

    Body: [
      o "Line", -> [$1]
      o "Body TERMINATOR Line", -> $1.push($3); $1
      o "Body TERMINATOR"
    ]

    Line: [
      o "Expression"
      o "Statement"
      o "", -> null
    ]

    # Statements (can't be expressions)
    Statement: [
      o "Return"
      o "Throw"
      o "Break"
      o "Continue"
      o "Import"
      o "Export"
    ]

    # Expressions (produce values)
    Expression: [
      o "Value"
      o "Assign"
      o "Operation"
      o "Code"
      o "If"
      o "For"
      o "While"
      o "Try"
    ]

    # Values - things that can be assigned to or called
    Value: [
      o "Literal"
      o "Identifier"
      o "ThisProperty"
      o "Array"
      o "Object"
      o "Parenthetical"
      o "Range"
      o "Invocation"
      o "Member"
    ]

    # Literals - the atoms of our language
    Literal: [
      o "NUMBER", -> type: 'num', val: $1, pos: '@$'
      o "STRING", -> type: 'str', val: $1, pos: '@$'
      o "BOOL", -> type: 'bool', val: $1, pos: '@$'
      o "NULL", -> type: 'null', pos: '@$'
      o "UNDEFINED", -> type: 'undef', pos: '@$'
      o "REGEX", -> type: 'regex', val: $1, pos: '@$'
    ]

    # Identifiers and properties
    Identifier: [
      o "IDENTIFIER", -> type: 'id', name: $1, pos: '@$'
    ]

    ThisProperty: [
      o "@ IDENTIFIER", ->
        type: 'prop',
        obj: {type: 'this', pos: '@1'},
        prop: {type: 'id', name: $2, pos: '@2'},
        pos: '@$'
    ]

    # Member access (dot notation and brackets)
    Member: [
      o "Value . IDENTIFIER", ->
        type: 'prop', obj: $1, prop: {type: 'id', name: $3, pos: '@3'}, pos: '@$'

      o "Value ?. IDENTIFIER", ->
        type: 'prop', obj: $1, prop: {type: 'id', name: $3, pos: '@3'}, optional: yes, pos: '@$'

      o "Value [ Expression ]", ->
        type: 'index', obj: $1, index: $3, pos: '@$'

      o "Value ?[ Expression ]", ->
        type: 'index', obj: $1, index: $3, optional: yes, pos: '@$'
    ]

    # Arrays
    Array: [
      o "[ ]", -> type: 'array', items: [], pos: '@$'
      o "[ ArgList ]", -> type: 'array', items: $2, pos: '@$'
      o "[ ArgList , ]", -> type: 'array', items: $2, pos: '@$'  # trailing comma
    ]

    # Objects
    Object: [
      o "{ }", -> type: 'object', props: [], pos: '@$'
      o "{ PropList }", -> type: 'object', props: $2, pos: '@$'
      o "{ PropList , }", -> type: 'object', props: $2, pos: '@$'  # trailing comma
    ]

    PropList: [
      o "Property", -> [$1]
      o "PropList , Property", -> $1.concat $3
      o "PropList TERMINATOR Property", -> $1.concat $3
    ]

    Property: [
      o "IDENTIFIER : Expression", ->
        key: {type: 'id', name: $1, pos: '@1'}, val: $3, pos: '@$'

      o "STRING : Expression", ->
        key: {type: 'str', val: $1, pos: '@1'}, val: $3, pos: '@$'

      o "[ Expression ] : Expression", ->
        key: $2, val: $4, computed: yes, pos: '@$'

      o "IDENTIFIER", ->  # shorthand
        key: {type: 'id', name: $1, pos: '@1'},
        val: {type: 'id', name: $1, pos: '@1'},
        shorthand: yes, pos: '@$'
    ]

    # Ranges
    Range: [
      o "[ Expression .. Expression ]", ->
        type: 'range', from: $2, to: $4, exclusive: no, pos: '@$'

      o "[ Expression ... Expression ]", ->
        type: 'range', from: $2, to: $4, exclusive: yes, pos: '@$'
    ]

    # Assignment
    Assign: [
      o "Assignable = Expression", ->
        type: 'assign', left: $1, right: $3, pos: '@$'

      o "Assignable = INDENT Expression OUTDENT", ->
        type: 'assign', left: $1, right: $4, pos: '@$'

      o "Assignable += Expression", ->
        type: 'assign', left: $1, right: $3, op: '+=', pos: '@$'

      o "Assignable -= Expression", ->
        type: 'assign', left: $1, right: $3, op: '-=', pos: '@$'

      o "Assignable *= Expression", ->
        type: 'assign', left: $1, right: $3, op: '*=', pos: '@$'

      o "Assignable /= Expression", ->
        type: 'assign', left: $1, right: $3, op: '/=', pos: '@$'
    ]

    Assignable: [
      o "Identifier"
      o "Member"
      o "ThisProperty"
    ]

    # Operations - using our beautiful helpers!
    Operation: [
      # Binary operators
      binOp "+"
      binOp "-"
      binOp "*"
      binOp "/"
      binOp "%"
      binOp "**"  # power
      binOp "=="
      binOp "!="
      binOp "<"
      binOp ">"
      binOp "<="
      binOp ">="
      binOp "and", "&&"
      binOp "or", "||"
      binOp "is", "==="
      binOp "isnt", "!=="
      binOp "in"
      binOp "of"
      binOp "instanceof"

      # Unary operators
      unOp "!"
      unOp "not", "!"
      unOp "-"
      unOp "+"
      unOp "typeof"
      unOp "delete"

      # Postfix
      o "Expression ++", -> type: 'update', op: '++', expr: $1, prefix: no, pos: '@$'
      o "Expression --", -> type: 'update', op: '--', expr: $1, prefix: no, pos: '@$'
      o "++ Expression", -> type: 'update', op: '++', expr: $2, prefix: yes, pos: '@$'
      o "-- Expression", -> type: 'update', op: '--', expr: $2, prefix: yes, pos: '@$'

      # Ternary
      o "Expression ? Expression : Expression", ->
        type: 'ternary', test: $1, then: $3, else: $5, pos: '@$'
    ]

    # Function invocation
    Invocation: [
      o "Value ( )", -> type: 'call', func: $1, args: [], pos: '@$'
      o "Value ( ArgList )", -> type: 'call', func: $1, args: $3, pos: '@$'
      o "Value ?( )", -> type: 'call', func: $1, args: [], optional: yes, pos: '@$'
      o "Value ?( ArgList )", -> type: 'call', func: $1, args: $3, optional: yes, pos: '@$'
    ]

    ArgList: [
      o "Expression", -> [$1]
      o "ArgList , Expression", -> $1.concat $3
    ]

    # Functions (Code)
    Code: [
      o "-> Block", -> type: 'func', params: [], body: $2, bound: no, pos: '@$'
      o "=> Block", -> type: 'func', params: [], body: $2, bound: yes, pos: '@$'
      o "ParamList -> Block", -> type: 'func', params: $1, body: $3, bound: no, pos: '@$'
      o "ParamList => Block", -> type: 'func', params: $1, body: $3, bound: yes, pos: '@$'
    ]

    ParamList: [
      o "( )", -> []
      o "( Params )", -> $2
      o "Param", -> [$1]  # no parens for single param
    ]

    Params: [
      o "Param", -> [$1]
      o "Params , Param", -> $1.concat $3
    ]

    Param: [
      o "IDENTIFIER", -> type: 'param', name: $1, pos: '@$'
      o "IDENTIFIER = Expression", -> type: 'param', name: $1, default: $3, pos: '@$'
      o "... IDENTIFIER", -> type: 'param', name: $2, rest: yes, pos: '@$'
    ]

    # Control flow
    If: [
      o "IF Expression Block", ->
        type: 'if', test: $2, then: $3, pos: '@$'

      o "IF Expression Block ELSE Block", ->
        type: 'if', test: $2, then: $3, else: $5, pos: '@$'

      o "IF Expression Block ELSE IF Expression Block", ->
        type: 'if', test: $2, then: $3,
        else: {type: 'if', test: $5, then: $7, pos: '@5'}, pos: '@$'

      o "Expression IF Expression", ->  # postfix
        type: 'if', test: $3, then: $1, postfix: yes, pos: '@$'

      o "Expression UNLESS Expression", ->  # postfix unless
        type: 'if', test: $3, then: $1, invert: yes, postfix: yes, pos: '@$'
    ]

    For: [
      o "FOR IDENTIFIER IN Expression Block", ->
        type: 'for-in', var: $2, iter: $4, body: $5, pos: '@$'

      o "FOR IDENTIFIER OF Expression Block", ->
        type: 'for-of', var: $2, iter: $4, body: $5, pos: '@$'

      o "Expression FOR IDENTIFIER IN Expression", ->  # comprehension
        type: 'for-in', var: $3, iter: $5, body: $1, postfix: yes, pos: '@$'
    ]

    While: [
      o "WHILE Expression Block", ->
        type: 'while', test: $2, body: $3, pos: '@$'

      o "UNTIL Expression Block", ->
        type: 'while', test: $2, body: $3, invert: yes, pos: '@$'

      o "LOOP Block", ->
        type: 'while', test: {type: 'bool', val: 'true', pos: '@1'}, body: $2, pos: '@$'
    ]

    Try: [
      o "TRY Block", ->
        type: 'try', body: $2, pos: '@$'

      o "TRY Block CATCH IDENTIFIER Block", ->
        type: 'try', body: $2, param: $4, handler: $5, pos: '@$'

      o "TRY Block FINALLY Block", ->
        type: 'try', body: $2, finalizer: $4, pos: '@$'
    ]

    # Other statements
    Return: [
      o "RETURN", -> type: 'return', pos: '@$'
      o "RETURN Expression", -> type: 'return', val: $2, pos: '@$'
    ]

    Throw: [
      o "THROW Expression", -> type: 'throw', arg: $2, pos: '@$'
    ]

    Break: [
      o "BREAK", -> type: 'break', pos: '@$'
    ]

    Continue: [
      o "CONTINUE", -> type: 'continue', pos: '@$'
    ]

    # Module system
    Import: [
      o "IMPORT STRING", ->
        type: 'import', source: $2, pos: '@$'

      o "IMPORT IDENTIFIER FROM STRING", ->
        type: 'import', default: $2, source: $4, pos: '@$'

      o "IMPORT { ImportList } FROM STRING", ->
        type: 'import', specs: $3, source: $6, pos: '@$'

      o "IMPORT * AS IDENTIFIER FROM STRING", ->
        type: 'import', namespace: $4, source: $6, pos: '@$'
    ]

    ImportList: [
      o "IDENTIFIER", -> [{imported: $1, local: $1}]
      o "IDENTIFIER AS IDENTIFIER", -> [{imported: $1, local: $3}]
      o "ImportList , IDENTIFIER", -> $1.concat [{imported: $3, local: $3}]
      o "ImportList , IDENTIFIER AS IDENTIFIER", -> $1.concat [{imported: $3, local: $5}]
    ]

    Export: [
      o "EXPORT Expression", ->
        type: 'export', val: $2, pos: '@$'

      o "EXPORT DEFAULT Expression", ->
        type: 'export', val: $3, default: yes, pos: '@$'

      o "EXPORT { ExportList }", ->
        type: 'export', specs: $3, pos: '@$'
    ]

    ExportList: [
      o "IDENTIFIER", -> [{local: $1, exported: $1}]
      o "IDENTIFIER AS IDENTIFIER", -> [{local: $1, exported: $3}]
      o "ExportList , IDENTIFIER", -> $1.concat [{local: $3, exported: $3}]
      o "ExportList , IDENTIFIER AS IDENTIFIER", -> $1.concat [{local: $3, exported: $5}]
    ]

    # Blocks
    Block: [
      o "INDENT Body OUTDENT", -> $2
      o "Expression", -> [$1]
    ]

    # Parenthetical (for grouping)
    Parenthetical: [
      o "( Expression )", -> $2  # just pass through, parens were for precedence
    ]

  # Start symbol
  start: "Root"

# Export the grammar
module.exports = grammar
