# Minimal Rip Compiler
# Transforms our simple object AST to JavaScript

class Compiler
  constructor: ->
    @indent = 0
    @code = []

  # Main compile function
  compile: (ast) ->
    @code = []
    @indent = 0
    result = @node(ast)
    result

  # Compile any node based on its type
  node: (n) ->
    return '' unless n?

    switch n.type

      # Literals
      when 'num'    then n.val
      when 'str'    then @string(n.val)
      when 'bool'   then n.val
      when 'null'   then 'null'
      when 'undef'  then 'undefined'
      when 'id'     then n.name
      when 'prop'   then @prop(n)
      when 'index'  then @index(n)

      # Operations
      when 'op'     then @op(n)
      when 'unary'  then @unary(n)
      when 'assign' then @assign(n)

      # Functions
      when 'func'   then @func(n)
      when 'call'   then @call(n)
      when 'return' then @return(n)

      # Control flow
      when 'if'     then @if(n)
      when 'while'  then @while(n)
      when 'for'    then @for(n)

      # Collections
      when 'array'  then @array(n)
      when 'object' then @object(n)
      when 'access' then @access(n)

      # Structure
      when 'block'  then @block(n)
      when 'root'   then @root(n)
      when 'stmt'   then @stmt(n)

      else
        console.warn "Unknown node type: #{n.type}"
        ''

  # String with proper escaping
  string: (val) ->
    # Handle quote style
    if val.indexOf('"') >= 0 and val.indexOf("'") < 0
      "'#{val}'"
    else
      "\"#{val.replace(/"/g, '\\"')}\""

  # Binary operations
  op: (n) ->
    left = @node(n.left)
    right = @node(n.right)

    # Special cases
    switch n.op
      when '**'  then "Math.pow(#{left}, #{right})"
      when '//'  then "Math.floor(#{left} / #{right})"
      when 'in'  then "(#{right}).includes(#{left})"
      when 'of'  then "(#{left} in #{right})"
      when 'is'  then "#{left} === #{right}"
      when 'isnt' then "#{left} !== #{right}"
      else "(#{left} #{n.op} #{right})"

  # Unary operations
  unary: (n) ->
    expr = @node(n.expr)
    switch n.op
      when 'not' then "!#{expr}"
      when 'typeof' then "typeof #{expr}"
      else "#{n.op}#{expr}"

  # Assignment
  assign: (n) ->
    target = @node(n.target)
    value = @node(n.value)
    op = n.op || '='

    # Add 'let' for first assignment (simple heuristic)
    if op is '=' and n.target.type is 'id'
      "let #{target} = #{value}"
    else
      "#{target} #{op} #{value}"

  # Function definition
  func: (n) ->
    params = n.params?.map((p) => @node(p)).join(', ') || ''
    body = @node(n.body)

    # Arrow function
    if n.arrow
      if n.body.type is 'block'
        "(#{params}) => #{body}"
      else
        "(#{params}) => #{body}"
    else
      # Regular function
      "function(#{params}) #{body}"

  # Function call
  call: (n) ->
    func = @node(n.func)
    args = n.args?.map((a) => @node(a)).join(', ') || ''
    "#{func}(#{args})"

  # Property access
  prop: (n) ->
    obj = @node(n.obj)
    # prop is a node with type 'id' containing the name
    propName = n.prop.name
    if n.optional
      "#{obj}?.#{propName}"
    else
      "#{obj}.#{propName}"

  # Index access
  index: (n) ->
    obj = @node(n.obj)
    idx = @node(n.index)
    if n.optional
      "#{obj}?.[#{idx}]"
    else
      "#{obj}[#{idx}]"

  # Return statement
  return: (n) ->
    if n.expr
      "return #{@node(n.expr)}"
    else
      "return"

  # If statement
  if: (n) ->
    cond = @node(n.cond)
    then_ = @node(n.then)
    else_ = if n.else then @node(n.else) else null

    # Ternary for simple expressions
    if n.expr and not n.else?.type is 'if'
      if else_
        "(#{cond} ? #{then_} : #{else_})"
      else
        "(#{cond} && #{then_})"
    else
      # Full if statement
      code = "if (#{cond}) #{then_}"
      if else_
        code += " else #{else_}"
      code

  # While loop
  while: (n) ->
    cond = @node(n.cond)
    body = @node(n.body)
    "while (#{cond}) #{body}"

  # For loop (simplified)
  for: (n) ->
    # Handle for..in and for..of
    if n.var and n.iterable
      var_ = @node(n.var)
      iter = @node(n.iterable)
      body = @node(n.body)

      if n.own  # for own key of object
        "for (const #{var_} in #{iter}) if (#{iter}.hasOwnProperty(#{var_})) #{body}"
      else if n.of
        "for (const #{var_} of #{iter}) #{body}"
      else
        "for (const #{var_} in #{iter}) #{body}"
    else
      # C-style for loop
      "for (#{@node(n.init)}; #{@node(n.cond)}; #{@node(n.update)}) #{@node(n.body)}"

  # Array literal
  array: (n) ->
    items = n.items?.map((i) => @node(i)).join(', ') || ''
    "[#{items}]"

  # Object literal
  object: (n) ->
    pairs = n.pairs?.map((p) =>
      key = if p.key.type is 'str' then p.key.val else @node(p.key)
      val = @node(p.value)
      "#{key}: #{val}"
    ).join(', ') || ''
    "{#{pairs}}"

  # Property/index access
  access: (n) ->
    obj = @node(n.object)

    if n.computed
      # obj[prop]
      prop = @node(n.property)
      "#{obj}[#{prop}]"
    else
      # obj.prop
      prop = @node(n.property)
      "#{obj}#{prop}"

  # Statement (adds semicolon if needed)
  stmt: (n) ->
    code = @node(n.expr)
    if code and not code.match(/[{}]$/)
      "#{code};"
    else
      code

  # Block of statements
  block: (n) ->
    if not n.stmts or n.stmts.length is 0
      '{}'
    else
      stmts = n.stmts.map((s) => @stmt(s)).filter((s) -> s).join('\n')
      "{\n#{@indented(stmts)}\n}"

  # Root/program
  root: (n) ->
    # Each statement is directly a node, not wrapped in stmt
    stmts = n.stmts?.map((s) => 
      code = @node(s)
      # Add semicolon if needed
      if code and not code.match(/[{}]$/)
        "#{code};"
      else
        code
    ).filter((s) -> s).join('\n') || ''
    stmts

  # Helper for indentation
  indented: (code) ->
    code.split('\n').map((line) -> '  ' + line).join('\n')

export default Compiler
export { Compiler }
