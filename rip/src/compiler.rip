# Rip Compiler - Main compilation pipeline
# Targets pure ES6/ESM for maximum compatibility
# Primary runtime: Bun, but works in Deno, Node.js, and browsers

import { Lexer } from './lexer.rip'
import { Parser } from './parser.rip'
import * as nodes from './nodes.rip'

export class Compiler
  constructor: (options = {}) ->
    @options = {
      # Default options
      bare: true           # Don't wrap in IIFE
      sourceMap: false     # Source map generation
      header: true         # Add "Generated by Rip" header
      filename: 'unknown'  # Source filename
      runtime: 'auto'      # auto, bun, deno, node, browser
      ...options
    }

    @lexer = new Lexer()
    @parser = new Parser()

  # Main compile function - works in all environments
  compile: (source, options = {}) ->
    options = { ...@options, ...options }

    try
      # Tokenize
      tokens = @lexer.tokenize(source)

      # Parse
      ast = @parser.parse(tokens)

      # Generate JavaScript
      js = @generate(ast, options)

      # Add header if requested
      if options.header
        header = @generateHeader(options)
        js = header + js

      # Return result
      if options.sourceMap
        { js, sourceMap: null }  # TODO: Implement source maps
      else
        js

    catch error
      # Format error nicely
      @formatError(error, source, options)

  # Create a mock AST for testing until parser is ready
  createMockAST: (tokens) ->
    root = new nodes.Root()
    body = new nodes.Block()

    # Super simple: just create literals for each non-whitespace token
    for token in tokens
      if token.type not in ['NEWLINE', 'EOF'] and token.value.trim()
        body.push new nodes.Literal(token.value)

    root.body = body
    root

  # Generate JavaScript from AST
  generate: (ast, options) ->
    ast.compile(options)

  # Generate file header
  generateHeader: (options) ->
    runtime = @detectRuntime(options.runtime)

    """
    // Generated by Rip v0.1.0
    // Runtime: #{runtime}
    // Platform: #{@getPlatformInfo()}

    """

  # Detect runtime environment
  detectRuntime: (runtime) ->
    return runtime unless runtime is 'auto'

    # Check for Bun
    if typeof Bun isnt 'undefined'
      return 'bun'

    # Check for Deno
    if typeof Deno isnt 'undefined'
      return 'deno'

    # Check for Node.js
    if typeof process isnt 'undefined' and process.versions?.node
      return 'node'

    # Default to browser
    'browser'

  # Get platform information for header
  getPlatformInfo: ->
    if typeof Bun isnt 'undefined'
      "Bun #{Bun.version}"
    else if typeof Deno isnt 'undefined'
      "Deno #{Deno.version.deno}"
    else if typeof process isnt 'undefined'
      "Node.js #{process.version}"
    else if typeof navigator isnt 'undefined'
      navigator.userAgent
    else
      "Unknown"

  # Format compilation errors nicely
  formatError: (error, source, options) ->
    message = error.message

    # Add location info if available
    if error.line? and error.column?
      lines = source.split('\n')
      errorLine = lines[error.line - 1]

      message = """
        #{message}
        at #{options.filename}:#{error.line}:#{error.column}

        #{error.line} | #{errorLine}
        #{' '.repeat(String(error.line).length + 3 + error.column - 1)}^
      """

    throw new Error(message)

# Platform-agnostic compile function
export compile = (source, options) ->
  compiler = new Compiler(options)
  compiler.compile(source, options)

# Runtime-specific file compilation (only when file system is available)
export compileFile = (filepath, options = {}) ->
  # This will use runtime-specific file reading
  source = await readFile(filepath)
  options.filename = filepath
  compile(source, options)

# Platform-specific file reading
readFile = (filepath) ->
  # Bun (primary target)
  if typeof Bun isnt 'undefined'
    file = Bun.file(filepath)
    return file.text()

  # Deno
  if typeof Deno isnt 'undefined'
    decoder = new TextDecoder('utf-8')
    data = await Deno.readFile(filepath)
    return decoder.decode(data)

  # Node.js
  if typeof process isnt 'undefined'
    { promises: fs } = await import('fs')
    return fs.readFile(filepath, 'utf8')

  # Browser - can't read local files
  throw new Error('File system access not available in browser environment')

# Export nodes for parser to use
export { nodes }
