// Generated by Rip Bootstrap Compiler
// This is a bootstrap compilation - not feature complete

//!/usr/bin/env coffee
// ==============================================================================
// Solar - SLR(1) Parser Generator for CoffeeScript
//
// Clean implementation influenced by Jison, but rewritten in CoffeeScript for
// readability, efficiency, and maintainability.
//
// Author: Steve Shreeve <steve.shreeve@gmail.com>
//   Date: Aug 1, 2025
// ==============================================================================
// Terminal symbols (tokens, cannot be expanded)
class Terminal {
  constructor() {
this.id   = id;
this.name = name;
// Nonterminal symbols (can be expanded by productions)
class Nonterminal {
  constructor() {
this.id          = id;
this.name        = name;
this.productions = []      # productions where this symbol is the LHS;
this.nullable    = false   # true if symbol can derive empty string;
this.first       = new Set # terminals that can appear first;
this.follows     = new Set # terminals that can follow this symbol;
// Production rule (Expression → Expression + Term)
class Production {
  constructor() {
this.lhs        = lhs     # left-hand side (nonterminal);
this.rhs        = rhs     # right-hand side (array of symbols);
this.id         = id      # unique production number;
this.nullable   = false   # true if RHS can derive empty string;
this.first      = new Set # terminals that can appear first in RHS;
this.precedence = 0       # operator precedence for conflict resolution;
// LR item (Expression → Expression • + Term)
class Item {
  constructor() {
this.production = production                  # the production rule;
this.dot        = dot                         # position of parse progress;
this.lookaheads = new Set(lookaheads or [])   # defensive copy, handle null/undefined;
this.nextSymbol = this.production.rhs[this.dot]       # symbol after dot (if any);
this.id         = this.production.id * 100 + this.dot # compact unique ID;
// LR state (set of items with transitions)
class LRState {
  constructor() {
this.id           = null           # state number (assigned later);
this.items        = new Set(items) # kernel and closure items;
this.transitions  = new Map        # symbol → next state;
this.reductions   = new Set        # reduction items;
this.hasShifts    = false          # has shift actions;
this.hasConflicts = false          # has shift/reduce or reduce/reduce conflicts;
// ==============================================================================
// SLR(1) Parser Generator
// ==============================================================================
class Generator {
  constructor() {
// Configuration
this.options = Object.assign {}, grammar.options, options;
this.parseParams = grammar.parseParams;
this.yy = {};
// Grammar structures
this.operators   = {};
this.productions = [];
this.conflicts   = 0;
// Initialize symbol table with special symbols
this.symbolTable = new Map;
this.symbolTable.set "$accept", new Nonterminal "$accept", 0;
this.symbolTable.set "$end"   , new Terminal    "$end"   , 1;
this.symbolTable.set "error"  , new Terminal    "error"  , 2;
// Code generation setup
this.moduleInclude = grammar.moduleInclude or '';
this.actionInclude = grammar.actionInclude and;
  if (typeof grammar.actionInclude is 'function') {
    String(grammar.actionInclude).replace(/^\s*function \(\) \{|\}\s*$/g, '')
  } else {
    grammar.actionInclude
// Build parser
this.timing '💥 Total time', =>;
this.timing 'processGrammar'   , => this.processGrammar grammar # Process grammar rules;
this.timing 'buildLRAutomaton' , => this.buildLRAutomaton()     # Build LR(0) automaton;
this.timing 'processLookaheads', => this.processLookaheads()    # Compute FIRST/FOLLOW and assign lookaheads;
this.timing 'buildParseTable'  , => this.buildParseTable()      # Build parse table with default actions;
// ============================================================================
// Helper Functions
// ============================================================================
timing(label, fn) {
    console.time(label)
    const result = fn() if fn;
    console.timeEnd(label)
    result
// ============================================================================
// Grammar Processing
// ============================================================================
processGrammar(grammar) {
this.nonterminals = {};
this.operators = this._processOperators grammar.operators;
this._buildProductions grammar.bnf, this.productions, this.nonterminals, this.operators;
this._augmentGrammar grammar;
_processOperators(ops) {
    return {} unless ops;
    const operators = {};
  for precedence, i in ops {
  for (const k of [1...precedence.length]) {
    operators[precedence[k]] = {precedence: i + 1, assoc: precedence[0]};
    operators
_buildProductions(bnf, productions, nonterminals, operators) {
    const actionGroups = {};
    const productionTable = [0];
this.symbolIds = {"$accept": 0, "$end": 1, "error": 2}  # Add reserved symbols;
    const symbolId = 3 # Next available symbol ID (after special symbols);
// Add symbol to symbol table if not already present
    const addSymbol = (name) =>;
    return if not name or @symbolIds[name];
// Use existing symbol or create a new one
    unless symbol = @symbolTable.get(name);
    const id = symbolId++;
    const symbol = if bnf[name] then new Nonterminal(name, id) else new Terminal(name, id);
this.symbolTable.set name, symbol;
this.symbolIds[name] = symbol.id;
// Process nonterminals and their productions
  for own symbol, rules of bnf {
    addSymbol symbol
    nonterminals[symbol] = @symbolTable.get symbol;
    const handles = if typeof rules is 'string' then rules.split(/\s*\|\s*/g) else rules[..];
  for (const handle of handles) {
    [rhs, action, precedence] = @_parseHandle handle;
// Add symbols to grammar
    addSymbol token for token in rhs
// Process semantic actions
  if (action) {
    const action = this._processSemanticAction action, rhs;
    const label = 'case ' + (productions.length + 1) + ':';
    actionGroups[action]?.push(label) or actionGroups[action] = [label];
// Create production
    const production = new Production symbol, rhs, productions.length + 1;
// Set precedence
this._assignPrecedence production, precedence, operators, nonterminals;
    productions.push production
    productionTable.push [@symbolIds[symbol], if rhs[0] is '' then 0 else rhs.length]
    nonterminals[symbol].productions.push production
// Generate parser components
    const actionsCode = this._generateActionCode actionGroups;
this.productionData = productionTable;
this._buildTerminalMappings nonterminals;
    const parameters = "yytext, yyleng, yylineno, yy, yystate, $$, _$";
    parameters += ', ' + @parseParams.join(', ') if @parseParams
this.performAction = "function anonymous(#{parameters}) {\n#{actionsCode}\n}";
_parseHandle(handle) {
  if (Array.isArray handle) {
    const rhs = if typeof handle[0] is 'string' then handle[0].trim().split(' ') else handle[0][..];
rhs = rhs.map (e) -> e.replace(/\[[a-zA-Z_][a-zA-Z0-9_-]*\]/g, '')
    const action = if typeof handle[1] is 'string' or handle.length is 3 then handle[1] else null;
    const precedence = if handle[2] then handle[2] else if handle[1] and typeof handle[1] isnt 'string' then handle[1] else null;
    [rhs, action, precedence]
  } else {
    const handle = handle.replace /\[[a-zA-Z_][a-zA-Z0-9_-]*\]/g, '';
    const rhs = handle.trim().split ' ';
    [rhs, null, null]
_processSemanticAction(action, rhs) {
// Process named semantic values
  if (action.match(/[$@][a-zA-Z][a-zA-Z0-9_]*/)) {
    const count = {};
    const names = {};
  for token, i in rhs {
    const rhs_i = token.match(/\[[a-zA-Z][a-zA-Z0-9_-]*\]/) # Like [var];
  if (rhs_i) {
    const rhs_i = rhs_i[0].slice(1, -1);
  } else {
    const rhs_i = token;
  if (names[rhs_i]) {
    names[rhs_i + (++count[rhs_i])] = i + 1;
  } else {
    names[rhs_i] = i + 1;
    names[rhs_i + "1"] = i + 1;
    count[rhs_i] = 1;
    const action = action;
.replace /\$([a-zA-Z][a-zA-Z0-9_]*)/g, (str, pl) -> if names[pl] then '$' + names[pl] else str # Like $var
.replace  /@([a-zA-Z][a-zA-Z0-9_]*)/g, (str, pl) -> if names[pl] then '@' + names[pl] else str # Like @var
// Transform $$ and positional references
    action
    .replace(/([^'"])\$\$|^\$\$/g, '$1this.$') # Like $$var
    .replace(/@[0$]/g, "this._$") # Like @var
.replace(/\$(-?\d+)/g, (_, n) -> "$$[$0" + (parseInt(n, 10) - rhs.length || '') + "]") # Like $1
.replace( /@(-?\d+)/g, (_, n) -> "_$[$0" +               (n - rhs.length || '') + "]") # Like @1
_assignPrecedence(production, precedence, operators, nonterminals) {
  if (precedence?.prec and operators[precedence.prec]) {
    production.precedence = operators[precedence.prec].precedence;
    else if production.precedence is 0
// Use rightmost terminal's precedence
  for (const token of production.rhs by -1) {
  if (operators[token] and not nonterminals[token]) {
    production.precedence = operators[token].precedence;
    break
_generateActionCode(actionGroups) {
    const actions = [;
    '/* this == yyval */'
this.actionInclude or '';
    'var $0 = $$.length - 1;';
    'hasProp = {}.hasOwnProperty;';
    'switch (yystate) {'
    ]
    actions.push labels.join(' '), action, 'break;' for action, labels of actionGroups
    actions.push '}'
    actions.join('\n')
    .replace(/YYABORT/g, 'return false')
    .replace(/YYACCEPT/g, 'return true')
_buildTerminalMappings(nonterminals) {
this.terminalNames = {};
  for own name, id of @symbolIds when id >= 2 {
  if (!(nonterminals[name])) {
this.terminalNames[id] = name;
_augmentGrammar(grammar) {
    throw new Error "Grammar error: must have at least one production rule." if @productions.length is 0
this.start = grammar.start or this.productions[0].lhs;
  if (!(@nonterminals[@start])) {
    throw new Error "Grammar error: start symbol '#{@start}' must be a nonterminal defined in the grammar."
    const acceptProduction = new Production "$accept", [@start, "$end"], 0;
this.productions.push acceptProduction;
this.acceptProductionIndex = this.productions.length - 1;
this.nonterminals.$accept = this.symbolTable.get "$accept";
this.nonterminals.$accept.productions.push acceptProduction;
this.nonterminals[this.start].follows.add "$end";
// ============================================================================
// LR Automaton Construction
// ============================================================================
buildLRAutomaton() {
    const acceptItem = new Item @productions[@acceptProductionIndex];
    const firstState = this._closure new LRState(acceptItem);
    firstState.id = 0;
    firstState.signature = @_computeStateSignature(firstState);
    const states = [firstState];
stateMap = new Map # stateSignature -> state index
    stateMap.set firstState.signature, 0
// Build automaton by exploring all transitions
    const marked = 0;
  while (marked < states.length) {
    const itemSet = states[marked++];
    const symbols = new Set;
    for item from itemSet.items when sym = item.nextSymbol;
  if (sym isnt '$end') {
    symbols.add sym
  for symbol from symbols {
this._insertLRState symbol, itemSet, states, stateMap;
this.states = states;
// Calculate unique identifier for a state based on its items
_computeStateSignature(state) {
    const ids = [];
    ids.push item.id for item from state.items
ids.sort((a, b) -> a - b).join('|')
// Compute closure of an LR item set (lookaheads assigned later using FOLLOW sets)
_closure(itemSet) {
    const closureSet = new LRState;
    const workingSet = new Set itemSet.items;
itemCores  = new Map # item.id -> item
// Process all items
  while (workingSet.size > 0) {
    const newItems = new Set;
// Only process item cores we haven't yet seen
  for item from workingSet when !itemCores.has(item.id) {
// Add item to closure
    closureSet.items.add(item)
    itemCores.set(item.id, item)
// Check item type
    {nextSymbol} = item;
  if (not nextSymbol) {
// Reduction item
    closureSet.reductions.add(item)
    closureSet.hasConflicts = closureSet.reductions.size > 1 or closureSet.hasShifts;
    else if not @nonterminals[nextSymbol]
// Shift item (terminal)
    closureSet.hasShifts = true;
    closureSet.hasConflicts = closureSet.reductions.size > 0;
  } else {
// Nonterminal - add items for all its productions
    const nonterminal = this.nonterminals[nextSymbol];
  for (const production of nonterminal.productions) {
// Create [B → •γ] with empty lookaheads (will be filled by FOLLOW sets later)
    const newItem = new Item production;
    newItems.add(newItem) unless itemCores.has(newItem.id)
    const workingSet = newItems;
    closureSet
// Compute GOTO(state, symbol) - transitions from one state to another
_goto(itemSet, symbol) {
    const gotoSet = new LRState;
  for item from itemSet.items when item.nextSymbol is symbol {
// Create advanced item (lookaheads will be set from FOLLOW sets later)
    const newItem = new Item item.production, null, item.dot + 1;
    gotoSet.items.add newItem
  if (gotoSet.items.size is 0 then gotoSet else @_closure gotoSet) {
// Insert new state into automaton
_insertLRState(symbol, itemSet, states, stateMap) {
// Build kernel signature (advanced items) before computing closure
    const kernel = [];
  for item from itemSet.items when item.nextSymbol is symbol {
    kernel.push [item.production.id, item.dot + 1]
    return unless kernel.length;
kernel.sort (a, b) -> (a[0] - b[0]) or (a[1] - b[1])
    const kernelSig = (pid + '.' + pos for [pid, pos] in kernel).join '|';
    const existing = stateMap.get kernelSig;
  if (existing?) {
    itemSet.transitions.set symbol, existing
    return
// Kernel is new; compute closure now
    const gotoSet = this._goto itemSet, symbol;
    return unless gotoSet.items.size > 0;
    gotoSet.signature = kernelSig;
    gotoSet.id = states.length;
    stateMap.set kernelSig, gotoSet.id
    itemSet.transitions.set symbol, gotoSet.id
    states.push gotoSet
// ============================================================================
// Lookahead Computation - SLR(1) Algorithm
// ============================================================================
processLookaheads() {
@processLookaheads = ->  # Computes once; no-op on subsequent calls
this._computeNullableSets()  # ε-derivable symbols;
this._computeFirstSets()     # First terminals;
this._computeFollowSets()    # Following terminals;
this._assignItemLookaheads() # FOLLOW(A) → item lookaheads;
// Determine nullable symbols (can derive ε)
_computeNullableSets() {
    const changed = true;
  while (changed) {
    const changed = false;
// Mark productions nullable if all handle symbols are nullable
  for (const production of @productions when not production.nullable) {
  if (production.rhs.every (symbol) => @_isNullable symbol) {
    production.nullable = changed = true;
// Propagate to nonterminals
  for symbol, nonterminal of @nonterminals when not @_isNullable symbol {
if nonterminal.productions.some (p) -> p.nullable
    nonterminal.nullable = changed = true;
_isNullable(symbol) {
    return true if symbol is '';
    return symbol.every((s) => @_isNullable s) if Array.isArray symbol;
this.nonterminals[symbol]?.nullable or false;
// Compute FIRST sets (terminals that can begin derivations)
_computeFirstSets() {
    const changed = true;
  while (changed) {
    const changed = false;
  for (const production of @productions) {
    const firsts = this._computeFirst production.rhs;
    const oldSize = production.first.size;
    production.first.clear()
    firsts.forEach (item) => production.first.add item
    const changed = true if production.first.size > oldSize;
  for symbol, nonterminal of @nonterminals {
    const oldSize = nonterminal.first.size;
    nonterminal.first.clear()
  for (const production of nonterminal.productions) {
    production.first.forEach (s) => nonterminal.first.add s
    const changed = true if nonterminal.first.size > oldSize;
_computeFirst(symbols) {
    return new Set if symbols is '';
    return @_computeFirstOfSequence symbols if Array.isArray symbols;
    return new Set([symbols]) unless @nonterminals[symbols];
this.nonterminals[symbols].first;
_computeFirstOfSequence(symbols) {
    const firsts = new Set;
  for (const symbol of symbols) {
  if (@nonterminals[symbol]) {
this.nonterminals[symbol].first.forEach (s) => firsts.add s;
  } else {
    firsts.add symbol
    break unless @_isNullable symbol
    firsts
// Compute FOLLOW sets (terminals that can follow nonterminals)
_computeFollowSets() {
    const changed = true;
  while (changed) {
    const changed = false;
  for (const production of @productions) {
  for symbol, i in production.rhs when @nonterminals[symbol] {
    const oldSize = this.nonterminals[symbol].follows.size;
  if (i is production.rhs.length - 1) {
// Symbol at end: add FOLLOW(LHS)
this.nonterminals[production.lhs].follows.forEach (item) =>;
this.nonterminals[symbol].follows.add item;
  } else {
// Add FIRST(β) where β follows symbol
    const beta = production.rhs[i + 1..];
    const firstSet = this._computeFirst beta;
    firstSet.forEach (item) => @nonterminals[symbol].follows.add item
// If β is nullable, also add FOLLOW(LHS)
  if (@_isNullable beta) {
this.nonterminals[production.lhs].follows.forEach (item) =>;
this.nonterminals[symbol].follows.add item;
    const changed = true if this.nonterminals[symbol].follows.size > oldSize;
// Assign FOLLOW sets to reduction items
_assignItemLookaheads() {
  for (const state of @states) {
  for item from state.reductions {
    const follows = this.nonterminals[item.production.lhs]?.follows;
  if (follows) {
    item.lookaheads.clear()
    item.lookaheads.add terminal for terminal from follows
// ============================================================================
// Parse Table Generation
// ============================================================================
buildParseTable(itemSets = @states) {
    const states = [];
    {nonterminals, operators} = this;
    [NONASSOC, SHIFT, REDUCE, ACCEPT] = [0, 1, 2, 3];
  for itemSet, k in itemSets {
    const state = states[k] = {};
// Shift and goto actions
  for [stackSymbol, gotoState] from itemSet.transitions when @symbolIds[stackSymbol]? {
  for item from itemSet.items when item.nextSymbol is stackSymbol {
  if (nonterminals[stackSymbol]) {
    state[@symbolIds[stackSymbol]] = gotoState;
  } else {
    state[@symbolIds[stackSymbol]] = [SHIFT, gotoState];
// Accept action
  for item from itemSet.items when item.nextSymbol is "$end" and @symbolIds["$end"]? {
    state[@symbolIds["$end"]] = [ACCEPT];
// Reduce actions
  for item from itemSet.reductions {
  for stackSymbol from item.lookaheads when @symbolIds[stackSymbol]? {
    const action = state[this.symbolIds[stackSymbol]];
    const op = operators[stackSymbol];
  if (action) {
// Resolve conflict
    const which = if action[0] instanceof Array then action[0] else action;
    const solution = this._resolveConflict item.production, op, [REDUCE, item.production.id], which;
  if (solution.bydefault) {
this.conflicts++;
  } else {
    const action = solution.action;
  } else {
    const action = [REDUCE, item.production.id];
  if (action?.length) {
    state[@symbolIds[stackSymbol]] = action;
    else if action is NONASSOC
    state[@symbolIds[stackSymbol]] = undefined;
this._computeDefaultActions this.parseTable = states;
// Resolve conflicts using precedence and associativity
_resolveConflict(production, op, reduce, shift) {
    const solution = {production, operator: op, r: reduce, s: shift};
    [NONASSOC, SHIFT, REDUCE] = [0, 1, 2];
  if (shift[0] is REDUCE) {
    solution.action = if shift[1] < reduce[1] then shift else reduce;
    solution.bydefault = true if shift[1] isnt reduce[1];
    return solution;
  if (production.precedence is 0 or not op) {
    solution.bydefault = true;
    solution.action = shift;
    else if production.precedence < op.precedence
    solution.action = shift;
    else if production.precedence is op.precedence
    solution.action = switch op.assoc;
    case "right": shift; break;
    case "left": reduce; break;
    case "nonassoc": NONASSOC; break;
    else shift
  } else {
    solution.action = reduce;
    solution
// Compute default actions for single-action states
_computeDefaultActions(states) {
    const defaults = {};
  for state, k in states {
    const actionCount = 0;
    const lastAction = null;
  for own action of state {
    actionCount++
    const lastAction = state[action];
    defaults[k] = lastAction if actionCount is 1 and lastAction[0] is 2;
this.defaultActions = defaults;
// ============================================================================
// Code Generation
// ============================================================================
generate(options = {}) {
this.options = { ...this.options, ...options };
    const parserCode = this.generateCommonJSModule this.options;
  if (@options.compress) {
this._compressParser parserCode;
  } else {
    parserCode
generateCommonJSModule(options = {}) {
    const moduleName = options.moduleName or "parser";
    const moduleName = "parser" unless moduleName.match /^[A-Za-z_$][A-Za-z0-9_$]*$/;
this.generateModule(options) + """;
    \n
  if ((typeof require !== 'undefined' && typeof exports !== 'undefined') {) {
    exports.parser = #{moduleName};;
    exports.Parser = #{moduleName}.Parser;;
    exports.parse = function () { return #{moduleName}.parse.apply(#{moduleName}, arguments); };;
    exports.main = function() {};;
  if ((typeof module !== 'undefined' && require.main === module) { exports.main(process.argv.slice(1)); }) {
    }
    """
generateModule(options = {}) {
    const moduleName = options.moduleName or "parser";
    const version = '2.0.0';
    const out = "/* parser generated by solar #{version} */\n";
    out += if moduleName.match /\./ then moduleName else "var #{moduleName}"
    out += " = #{@generateModuleExpr()}";
generateModuleExpr() {
    const module = this._generateModuleCore();
    """
    (function(){
    var hasProp = {}.hasOwnProperty;;
//{module.commonCode}
    var parser = #{module.moduleCode};;
//{@moduleInclude}
    function Parser () { this.yy = {}; };
    Parser.prototype = parser;;
    parser.Parser = Parser;;
    return new Parser;;
    })();
    """
_generateModuleCore() {
    const tableCode = this._generateTableCode this.parseTable;
    const moduleCode = """{;
    trace: function trace() {},
    yy: {},
    symbolIds: #{JSON.stringify @symbolIds},
    terminalNames: #{JSON.stringify(@terminalNames).replace /"([0-9]+)":/g, "$1:"},
    productionData: #{JSON.stringify @productionData},
    parseTable: #{tableCode.moduleCode},
    defaultActions: #{JSON.stringify(@defaultActions).replace /"([0-9]+)":/g, "$1:"},
    performAction: #{@performAction},
    parseError: function #{@parseError},
    parse: function #{@parse}
    }"""
    {commonCode: tableCode.commonCode, moduleCode}
_generateTableCode(stateTable) {
    const moduleCode = JSON.stringify(stateTable, null, 0).replace /"([0-9]+)"(?=:)/g, "$1";
    {commonCode: '', moduleCode}
_compressParser(parserCode) {
// Compress the entire parser with Brotli
    const compressedData = this._brotliCompress parserCode;
    """
    /* Brotli-compressed parser generated by solar #{@version or '0.6.0'} */
    (function() {
    // Brotli decompression (requires Node.js with Brotli support)
    function loadBrotliDecoder() {
  if ((typeof require !== 'undefined') {) {
    try {
    // Try built-in Node.js zlib brotli first (Node 12+)
    const zlib = require('zlib');;
  if ((zlib.brotliDecompressSync) {) {
    return function(buffer) {;
    return zlib.brotliDecompressSync(buffer);;
    };
    }
    } catch (e) {}
    try {
    // Fallback to brotli package
    const brotli = require('brotli');;
    return function(buffer) {;
    return Buffer.from(brotli.decompress(new Uint8Array(buffer)));;
    };
    } catch (e) {
    throw new Error('Brotli decompression not available. This parser requires Brotli support. Please install the brotli package or use Node.js 12+.');
    }
    }
    throw new Error('This compressed parser requires Node.js environment with Brotli support.');
    }
    // Decompress and evaluate the parser
    const brotliDecode = loadBrotliDecoder();;
    const compressedBuffer = Buffer.from('#{compressedData}', 'base64');;
    const decompressedBuffer = brotliDecode(compressedBuffer);;
    const parserCode = decompressedBuffer.toString('utf8');;
    // Evaluate the decompressed parser code
    return eval(parserCode);;
    })();
    """
_brotliCompress(data) {
  try {
  if (typeof require isnt 'undefined') {
// Try Node.js built-in zlib brotli first
    const zlib = require 'zlib';
  if (zlib.brotliCompressSync) {
    const compressed = zlib.brotliCompressSync Buffer.from(data);
    return compressed.toString 'base64';
// Fallback to brotli package
    const brotli = require 'brotli';
    const compressed = brotli.compress Buffer.from(data);
    return Buffer.from(compressed).toString 'base64';
  } else {
    throw new Error 'Brotli compression requires Node.js environment'
  } catch (error) {
    throw new Error "Brotli compression failed: #{error.message}. Please ensure Brotli is available (Node.js 12+ or install 'brotli' package)."
// ============================================================================
// Runtime Parser
// ============================================================================
parseError(str, hash) {
  if (hash.recoverable) {
this.trace str;
  } else {
    const error = new Error str;
    error.hash = hash;
    throw error
parse(input) {
    [stk, val, loc] = [[0], [null], []];
    [parseTable, yytext, yylineno, yyleng, recovering] = [@parseTable, '', 0, 0, 0];
    [TERROR, EOF] = [2, 1];
    const lexer = Object.create this.lexer;
    const sharedState = {yy: {}};
    sharedState.yy[k] = v for own k, v of @yy;
    lexer.setInput input, sharedState.yy
    [sharedState.yy.lexer, sharedState.yy.parser] = [lexer, this];
    lexer.yylloc = {} unless lexer.yylloc?;
    const yyloc = lexer.yylloc;
    loc.push yyloc
    const ranges = lexer.options?.ranges;
this.parseError = if typeof sharedState.yy.parseError is 'function';
    sharedState.yy.parseError
  } else {
    Object.getPrototypeOf(this).parseError
    const lex = =>;
    const token = lexer.lex() or EOF;
    const token = this.symbolIds[token] or token unless typeof token is 'number';
    token
    [symbol, preErrorSymbol, state, action, r, yyval, p, len, newState, expected] =
    [null, null, null, null, null, {}, null, null, null, null]
    loop
    const state = stk[stk.length - 1];
    const action = this.defaultActions[state] or (;
    const symbol = lex() if not symbol?;
    parseTable[state]?[symbol]
    )
  if (!(action?.length and action[0])) {
    const errStr = '';
  if (!(recovering)) {
    const expected = ("'#{this.terminalNames[p]}'" for own p of parseTable[state] when this.terminalNames[p] and p > TERROR);
    const errStr = if lexer.showPosition;
    "Parse error on line #{yylineno + 1}:\n#{lexer.showPosition()}\nExpecting #{expected.join(', ')}, got '#{@terminalNames[symbol] or symbol}'"
  } else {
    "Parse error on line #{yylineno + 1}: Unexpected #{if symbol is EOF then "end of input" else "'#{@terminalNames[symbol] or symbol}'"}"
this.parseError errStr, {;
    text: lexer.match
    token: @terminalNames[symbol] or symbol
    line: lexer.yylineno
    loc: yyloc
    expected
    }
    throw new Error errStr
    throw new Error "Parse Error: multiple actions possible at state: #{state}, token: #{symbol}" if action[0] instanceof Array and action.length > 1
  switch (action[0]) {
    case 1 # shift:
    stk.push symbol, action[1]
    val.push lexer.yytext
    loc.push lexer.yylloc
    const symbol = null;
  if (!(preErrorSymbol)) {
    [yyleng, yytext, yylineno, yyloc] = [lexer.yyleng, lexer.yytext, lexer.yylineno, lexer.yylloc];
    recovering-- if recovering > 0
  } else {
    [symbol, preErrorSymbol] = [preErrorSymbol, null];
    case 2 # reduce:
    const len = this.productionData[action[1]][1];
    yyval.$ = val[val.length - len];
    [locFirst, locLast] = [loc[loc.length - (len or 1)], loc[loc.length - 1]];
    yyval._$ = {;
    first_line: locFirst.first_line, last_line: locLast.last_line
    first_column: locFirst.first_column, last_column: locLast.last_column
    }
    yyval._$.range = [locFirst.range[0], locLast.range[1]] if ranges;
    const r = this.performAction.apply yyval, [yytext, yyleng, yylineno, sharedState.yy, action[1], val, loc];
    return r if r?;
  if (len) {
    stk.length -= len * 2
    val.length -= len
    loc.length -= len
    stk.push @productionData[action[1]][0]
    val.push yyval.$
    loc.push yyval._$
    const newState = parseTable[stk[stk.length - 2]][stk[stk.length - 1]];
    stk.push newState
    case 3 # accept:
    return true;
trace(msg) { return # Debug output (no-op by default); }
    console.log msg if @options?.debug
createParser() {
    const parser = eval this.generateModuleExpr();
    parser.productions = @productions;
    const bindMethod = (method) => => this.lexer = parser.lexer; @[method].apply this, arguments;
    parser.lexer = @lexer;
    parser.generate = bindMethod 'generate';
    parser.generateModule = bindMethod 'generateModule';
    parser.generateCommonJSModule = bindMethod 'generateCommonJSModule';
    parser
// ==============================================================================
// Exports
// ==============================================================================
    const Solar = exports.Solar = exports;
Solar.Parser = (grammar, options) ->
    const generator = new Generator grammar, options;
    generator.createParser()
    exports.Generator = Generator;
Solar.Generator = (g, options) ->
    new Generator g, Object.assign({}, g.options, options)
exports.Parser = (grammar, options) ->
    const generator = Solar.Generator grammar, options;
    generator.createParser()
// ==============================================================================
// CLI Interface
// ==============================================================================
  if (require.main is module) {
    const fs = require 'fs';
    const path = require 'path';
const showHelp = () => {
    console.log """
    Solar - SLR(1) Parser Generator
    ===============================
    Usage: coffee solar.coffee [options] [grammar-file]
    Options:
    -h, --help              Show this help
    -s, --stats             Show grammar statistics
    -g, --generate          Generate parser (default)
    -o, --output <file>     Output file (default: parser.js)
    -c, --compress          Compress parser with Brotli (requires Brotli support)
    -v, --verbose           Verbose output
    Examples:
    coffee solar.coffee grammar.coffee
    coffee solar.coffee --stats grammar.coffee
    coffee solar.coffee -c -o parser.js grammar.coffee
    coffee solar.coffee --compress --output parser.js grammar.coffee
    """
const showStats = (generator) => {
    const terminals = Object.keys(generator.terminalNames or {}).length;
    const nonterminals = Object.keys(generator.nonterminals or {}).length;
    const productions = generator.productions?.length or 0;
    const states = generator.states?.length or 0;
    const conflicts = generator.conflicts or 0;
    console.log """
    ⏱️ Statistics:
    • Terminals: #{terminals}
    • Nonterminals: #{nonterminals}
    • Productions: #{productions}
    • States: #{states}
    • Conflicts: #{conflicts}
    """
// Parse command line
    const options = {help: false, stats: false, generate: false, output: 'parser.js', verbose: false, compress: false};
    const grammarFile = null;
    const i = 0;
  while (i < process.argv.length - 2) {
    const arg = process.argv[i + 2];
  switch (arg) {
    when '-h', '--help'     then options.help     = true;
    when '-s', '--stats'    then options.stats    = true;
    when '-g', '--generate' then options.generate = true;
    when '-o', '--output'   then options.output   = process.argv[++i + 2];
    when '-v', '--verbose'  then options.verbose  = true;
    when '-c', '--compress' then options.compress = true;
    else grammarFile = arg unless arg.startsWith('-');
    i++
  if (options.help or not grammarFile) {
    showHelp()
    process.exit 0
  try {
  if (!(fs.existsSync grammarFile)) {
    console.error "Grammar file not found: #{grammarFile}"
    process.exit 1
// Load grammar
    const grammar = if grammarFile.endsWith('.coffee');
    require(path.resolve(grammarFile))
    else if grammarFile.endsWith('.json')
    JSON.parse fs.readFileSync(grammarFile, 'utf8')
  } else {
    throw new Error "Unsupported format. Use .coffee or .json"
  if (!(grammar)) {
    throw new Error "Failed to load grammar"
// Generate parser
    const generator = new Generator grammar, options;
  if (options.stats) {
    showStats generator
  if (options.generate or not options.stats) {
    const parserCode = generator.generate();
    fs.writeFileSync options.output, parserCode
    console.log "\nParser generated: #{options.output}"
  } catch (error) {
    console.error "Error:", error.message
    console.error error.stack if options.verbose
    process.exit 1