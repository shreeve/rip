// Generated by CoffeeScript 2.7.0 - Fixed for ES6
//!/usr/bin/env coffee

// ==============================================================================
// Solar - SLR(1) Parser Generator for CoffeeScript
//
// Clean implementation influenced by Jison, but rewritten in CoffeeScript for
// readability, efficiency, and maintainability.
//
// Author: Steve Shreeve <steve.shreeve@gmail.com>
//   Date: Aug 1, 2025
// ==============================================================================

// Terminal symbols (tokens, cannot be expanded)
var Generator, Item, LRState, Nonterminal, Production, Solar, Terminal;
var hasProp = {}.hasOwnProperty;

Terminal = class Terminal {
  constructor(name, id) {
    this.id = id;
    this.name = name;
    this.first = new Set(); // For consistency with algorithm
  }
};

// Nonterminal symbols (can be expanded by productions)
Nonterminal = class Nonterminal {
  constructor(name, id) {
    this.id = id;
    this.name = name;
    this.productions = []; // productions where this symbol is the LHS
    this.nullable = false; // true if symbol can derive empty string
    this.first = new Set(); // terminals that can appear first
    this.follows = new Set(); // terminals that can follow this symbol
  }
};

// Production rule (Expression â†’ Expression + Term)
Production = class Production {
  constructor(lhs, rhs, id) {
    this.lhs = lhs; // left-hand side (nonterminal)
    this.rhs = rhs; // right-hand side (array of symbols)
    this.id = id; // unique production number
    this.nullable = false; // true if RHS can derive empty string
    this.first = new Set(); // terminals that can appear first in RHS
    this.precedence = 0; // operator precedence for conflict resolution
  }
};

// LR item (Expression â†’ Expression â€¢ + Term)
Item = class Item {
  constructor(production, lookaheads, dot = 0) {
    this.production = production; // the production rule
    this.dot = dot; // position of parse progress
    this.lookaheads = new Set(lookaheads || []); // defensive copy, handle null/undefined
    this.nextSymbol = this.production.rhs[this.dot]; // symbol after dot (if any)
    this.id = this.production.id * 100 + this.dot; // compact unique ID
  }
};

// LR state (set of items with transitions)
LRState = class LRState {
  constructor(...items) {
    var i, item, j, len1, len2, ref;
    this.items = [];
    this.goto = {}; // transitions on symbols
    this.id = -1; // assigned later
    this._key = ''; // signature for state comparison
    ref = items;
    for (i = 0, len1 = ref.length; i < len1; i++) {
      item = ref[i];
      if (item instanceof Item) {
        this.items.push(item);
      } else if (item instanceof Array) {
        for (j = 0, len2 = item.length; j < len2; j++) {
          const subItem = item[j];
          if (subItem instanceof Item) {
            this.items.push(subItem);
          }
        }
      }
    }
  }

  // Add items to the state
  addItems(...items) {
    var i, item, len1, results;
    results = [];
    for (i = 0, len1 = items.length; i < len1; i++) {
      item = items[i];
      results.push(this.items.push(item));
    }
    return results;
  }

  // Generate unique state signature
  key() {
    var i, id, item, len1, ref;
    if (this._key) {
      return this._key;
    }
    ref = this.items;
    for (i = 0, len1 = ref.length; i < len1; i++) {
      item = ref[i];
      id = `${item.production.id}:${item.dot}`;
      this._key += `${id},`;
    }
    return this._key;
  }

  // Compute closure of this state's items
  closure(grammar) {
    var added, i, item, j, len1, len2, lookaheadSymbol, newItem, nextItem, prod, ref, ref1, ref2;
    added = true;
    while (added) {
      added = false;
      ref = this.items;
      for (i = 0, len1 = ref.length; i < len1; i++) {
        item = ref[i];
        nextItem = item.nextSymbol;
        if (!nextItem || nextItem instanceof Terminal) {
          continue;
        }
        ref1 = nextItem.productions;
        for (j = 0, len2 = ref1.length; j < len2; j++) {
          prod = ref1[j];
          newItem = new Item(prod, null, 0);
          if (!this.hasItem(newItem)) {
            this.items.push(newItem);
            added = true;
          }
        }
      }
    }
    return this;
  }

  // Check if state contains an item (by ID)
  hasItem(item) {
    var existingItem, i, len1, ref;
    ref = this.items;
    for (i = 0, len1 = ref.length; i < len1; i++) {
      existingItem = ref[i];
      if (existingItem.id === item.id) {
        return true;
      }
    }
    return false;
  }
};

// ==============================================================================
// Parser Generator
// ==============================================================================
Generator = class Generator {
  constructor(grammar, options = {}) {
    this.grammar = grammar;
    this.options = options;
    // Symbol management
    this.terminals = {};
    this.terminalNames = {};
    this.nonterminals = {};
    this.productions = [];
    // Parser state
    this.states = [];
    this.stateMap = {}; // signature -> state mapping
    this.table = [];
    this.defaultActions = [];
    this.conflicts = 0;
    // Debug/trace
    this.DEBUG = options.debug || false;
    // Build parser
    this.timing('ðŸ’¥ Total time', () => {
      this.timing('processGrammar', () => this.processGrammar(grammar)); // Process grammar rules
      this.timing('buildLRAutomaton', () => this.buildLRAutomaton()); // Build LR(0) automaton
      this.timing('processLookaheads', () => this.processLookaheads()); // Compute FIRST/FOLLOW and assign lookaheads
      return this.timing('buildParseTable', () => this.buildParseTable()); // Build parse table with default actions
    });
  }

  // ============================================================================
  // Helper Functions
  // ============================================================================
  timing(label, fn) {
    var result;
    console.time(label);
    if (fn) {
      result = fn();
    }
    console.timeEnd(label);
    return result;
  }

  // ============================================================================
  // Grammar Processing
  // ============================================================================
  processGrammar(grammar) {
    var action, associativity, i, j, k, l, len1, len2, len3, len4, nonterminal, operator, production, ref, ref1, ref2, ref3, ref4, results, rhs, rule, rules, symbol, terminal, token, value;
    // Register terminals
    if (grammar.terminals) {
      ref = grammar.terminals;
      for (i = 0, len1 = ref.length; i < len1; i++) {
        terminal = ref[i];
        if (!this.terminals[terminal]) {
          this.terminals[terminal] = new Terminal(terminal, Object.keys(this.terminals).length);
          this.terminalNames[terminal] = terminal;
        }
      }
    }
    // Process operator precedence
    if (grammar.operators) {
      ref1 = grammar.operators;
      for (j = 0, len2 = ref1.length; j < len2; j++) {
        const opDecl = ref1[j];
        const associativity = opDecl[0];
        const operators = opDecl.slice(1);
        for (k = 0, len3 = operators.length; k < len3; k++) {
          operator = operators[k];
          if (!this.terminals[operator]) {
            this.terminals[operator] = new Terminal(operator, Object.keys(this.terminals).length);
          }
          this.terminals[operator].precedence = j + 1;
          this.terminals[operator].associativity = associativity;
        }
      }
    }
    // Process grammar rules
    ref2 = grammar.bnf || grammar.rules;
    results = [];
    for (nonterminal in ref2) {
      if (!hasProp.call(ref2, nonterminal)) continue;
      rules = ref2[nonterminal];
      if (!this.nonterminals[nonterminal]) {
        this.nonterminals[nonterminal] = new Nonterminal(nonterminal, Object.keys(this.nonterminals).length);
      }
      results.push((function() {
        var l, len4, results1;
        results1 = [];
        for (l = 0, len4 = rules.length; l < len4; l++) {
          rule = rules[l];
          // Parse rule definition
          if (typeof rule === 'string') {
            rhs = rule.split(' ').filter((s) => {
              return s.length > 0;
            });
            action = null;
          } else if (rule instanceof Array) {
            rhs = rule[0].split(' ').filter((s) => {
              return s.length > 0;
            });
            action = rule[1];
          } else {
            throw new Error(`Invalid rule format: ${rule}`);
          }
          // Register symbols in RHS
          for (var m = 0, len5 = rhs.length; m < len5; m++) {
            symbol = rhs[m];
            if (!this.terminals[symbol] && !this.nonterminals[symbol]) {
              // Check if it's a token reference
              if (grammar.tokens && grammar.tokens[symbol]) {
                value = grammar.tokens[symbol];
                token = typeof value === 'string' ? value : symbol;
                if (!this.terminals[token]) {
                  this.terminals[token] = new Terminal(token, Object.keys(this.terminals).length);
                  this.terminalNames[symbol] = token;
                }
              } else {
                // It's a nonterminal
                this.nonterminals[symbol] = new Nonterminal(symbol, Object.keys(this.nonterminals).length);
              }
            }
          }
          // Convert RHS symbols to objects
          rhs = rhs.map((symbol) => {
            return this.terminals[symbol] || this.nonterminals[symbol] || this.terminals[this.terminalNames[symbol]];
          });
          // Create production
          production = new Production(this.nonterminals[nonterminal], rhs, this.productions.length);
          production.action = action;
          // Inherit precedence from rightmost terminal
          for (var n = rhs.length - 1; n >= 0; n--) {
            symbol = rhs[n];
            if (symbol instanceof Terminal && symbol.precedence) {
              production.precedence = symbol.precedence;
              production.associativity = symbol.associativity;
              break;
            }
          }
          this.productions.push(production);
          results1.push(this.nonterminals[nonterminal].productions.push(production));
        }
        return results1;
      }).call(this));
    }
    return results;
  }

  // ============================================================================
  // LR Automaton Construction
  // ============================================================================
  buildLRAutomaton() {
    var gotoState, i, initialItem, initialState, item, items, j, len1, len2, nextSymbol, newItems, newState, newStateKey, ref, results, state, symbol, symbolName;
    // Create initial state with augmented start production
    initialItem = new Item(this.productions[0], null, 0);
    initialState = new LRState(initialItem);
    initialState.closure(this);
    initialState.id = 0;
    this.states.push(initialState);
    this.stateMap[initialState.key()] = initialState;
    // Build states and transitions
    i = 0;
    while (i < this.states.length) {
      state = this.states[i];
      // Group items by next symbol
      newItems = {};
      ref = state.items;
      for (j = 0, len1 = ref.length; j < len1; j++) {
        item = ref[j];
        nextSymbol = item.nextSymbol;
        if (nextSymbol) {
          symbolName = nextSymbol.name;
          if (!newItems[symbolName]) {
            newItems[symbolName] = [];
          }
          newItems[symbolName].push(new Item(item.production, item.lookaheads, item.dot + 1));
        }
      }
      // Create new states for each symbol
      results = [];
      for (symbol in newItems) {
        if (!hasProp.call(newItems, symbol)) continue;
        items = newItems[symbol];
        newState = new LRState(items);
        newState.closure(this);
        newStateKey = newState.key();
        // Check if state already exists
        if (this.stateMap[newStateKey]) {
          gotoState = this.stateMap[newStateKey];
        } else {
          newState.id = this.states.length;
          this.states.push(newState);
          this.stateMap[newStateKey] = newState;
          gotoState = newState;
        }
        // Record transition
        results.push(state.goto[symbol] = gotoState);
      }
      i++;
    }
    return null;
  }

  // ============================================================================
  // FIRST/FOLLOW Computation
  // ============================================================================
  computeFirst() {
    var changed, i, j, k, len1, len2, len3, nonterminal, production, ref, ref1, ref2, symbol, terminal, terminalObj;
    // Initialize FIRST sets
    for (terminal in this.terminals) {
      if (!hasProp.call(this.terminals, terminal)) continue;
      terminalObj = this.terminals[terminal];
      terminalObj.first.add(terminalObj);
    }
    // Compute FIRST sets for productions and nonterminals
    changed = true;
    while (changed) {
      changed = false;
      ref = this.productions;
      for (i = 0, len1 = ref.length; i < len1; i++) {
        production = ref[i];
        ref1 = production.rhs;
        for (j = 0, len2 = ref1.length; j < len2; j++) {
          symbol = ref1[j];
          if (symbol instanceof Terminal) {
            if (!production.first.has(symbol)) {
              production.first.add(symbol);
              changed = true;
            }
            break;
          } else {
            // Add FIRST(symbol) to FIRST(production)
            symbol.first.forEach((terminal) => {
              if (!production.first.has(terminal)) {
                production.first.add(terminal);
                changed = true;
              }
            });
            if (!symbol.nullable) {
              break;
            }
          }
        }
        // If we made it through all symbols, production is nullable
        if (j === production.rhs.length) {
          production.nullable = true;
        }
        // Add FIRST(production) to FIRST(lhs)
        production.first.forEach((terminal) => {
          if (!production.lhs.first.has(terminal)) {
            production.lhs.first.add(terminal);
            changed = true;
          }
        });
        // Check if LHS is nullable
        if (production.nullable && !production.lhs.nullable) {
          production.lhs.nullable = true;
          changed = true;
        }
      }
    }
    return null;
  }

  computeFollow() {
    var changed, i, j, k, len1, len2, nextSymbol, production, ref, ref1, symbol;
    // Initialize FOLLOW sets
    // Add EOF to FOLLOW(start)
    if (this.productions[0]) {
      this.productions[0].lhs.follows.add('$EOF');
    }
    // Compute FOLLOW sets
    changed = true;
    while (changed) {
      changed = false;
      ref = this.productions;
      for (i = 0, len1 = ref.length; i < len1; i++) {
        production = ref[i];
        ref1 = production.rhs;
        for (j = 0, len2 = ref1.length; j < len2; j++) {
          symbol = ref1[j];
          if (symbol instanceof Nonterminal) {
            // Add FIRST of remaining symbols
            for (k = j + 1; k < production.rhs.length; k++) {
              nextSymbol = production.rhs[k];
              if (nextSymbol instanceof Terminal) {
                if (!symbol.follows.has(nextSymbol)) {
                  symbol.follows.add(nextSymbol);
                  changed = true;
                }
                break;
              } else {
                nextSymbol.first.forEach((terminal) => {
                  if (!symbol.follows.has(terminal)) {
                    symbol.follows.add(terminal);
                    changed = true;
                  }
                });
                if (!nextSymbol.nullable) {
                  break;
                }
              }
            }
            // If we made it to the end, add FOLLOW(lhs)
            if (k === production.rhs.length) {
              production.lhs.follows.forEach((terminal) => {
                if (!symbol.follows.has(terminal)) {
                  symbol.follows.add(terminal);
                  changed = true;
                }
              });
            }
          }
        }
      }
    }
    return null;
  }

  processLookaheads() {
    var i, item, j, k, len1, len2, len3, production, ref, ref1, ref2, state;
    // Compute FIRST and FOLLOW sets
    this.computeFirst();
    this.computeFollow();
    // Assign lookaheads to items
    ref = this.states;
    for (i = 0, len1 = ref.length; i < len1; i++) {
      state = ref[i];
      ref1 = state.items;
      for (j = 0, len2 = ref1.length; j < len2; j++) {
        item = ref1[j];
        production = item.production;
        // For completed items, use FOLLOW(lhs)
        if (item.dot === production.rhs.length) {
          production.lhs.follows.forEach((terminal) => {
            if (typeof terminal === 'string') {
              item.lookaheads.add(terminal);
            } else {
              item.lookaheads.add(terminal.name);
            }
          });
        }
      }
    }
    return null;
  }

  // ============================================================================
  // Parse Table Construction
  // ============================================================================
  buildParseTable() {
    var action, actions, count, defaultAction, gotoState, i, item, j, k, len1, len2, len3, lookahead, maxCount, production, productionId, ref, ref1, ref2, ref3, state, symbol, terminalId;
    // Initialize parse table
    ref = this.states;
    for (i = 0, len1 = ref.length; i < len1; i++) {
      state = ref[i];
      this.table[state.id] = {};
      this.defaultActions[state.id] = null;
      // Shift actions
      ref1 = Object.keys(state.goto);
      for (j = 0, len2 = ref1.length; j < len2; j++) {
        symbol = ref1[j];
        gotoState = state.goto[symbol];
        if (this.terminals[symbol]) {
          // Shift action for terminal
          terminalId = this.terminals[symbol].id;
          if (!this.table[state.id][terminalId]) {
            this.table[state.id][terminalId] = [1, gotoState.id]; // [SHIFT, state]
          } else {
            // Shift-reduce conflict
            this.handleConflict(state, symbol, [1, gotoState.id], this.table[state.id][terminalId]);
          }
        } else if (this.nonterminals[symbol]) {
          // Goto action for nonterminal
          this.table[state.id][this.nonterminals[symbol].id] = gotoState.id;
        }
      }
      // Reduce actions
      ref2 = state.items;
      for (k = 0, len3 = ref2.length; k < len3; k++) {
        item = ref2[k];
        production = item.production;
        // Check if item is complete
        if (item.dot === production.rhs.length) {
          // Accept action for augmented start
          if (production.id === 0) {
            if (!this.table[state.id]['$EOF']) {
              this.table[state.id]['$EOF'] = [3]; // [ACCEPT]
            }
          } else {
            // Reduce action for lookaheads
            item.lookaheads.forEach((lookahead) => {
              terminalId = lookahead === '$EOF' ? '$EOF' : ((ref3 = this.terminals[lookahead]) != null ? ref3.id : void 0);
              if (terminalId != null) {
                action = [2, production.id]; // [REDUCE, production]
                if (!this.table[state.id][terminalId]) {
                  this.table[state.id][terminalId] = action;
                } else {
                  // Reduce-reduce or shift-reduce conflict
                  this.handleConflict(state, lookahead, action, this.table[state.id][terminalId]);
                }
              }
            });
          }
        }
      }
      // Set default action (most common reduce)
      actions = {};
      for (terminalId in this.table[state.id]) {
        action = this.table[state.id][terminalId];
        if (action[0] === 2) { // REDUCE
          if (!actions[action[1]]) {
            actions[action[1]] = 0;
          }
          actions[action[1]]++;
        }
      }
      defaultAction = null;
      maxCount = 0;
      for (productionId in actions) {
        count = actions[productionId];
        if (count > maxCount) {
          maxCount = count;
          defaultAction = [2, parseInt(productionId)];
        }
      }
      if (defaultAction) {
        this.defaultActions[state.id] = defaultAction;
        // Remove default action from table
        for (terminalId in this.table[state.id]) {
          action = this.table[state.id][terminalId];
          if (action[0] === defaultAction[0] && action[1] === defaultAction[1]) {
            delete this.table[state.id][terminalId];
          }
        }
      }
    }
    return null;
  }

  handleConflict(state, symbol, newAction, existingAction) {
    var existingPrecedence, existingProduction, newPrecedence, newProduction, ref, ref1, terminal;
    // Both are reduce actions (reduce-reduce conflict)
    if (newAction[0] === 2 && existingAction[0] === 2) {
      console.warn(`Reduce-reduce conflict at state ${state.id} on ${symbol}`);
      this.conflicts++;
      return;
    }
    // Shift-reduce conflict
    terminal = this.terminals[symbol] || this.terminals[this.terminalNames[symbol]];
    if (!terminal || !terminal.precedence) {
      console.warn(`Shift-reduce conflict at state ${state.id} on ${symbol} (no precedence)`);
      this.conflicts++;
      return;
    }
    // Get precedence of reduce action
    if (newAction[0] === 2) {
      newProduction = this.productions[newAction[1]];
      newPrecedence = newProduction.precedence;
    } else {
      newPrecedence = terminal.precedence;
    }
    if (existingAction[0] === 2) {
      existingProduction = this.productions[existingAction[1]];
      existingPrecedence = existingProduction.precedence;
    } else {
      existingPrecedence = terminal.precedence;
    }
    // Resolve by precedence
    if (newPrecedence > existingPrecedence) {
      this.table[state.id][terminal.id] = newAction;
    } else if (newPrecedence === existingPrecedence) {
      // Resolve by associativity
      if (terminal.associativity === 'left') {
        // Prefer reduce (existing)
        if (existingAction[0] === 2) {
          return;
        }
        this.table[state.id][terminal.id] = newAction;
      } else if (terminal.associativity === 'right') {
        // Prefer shift (new)
        if (newAction[0] === 1) {
          this.table[state.id][terminal.id] = newAction;
        }
      } else {
        console.warn(`Shift-reduce conflict at state ${state.id} on ${symbol} (equal precedence)`);
        this.conflicts++;
      }
    }
  }

  // ============================================================================
  // Parser Generation
  // ============================================================================
  generateModuleExpr() {
    // Generate parser code
    return `(function() {
  var parser = {
    trace: function ${this.trace.toString().replace(/^trace/, '')},
    yy: {},
    symbols_: ${JSON.stringify(this.terminalNames)},
    terminals_: ${JSON.stringify(this.terminals)},
    productionData: ${this.generateProductionData()},
    table: ${this.generateCompressedTable()},
    defaultActions: ${JSON.stringify(this.defaultActions)},
    parseError: function ${this.parseError.toString().replace(/^parseError/, '')},
    parse: function ${this.parse.toString().replace(/^parse/, '')},
    lexer: undefined
  };
  
  ${this.generatePerformAction()}
  
  parser.performAction = performAction;
  return parser;
})()`;
  }

  generateProductionData() {
    var i, len1, production, ref, result;
    result = [];
    ref = this.productions;
    for (i = 0, len1 = ref.length; i < len1; i++) {
      production = ref[i];
      result.push([production.lhs.id, production.rhs.length]);
    }
    return JSON.stringify(result);
  }

  generateCompressedTable() {
    var action, compressed, i, j, len1, len2, ref, ref1, row, state, symbol;
    compressed = [];
    ref = this.table;
    for (i = 0, len1 = ref.length; i < len1; i++) {
      row = ref[i];
      compressed[i] = {};
      for (symbol in row) {
        action = row[symbol];
        compressed[i][symbol] = action;
      }
    }
    return JSON.stringify(compressed);
  }

  generatePerformAction() {
    var action, i, len1, production, ref;
    var code = 'function performAction(yytext, yyleng, yylineno, yy, yystate, $$, _$) {\n';
    code += '  var $0 = $$.length - 1;\n';
    code += '  switch (yystate) {\n';
    ref = this.productions;
    for (i = 0, len1 = ref.length; i < len1; i++) {
      production = ref[i];
      if (production.action) {
        code += `    case ${production.id}:\n`;
        // Replace $$ with this.$, $n with $$[$0-n+1]
        action = production.action.replace(/\$\$/g, 'this.$').replace(/\$(\d+)/g, function(match, n) {
          return `$$[$0-${production.rhs.length - n}]`;
        }).replace(/@(\d+)/g, function(match, n) {
          return `_$[$0-${production.rhs.length - n}]`;
        });
        code += `      ${action}\n`;
        code += '      break;\n';
      }
    }
    code += '  }\n';
    code += '}';
    return code;
  }

  parseError(str, hash) {
    if (hash.recoverable) {
      this.trace(str);
    } else {
      var error = new Error(str);
      error.hash = hash;
      throw error;
    }
  }

  parse(input) {
    var EOF, TERROR, action, checkRecover, errStr, error, expected, gotos, i, j, k, l, len, len1, len2, lexer, locFirst, locLast, loc, newState, p, parseTable, preErrorSymbol, r, ranges, recovering, ref, ref1, ref2, ref3, ref4, ref5, sharedState, stk, symbol, table, val, vstack, yylineno, yyleng, yyloc, yytext, yyval;
    // Setup
    stk = [0]; // state stack
    val = [null]; // value stack
    loc = []; // location stack
    table = this.table;
    parseTable = this.table;
    gotos = this.goto;
    yyval = {};
    recovering = 0; // 0=not recovering, 1-3=recovering
    TERROR = 2;
    EOF = 1;
    // Lexer setup
    lexer = this.lexer || {
      lex: function() {
        return EOF;
      },
      setInput: function(input) {
        return this.input = input;
      },
      input: ''
    };
    if (typeof input === 'string') {
      lexer.setInput(input);
    }
    // Shared state
    sharedState = {
      yy: this.yy || {}
    };
    lexer.yy = sharedState.yy;
    sharedState.yy.lexer = lexer;
    sharedState.yy.parser = this;
    // Location tracking
    ranges = (ref = lexer.options) != null ? ref.ranges : void 0;
    yyloc = (ref1 = lexer.yylloc) != null ? ref1 : {};
    sharedState.yy.parseError = typeof sharedState.yy.parseError === 'function' ? sharedState.yy.parseError : this.parseError;
    // Main parse loop
    symbol = null;
    preErrorSymbol = null;
    yyleng = yytext = yylineno = 0;
    while (true) {
      // Get current state
      state = stk[stk.length - 1];
      // Get default action for this state
      if (this.defaultActions[state]) {
        action = this.defaultActions[state];
      } else {
        // Get next token if needed
        if (!symbol) {
          symbol = lexer.lex() || EOF;
          if (symbol === EOF) {
            symbol = '$EOF';
          }
        }
        // Get action from parse table
        action = table[state] && table[state][symbol];
      }
      // Handle missing action
      if (!action || !action.length || !action[0]) {
        // Error recovery
        errStr = '';
        expected = [];
        for (p in table[state]) {
          if (this.terminals_[p] && p > TERROR) {
            expected.push(`'${this.terminals_[p]}'`);
          }
        }
        if (lexer.showPosition) {
          errStr = `Parse error on line ${yylineno + 1}:\n${lexer.showPosition()}\nExpecting ${expected.join(', ')}, got '${this.terminals_[symbol] || symbol}'`;
        } else {
          errStr = `Parse error on line ${yylineno + 1}: Unexpected ${symbol === EOF ? 'end of input' : `'${this.terminals_[symbol] || symbol}'`}`;
        }
        this.parseError(errStr, {
          text: lexer.match,
          token: this.terminals_[symbol] || symbol,
          line: lexer.yylineno,
          loc: yyloc,
          expected: expected
        });
      }
      if (action[0] instanceof Array && action.length > 1) {
        throw new Error(`Parse Error: multiple actions possible at state: ${state}, token: ${symbol}`);
      }
      switch (action[0]) {
        case 1: // shift
          stk.push(symbol, action[1]);
          val.push(lexer.yytext);
          loc.push(lexer.yylloc);
          symbol = null;
          if (!preErrorSymbol) {
            [yyleng, yytext, yylineno, yyloc] = [lexer.yyleng, lexer.yytext, lexer.yylineno, lexer.yylloc];
            if (recovering > 0) {
              recovering--;
            }
          } else {
            [symbol, preErrorSymbol] = [preErrorSymbol, null];
          }
          break;
        case 2: // reduce
          len = this.productionData[action[1]][1];
          yyval.$ = val[val.length - len];
          [locFirst, locLast] = [loc[loc.length - (len || 1)], loc[loc.length - 1]];
          yyval._$ = {
            first_line: locFirst.first_line,
            last_line: locLast.last_line,
            first_column: locFirst.first_column,
            last_column: locLast.last_column
          };
          if (ranges) {
            yyval._$.range = [locFirst.range[0], locLast.range[1]];
          }
          r = this.performAction.apply(yyval, [yytext, yyleng, yylineno, sharedState.yy, action[1], val, loc]);
          if (r != null) {
            return r;
          }
          if (len) {
            stk.length -= len * 2;
            val.length -= len;
            loc.length -= len;
          }
          stk.push(this.productionData[action[1]][0]);
          val.push(yyval.$);
          loc.push(yyval._$);
          newState = parseTable[stk[stk.length - 2]][stk[stk.length - 1]];
          stk.push(newState);
          break;
        case 3: // accept
          return true;
      }
    }
  }

  trace(msg) { // Debug output (no-op by default)
    var ref;
    if ((ref = this.options) != null ? ref.debug : void 0) {
      return console.log(msg);
    }
  }

  createParser() {
    var bindMethod, parser;
    parser = eval(this.generateModuleExpr());
    parser.productions = this.productions;
    bindMethod = (method) => {
      return () => {
        this.lexer = parser.lexer;
        return this[method].apply(this, arguments);
      };
    };
    parser.lexer = this.lexer;
    parser.generate = bindMethod('generate');
    parser.generateModule = bindMethod('generateModule');
    parser.generateCommonJSModule = bindMethod('generateCommonJSModule');
    return parser;
  }
};

// ==============================================================================
// Exports
// ==============================================================================
Solar = {};

Solar.Parser = function(grammar, options) {
  var generator;
  generator = new Generator(grammar, options);
  return generator.createParser();
};

Solar.Generator = function(g, options) {
  return new Generator(g, Object.assign({}, g.options, options));
};

// ESM exports
export { Generator, Solar };
export default Solar;