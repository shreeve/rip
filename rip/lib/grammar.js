// Generated by CoffeeScript 2.7.0
// Rip's beautiful, simple, powerful grammar - using Rip's own syntax!

// Test Coverage Legend:
//   ✅ = Tested and passing
//   ⚠️ = Partially tested or has issues
//   ❌ = Tested but failing
//   (no marker) = Not yet tested
var binOp, grammar, o, unOp;

o = function(pattern, action = (function() {
    return $1;
  })) {
  return [
    pattern,
    function() {
      var result;
      result = action.apply(this,
    arguments);
      if ((result != null) && typeof result === 'object' && !result.pos) {
        result.pos = '@$';
      }
      return result;
    }
  ];
};

binOp = function(ripOp, jsOp = ripOp) {
  return o(`Expression ${ripOp} Expression`, function() {
    return {
      type: 'op',
      op: jsOp,
      left: $1,
      right: $3
    };
  });
};

unOp = function(ripOp, jsOp = ripOp) {
  return o(`${ripOp} Expression`, function() {
    return {
      type: 'unary',
      op: jsOp,
      expr: $2
    };
  });
};

grammar = {
  // Operator precedence (from lowest to highest)
  // TODO: Use a """ and split these for visual clarity
  operators: [["right", "=", "+=", "-=", "*=", "/="], ["left", "or", "||"], ["left", "and", "&&"], ["left", "==", "!=", "is", "isnt"], ["left", "<", ">", "<=", ">=", "in", "of"], ["left", "+", "-"], ["left", "*", "/", "%"], ["right", "!", "not", "typeof"], ["left", ".", "?.", "[", "]"], ["left", "CALL"]],
  bnf: {
    Root: [o("Body")],
    Body: [
      o("Line",
      function() {
        return [$1];
      }),
      o("Body TERMINATOR Line",
      function() {
        $1.push($3);
        return $1;
      }),
      o("Body TERMINATOR")
    ],
    Line: [
      o("Expression"),
      o("Statement"),
      o("",
      function() {
        return null;
      })
    ],
    // Statements (can't be expressions)
    Statement: [o("Return"), o("Throw"), o("Break"), o("Continue"), o("Import"), o("Export")],
    // Expressions (produce values)
    Expression: [o("Value"), o("Assign"), o("Operation"), o("Code"), o("If"), o("For"), o("While"), o("Try")],
    // Values (things that can be assigned to or called)
    Value: [o("Literal"), o("Identifier"), o("ThisProperty"), o("Array"), o("Object"), o("Parenthetical"), o("Range"), o("Invocation"), o("Member")],
    // Literals (the atoms of our language)
    Literal: [
      o("NUMBER",
      function() {
        return {
          type: 'num',
          val: $1 // ✅
        };
      }),
      o("STRING",
      function() {
        return {
          type: 'str',
          val: $1 // ✅
        };
      }),
      o("BOOL",
      function() {
        return {
          type: 'bool',
          val: $1
        };
      }),
      o("NULL",
      function() {
        return {
          type: 'null'
        };
      }),
      o("UNDEFINED",
      function() {
        return {
          type: 'undef'
        };
      }),
      o("REGEX",
      function() {
        return {
          type: 'regex',
          val: $1
        };
      })
    ],
    // Identifiers and properties
    Identifier: [
      o("IDENTIFIER",
      function() {
        return {
          type: 'id',
          name: $1 // ✅
        };
      })
    ],
    ThisProperty: [
      o("@ IDENTIFIER",
      function() {
        return {
          type: 'prop',
          obj: {
            type: 'this',
            pos: '@1'
          },
          prop: {
            type: 'id',
            name: $2,
            pos: '@2'
          }
        };
      })
    ],
    // Member access (dot notation and brackets)
    Member: [
      o("Value . IDENTIFIER",
      function() {
        return {
          type: 'prop',
          obj: $1,
          prop: {
            type: 'id',
            name: $3,
            pos: '@3' // ✅
          }
        };
      }),
      o("Value ?. IDENTIFIER",
      function() {
        return {
          type: 'prop',
          obj: $1,
          prop: {
            type: 'id',
            name: $3,
            pos: '@3'
          },
          optional: true
        };
      }),
      o("Value [ Expression ]",
      function() {
        return {
          type: 'index',
          obj: $1,
          index: $3 // ✅
        };
      }),
      o("Value ?[ Expression ]",
      function() {
        return {
          type: 'index',
          obj: $1,
          index: $3,
          optional: true
        };
      })
    ],
    Array: [
      o("[ ]",
      function() {
        return {
          type: 'array',
          items: [] // ✅
        };
      }),
      o("[ ArgList ]",
      function() {
        return {
          type: 'array',
          items: $2 // ✅
        };
      }),
      o("[ ArgList , ]",
      function() {
        return {
          type: 'array',
          items: $2 // trailing comma
        };
      })
    ],
    Object: [
      o("{ }",
      function() {
        return {
          type: 'object',
          props: [] // ✅
        };
      }),
      o("{ PropList }",
      function() {
        return {
          type: 'object',
          props: $2 // ✅
        };
      }),
      o("{ PropList , }",
      function() {
        return {
          type: 'object',
          props: $2 // trailing comma
        };
      })
    ],
    PropList: [
      o("Property",
      function() {
        return [$1];
      }),
      o("PropList , Property",
      function() {
        return $1.concat($3);
      }),
      o("PropList TERMINATOR Property",
      function() {
        return $1.concat($3);
      })
    ],
    Property: [
      o("IDENTIFIER : Expression",
      function() {
        return {
          key: {
            type: 'id',
            name: $1,
            pos: '@1'
          },
          val: $3
        };
      }),
      o("STRING : Expression",
      function() {
        return {
          key: {
            type: 'str',
            val: $1,
            pos: '@1'
          },
          val: $3
        };
      }),
      o("[ Expression ] : Expression",
      function() {
        return {
          key: $2,
          val: $4,
          computed: true
        };
      }),
      o("IDENTIFIER",
      function() {
        return {
          key: {
            type: 'id',
            name: $1,
            pos: '@1'
          },
          val: {
            type: 'id',
            name: $1,
            pos: '@1'
          },
          shorthand: true
        };
      })
    ],
    // Ranges
    Range: [
      o("[ Expression .. Expression ]",
      function() {
        return {
          type: 'range',
          from: $2,
          to: $4,
          exclusive: false
        };
      }),
      o("[ Expression ... Expression ]",
      function() {
        return {
          type: 'range',
          from: $2,
          to: $4,
          exclusive: true
        };
      })
    ],
    // Assignment
    Assign: [
      o("Assignable = Expression",
      function() {
        return {
          type: 'assign',
          left: $1,
          right: $3 // ✅
        };
      }),
      o("Assignable = INDENT Expression OUTDENT",
      function() {
        return {
          type: 'assign',
          left: $1,
          right: $4
        };
      }),
      o("Assignable += Expression",
      function() {
        return {
          type: 'assign',
          left: $1,
          right: $3,
          op: '+=' // ✅
        };
      }),
      o("Assignable -= Expression",
      function() {
        return {
          type: 'assign',
          left: $1,
          right: $3,
          op: '-=' // ✅
        };
      }),
      o("Assignable *= Expression",
      function() {
        return {
          type: 'assign',
          left: $1,
          right: $3,
          op: '*=' // ✅
        };
      }),
      o("Assignable /= Expression",
      function() {
        return {
          type: 'assign',
          left: $1,
          right: $3,
          op: '/=' // ✅
        };
      })
    ],
    Assignable: [o("Identifier"), o("Member"), o("ThisProperty")],
    // Operations - using our beautiful helpers!
    Operation: [
      // Binary operators
      binOp("+"), // ✅
      binOp("-"), // ✅
      binOp("*"), // ✅
      binOp("/"), // ✅
      binOp("%"), // ✅
      binOp("**"), // power
      binOp("=="),
      binOp("!="),
      binOp("<"),
      binOp(">"),
      binOp("<="),
      binOp(">="),
      binOp("and",
      "&&"),
      binOp("or",
      "||"),
      binOp("is",
      "==="), // ✅
      binOp("isnt",
      "!=="), // ✅
      binOp("in"),
      binOp("of"),
      binOp("instanceof"),
      // Unary operators
      unOp("!"), // ✅
      unOp("not",
      "!"), // ✅
      unOp("-"),
      unOp("+"),
      unOp("typeof"),
      unOp("delete"),
      // Postfix
      o("Expression ++",
      function() {
        return {
          type: 'update',
          op: '++',
          expr: $1,
          prefix: false
        };
      }),
      o("Expression --",
      function() {
        return {
          type: 'update',
          op: '--',
          expr: $1,
          prefix: false
        };
      }),
      o("++ Expression",
      function() {
        return {
          type: 'update',
          op: '++',
          expr: $2,
          prefix: true
        };
      }),
      o("-- Expression",
      function() {
        return {
          type: 'update',
          op: '--',
          expr: $2,
          prefix: true
        };
      }),
      // Ternary
      o("Expression ? Expression : Expression",
      function() {
        return {
          type: 'ternary',
          test: $1,
          then: $3,
          else: $5
        };
      })
    ],
    // Function invocation
    Invocation: [
      o("Value ( )",
      function() {
        return {
          type: 'call',
          func: $1,
          args: [] // ✅
        };
      }),
      o("Value ( ArgList )",
      function() {
        return {
          type: 'call',
          func: $1,
          args: $3 // ✅
        };
      }),
      o("Value ?( )",
      function() {
        return {
          type: 'call',
          func: $1,
          args: [],
          optional: true // ⚠️ implicit calls
        };
      }),
      o("Value ?( ArgList )",
      function() {
        return {
          type: 'call',
          func: $1,
          args: $3,
          optional: true // ⚠️ implicit calls
        };
      })
    ],
    ArgList: [
      o("Expression",
      function() {
        return [$1];
      }),
      o("ArgList , Expression",
      function() {
        return $1.concat($3);
      })
    ],
    // Functions (Code)
    Code: [
      o("-> Block",
      function() {
        return {
          type: 'func',
          params: [],
          body: $2,
          bound: false // ✅
        };
      }),
      o("=> Block",
      function() {
        return {
          type: 'func',
          params: [],
          body: $2,
          bound: true
        };
      }),
      o("ParamList -> Block",
      function() {
        return {
          type: 'func',
          params: $1,
          body: $3,
          bound: false // ✅
        };
      }),
      o("ParamList => Block",
      function() {
        return {
          type: 'func',
          params: $1,
          body: $3,
          bound: true
        };
      })
    ],
    ParamList: [
      o("( )",
      function() {
        return [];
      }),
      o("( Params )",
      function() {
        return $2;
      }),
      o("Param",
      function() {
        return [$1]; // no parens for single param
      })
    ],
    Params: [
      o("Param",
      function() {
        return [$1];
      }),
      o("Params , Param",
      function() {
        return $1.concat($3);
      })
    ],
    Param: [
      o("IDENTIFIER",
      function() {
        return {
          type: 'param',
          name: $1
        };
      }),
      o("IDENTIFIER = Expression",
      function() {
        return {
          type: 'param',
          name: $1,
          default: $3
        };
      }),
      o("... IDENTIFIER",
      function() {
        return {
          type: 'param',
          name: $2,
          rest: true
        };
      })
    ],
    // Control flow
    If: [
      o("IF Expression Block",
      function() {
        return {
          type: 'if',
          test: $2,
          then: $3 // ❌
        };
      }),
      o("IF Expression Block ELSE Block",
      function() {
        return {
          type: 'if',
          test: $2,
          then: $3,
          else: $5 // ❌
        };
      }),
      o("IF Expression Block ELSE IF Expression Block",
      function() {
        return {
          type: 'if',
          test: $2,
          then: $3,
          else: {
            type: 'if',
            test: $5,
            then: $7,
            pos: '@5'
          }
        };
      }),
      o("Expression IF Expression",
      function() {
        return {
          type: 'if',
          test: $3,
          then: $1,
          postfix: true // ✅
        };
      }),
      o("Expression UNLESS Expression",
      function() {
        return {
          type: 'if',
          test: $3,
          then: $1,
          invert: true,
          postfix: true // ✅
        };
      })
    ],
    For: [
      o("FOR IDENTIFIER IN Expression Block",
      function() {
        return {
          type: 'for-in',
          var: $2,
          iter: $4,
          body: $5
        };
      }),
      o("FOR IDENTIFIER OF Expression Block",
      function() {
        return {
          type: 'for-of',
          var: $2,
          iter: $4,
          body: $5
        };
      }),
      o("Expression FOR IDENTIFIER IN Expression",
      function() {
        return {
          type: 'for-in',
          var: $3,
          iter: $5,
          body: $1,
          postfix: true
        };
      })
    ],
    While: [
      o("WHILE Expression Block",
      function() {
        return {
          type: 'while',
          test: $2,
          body: $3
        };
      }),
      o("UNTIL Expression Block",
      function() {
        return {
          type: 'while',
          test: $2,
          body: $3,
          invert: true
        };
      }),
      o("LOOP Block",
      function() {
        return {
          type: 'while',
          test: {
            type: 'bool',
            val: 'true',
            pos: '@1'
          },
          body: $2
        };
      })
    ],
    Try: [
      o("TRY Block",
      function() {
        return {
          type: 'try',
          body: $2
        };
      }),
      o("TRY Block CATCH IDENTIFIER Block",
      function() {
        return {
          type: 'try',
          body: $2,
          param: $4,
          handler: $5
        };
      }),
      o("TRY Block FINALLY Block",
      function() {
        return {
          type: 'try',
          body: $2,
          finalizer: $4
        };
      })
    ],
    // Other statements
    Return: [
      o("RETURN",
      function() {
        return {
          type: 'return' // ✅
        };
      }),
      o("RETURN Expression",
      function() {
        return {
          type: 'return',
          val: $2 // ✅
        };
      })
    ],
    Throw: [
      o("THROW Expression",
      function() {
        return {
          type: 'throw',
          arg: $2
        };
      })
    ],
    Break: [
      o("BREAK",
      function() {
        return {
          type: 'break'
        };
      })
    ],
    Continue: [
      o("CONTINUE",
      function() {
        return {
          type: 'continue'
        };
      })
    ],
    // Module system
    Import: [
      o("IMPORT STRING",
      function() {
        return {
          type: 'import',
          source: $2
        };
      }),
      o("IMPORT IDENTIFIER FROM STRING",
      function() {
        return {
          type: 'import',
          default: $2,
          source: $4
        };
      }),
      o("IMPORT { ImportList } FROM STRING",
      function() {
        return {
          type: 'import',
          specs: $3,
          source: $6
        };
      }),
      o("IMPORT * AS IDENTIFIER FROM STRING",
      function() {
        return {
          type: 'import',
          namespace: $4,
          source: $6
        };
      })
    ],
    ImportList: [
      o("IDENTIFIER",
      function() {
        return [
          {
            imported: $1,
            local: $1
          }
        ];
      }),
      o("IDENTIFIER AS IDENTIFIER",
      function() {
        return [
          {
            imported: $1,
            local: $3
          }
        ];
      }),
      o("ImportList , IDENTIFIER",
      function() {
        return $1.concat([
          {
            imported: $3,
            local: $3
          }
        ]);
      }),
      o("ImportList , IDENTIFIER AS IDENTIFIER",
      function() {
        return $1.concat([
          {
            imported: $3,
            local: $5
          }
        ]);
      })
    ],
    Export: [
      o("EXPORT Expression",
      function() {
        return {
          type: 'export',
          val: $2
        };
      }),
      o("EXPORT DEFAULT Expression",
      function() {
        return {
          type: 'export',
          val: $3,
          default: true
        };
      }),
      o("EXPORT { ExportList }",
      function() {
        return {
          type: 'export',
          specs: $3
        };
      })
    ],
    ExportList: [
      o("IDENTIFIER",
      function() {
        return [
          {
            local: $1,
            exported: $1
          }
        ];
      }),
      o("IDENTIFIER AS IDENTIFIER",
      function() {
        return [
          {
            local: $1,
            exported: $3
          }
        ];
      }),
      o("ExportList , IDENTIFIER",
      function() {
        return $1.concat([
          {
            local: $3,
            exported: $3
          }
        ]);
      }),
      o("ExportList , IDENTIFIER AS IDENTIFIER",
      function() {
        return $1.concat([
          {
            local: $3,
            exported: $5
          }
        ]);
      })
    ],
    // Blocks
    Block: [
      o("INDENT Body OUTDENT",
      function() {
        return $2; // ❌
      }),
      o("Expression",
      function() {
        return [$1]; // ❌
      })
    ],
    // Parenthetical (for grouping)
    Parenthetical: [
      o("( Expression )",
      function() {
        return $2; // just pass through, parens were for precedence
      })
    ]
  },
  // Start symbol
  start: "Root",
  // =========================================================================
  // ADVANCED FEATURES - NOT YET IMPLEMENTED
  // =========================================================================
  // Below this line are advanced CoffeeScript features that we haven't
  // focused on yet. They're here so we have everything in one place and
  // can stop referring back to grammar.coffee. These will be activated
  // progressively as we build out the language.
  // =========================================================================

  // Classes (ES6 class syntax)
  Class: [
    o("CLASS",
    function() {
      return {
        type: 'class'
      };
    }),
    o("CLASS Block",
    function() {
      return {
        type: 'class',
        body: $2
      };
    }),
    o("CLASS EXTENDS Expression",
    function() {
      return {
        type: 'class',
        superClass: $3
      };
    }),
    o("CLASS EXTENDS Expression Block",
    function() {
      return {
        type: 'class',
        superClass: $3,
        body: $4
      };
    }),
    o("CLASS SimpleAssignable",
    function() {
      return {
        type: 'class',
        name: $2
      };
    }),
    o("CLASS SimpleAssignable Block",
    function() {
      return {
        type: 'class',
        name: $2,
        body: $3
      };
    }),
    o("CLASS SimpleAssignable EXTENDS Expression",
    function() {
      return {
        type: 'class',
        name: $2,
        superClass: $4
      };
    }),
    o("CLASS SimpleAssignable EXTENDS Expression Block",
    function() {
      return {
        type: 'class',
        name: $2,
        superClass: $4,
        body: $5
      };
    })
  ],
  // Super calls
  Super: [
    o("SUPER",
    function() {
      return {
        type: 'super'
      };
    }),
    o("SUPER Arguments",
    function() {
      return {
        type: 'super',
        args: $2
      };
    }),
    o("SUPER . Property",
    function() {
      return {
        type: 'super',
        prop: $3
      };
    })
  ],
  // Switch statements
  Switch: [
    o("SWITCH Expression INDENT Whens OUTDENT",
    function() {
      return {
        type: 'switch',
        test: $2,
        cases: $4
      };
    }),
    o("SWITCH Expression INDENT Whens ELSE Block OUTDENT",
    function() {
      return {
        type: 'switch',
        test: $2,
        cases: $4,
        default: $6
      };
    }),
    o("SWITCH INDENT Whens OUTDENT",
    function() {
      return {
        type: 'switch',
        cases: $3
      };
    }),
    o("SWITCH INDENT Whens ELSE Block OUTDENT",
    function() {
      return {
        type: 'switch',
        cases: $3,
        default: $5
      };
    })
  ],
  Whens: [
    o("When",
    function() {
      return [$1];
    }),
    o("Whens When",
    function() {
      return $1.concat($2);
    })
  ],
  When: [
    o("WHEN SimpleArgs Block",
    function() {
      return {
        type: 'case',
        tests: $2,
        body: $3
      };
    }),
    o("WHEN SimpleArgs Block TERMINATOR",
    function() {
      return {
        type: 'case',
        tests: $2,
        body: $3
      };
    })
  ],
  SimpleArgs: [
    o("Expression",
    function() {
      return [$1];
    }),
    o("SimpleArgs , Expression",
    function() {
      return $1.concat($3);
    })
  ],
  // Generators and yield
  Yield: [
    o("YIELD",
    function() {
      return {
        type: 'yield'
      };
    }),
    o("YIELD Expression",
    function() {
      return {
        type: 'yield',
        arg: $2
      };
    }),
    o("YIELD FROM Expression",
    function() {
      return {
        type: 'yield',
        delegate: true,
        arg: $3
      };
    })
  ],
  // Async/await
  Await: [
    o("AWAIT Expression",
    function() {
      return {
        type: 'await',
        arg: $2
      };
    })
  ],
  // Do expressions (IIFE)
  DoExpression: [
    o("DO Expression",
    function() {
      return {
        type: 'do',
        body: $2
      };
    }),
    o("DO Block",
    function() {
      return {
        type: 'do',
        body: $2
      };
    })
  ],
  // Existence operator
  Existence: [
    o("Expression ?",
    function() {
      return {
        type: 'existence',
        expr: $1
      };
    })
  ],
  // String interpolation
  StringWithInterpolations: [
    o("STRING_START Interpolations STRING_END",
    function() {
      return {
        type: 'template',
        parts: $2
      };
    })
  ],
  Interpolations: [
    o("InterpolationChunk",
    function() {
      return [$1];
    }),
    o("Interpolations InterpolationChunk",
    function() {
      return $1.concat($2);
    })
  ],
  InterpolationChunk: [
    o("INTERPOLATION_START Body INTERPOLATION_END",
    function() {
      return {
        type: 'interpolation',
        expr: $2
      };
    }),
    o("String",
    function() {
      return $1;
    })
  ],
  // Destructuring assignments (arrays and objects)
  Destructuring: [
    o("[ DestructureList ]",
    function() {
      return {
        type: 'array-pattern',
        elements: $2
      };
    }),
    o("{ DestructureList }",
    function() {
      return {
        type: 'object-pattern',
        properties: $2
      };
    })
  ],
  DestructureList: [
    o("DestructureItem",
    function() {
      return [$1];
    }),
    o("DestructureList , DestructureItem",
    function() {
      return $1.concat($3);
    })
  ],
  DestructureItem: [
    o("Identifier",
    function() {
      return $1;
    }),
    o("Identifier = Expression",
    function() {
      return {
        type: 'default',
        left: $1,
        right: $3
      };
    }),
    o("... Identifier",
    function() {
      return {
        type: 'rest',
        arg: $2
      };
    })
  ],
  // Splats in arrays and arguments
  Splat: [
    o("Expression ...",
    function() {
      return {
        type: 'spread',
        arg: $1
      };
    }),
    o("... Expression",
    function() {
      return {
        type: 'spread',
        arg: $2,
        prefix: true
      };
    })
  ],
  // JS passthrough (backticks)
  JSLiteral: [
    o("JS",
    function() {
      return {
        type: 'js',
        code: $1
      };
    })
  ],
  // Regex with interpolation
  RegexWithInterpolations: [
    o("REGEX_START Invocation REGEX_END",
    function() {
      return {
        type: 'regex-template',
        pattern: $2
      };
    })
  ],
  // Meta properties (new.target, import.meta)
  MetaProperty: [
    o("NEW_TARGET",
    function() {
      return {
        type: 'meta',
        meta: 'new',
        prop: 'target'
      };
    }),
    o("IMPORT_META",
    function() {
      return {
        type: 'meta',
        meta: 'import',
        prop: 'meta'
      };
    })
  ],
  // Tagged template literals
  TaggedTemplate: [
    o("Value String",
    function() {
      return {
        type: 'tagged',
        tag: $1,
        template: $2
      };
    })
  ],
  // Dynamic import
  DynamicImport: [
    o("DYNAMIC_IMPORT Arguments",
    function() {
      return {
        type: 'dynamic-import',
        args: $2
      };
    })
  ],
  // Array elisions (holes)
  Elision: [
    o(",",
    function() {
      return {
        type: 'elision'
      };
    })
  ]
};

// Export the grammar
export default grammar;

export {
  grammar
};
