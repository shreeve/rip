// Generated by CoffeeScript 2.7.0
  // Rip Rewriter - Essential token stream transformations
  // Makes Rip feel natural by adding implicit syntax
var Rewriter,
  indexOf = [].indexOf;

Rewriter = class Rewriter {
  constructor() {
    this.tokens = [];
    this.stack = []; // Track nesting for implicit calls/objects
  }

  
    // Main rewrite pipeline - order matters!
  rewrite(tokens) {
    this.tokens = tokens;
    this.removeLeadingNewlines();
    this.tagPostfixConditionals();
    this.addImplicitBracesAndParens();
    this.normalizeLines();
    return this.tokens;
  }

  // Scan tokens with ability to insert/remove
  scanTokens(fn) {
    var delta, i;
    i = 0;
    while (i < this.tokens.length) {
      delta = fn.call(this, this.tokens[i], i, this.tokens);
      i += delta;
    }
    return true;
  }

  // Find matching end of balanced expression
  detectEnd(start, condition, action) {
    var EXPRESSION_END, EXPRESSION_START, i, levels, ref, ref1, token;
    levels = 0;
    i = start;
    EXPRESSION_START = ['INDENT', '(', '[', '{'];
    EXPRESSION_END = ['OUTDENT', ')', ']', '}'];
    while (i < this.tokens.length) {
      token = this.tokens[i];
      // Check end condition at depth 0
      if (levels === 0 && condition.call(this, token, i)) {
        if (action) {
          return action.call(this, token, i);
        }
        return i;
      }
      // Track nesting depth
      if (ref = token[0], indexOf.call(EXPRESSION_START, ref) >= 0) {
        levels += 1;
      } else if (ref1 = token[0], indexOf.call(EXPRESSION_END, ref1) >= 0) {
        levels -= 1;
      }
      if (levels < 0) {
        return i;
      }
      i += 1;
    }
    return i;
  }

  // Helper to get token type at index
  tag(i) {
    var ref;
    return (ref = this.tokens[i]) != null ? ref[0] : void 0;
  }

  // Generate a synthetic token
  generate(type, value = '') {
    var token;
    token = [type, value, 0, 0];
    token.generated = true;
    return token;
  }

  // Remove leading newlines (they confuse the grammar)
  removeLeadingNewlines() {
    var ref;
    while (((ref = this.tokens[0]) != null ? ref[0] : void 0) === 'TERMINATOR') {
      this.tokens.shift();
    }
    return true;
  }

  // Tag postfix conditionals so grammar can handle them differently
  tagPostfixConditionals() {
    return this.scanTokens((token, i, tokens) => {
      var next, prev, ref, ref1, ref2;
      if ((ref = token[0]) !== 'IF' && ref !== 'UNLESS') {
        return 1;
      }
      // Check if this is postfix by looking backward
      prev = tokens[i - 1];
      if (prev && ((ref1 = prev[0]) !== 'TERMINATOR' && ref1 !== 'INDENT' && ref1 !== 'OUTDENT' && ref1 !== 'THEN' && ref1 !== null)) {
        // Look forward to see if there's a block
        next = tokens[i + 1];
        if ((ref2 = next != null ? next[0] : void 0) !== 'INDENT' && ref2 !== 'THEN') {
          token[0] = 'POST_' + token[0];
        }
      }
      return 1;
    });
  }

  // The big one - add implicit calls and objects
  addImplicitBracesAndParens() {
    var IMPLICIT_BLOCK, IMPLICIT_CALL, IMPLICIT_END, IMPLICIT_FUNC, stack;
    // Track what we're inside of
    stack = [];
    // Tokens that can be implicitly called
    IMPLICIT_FUNC = ['IDENTIFIER', 'PROPERTY', ')', ']', 'THIS', 'SUPER'];
    // Tokens that can be arguments to implicit calls
    IMPLICIT_CALL = ['IDENTIFIER', 'NUMBER', 'STRING', 'REGEX', 'BOOL', 'NULL', 'UNDEFINED', 'THIS', 'SUPER', '@', '(', '[', '{', 'IF', 'UNLESS', 'FOR', 'WHILE', 'SWITCH', 'TRY', '->', '=>'];
    // Don't start implicit calls in these contexts
    IMPLICIT_BLOCK = ['IF', 'UNLESS', 'FOR', 'WHILE', 'SWITCH', 'CATCH', 'FINALLY'];
    // Tokens that end implicit calls
    IMPLICIT_END = ['TERMINATOR', 'OUTDENT', 'POST_IF', 'POST_UNLESS', ',', ')', ']', '}'];
    return this.scanTokens((token, i, tokens) => {
      var callEnd, callStart, closeBrace, endIdx, insertIdx, isControl, j, k, l, needsOpen, next, nextNext, openBrace, prev, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, ref8, startIdx, type;
      if (i > 0) {
        prev = tokens[i - 1];
      }
      next = tokens[i + 1];
      nextNext = tokens[i + 2];
      // Check for implicit function call
      // Token needs to be spaced (or certain types like PROPERTY)
      if ((ref = token[0], indexOf.call(IMPLICIT_FUNC, ref) >= 0) && token.spaced && (ref1 = next != null ? next[0] : void 0, indexOf.call(IMPLICIT_CALL, ref1) >= 0)) {
        // Don't add implicit call if:
        // 1. We're in a control flow condition
        // 2. Next is a comma (we're in a list)
        // 3. Already has explicit parens
        // 4. We're on different lines (unless indented)

        // Check for control flow
        isControl = false;
        for (j = k = ref2 = i - 1; k >= 0; j = k += -1) {
          if (ref3 = tokens[j][0], indexOf.call(IMPLICIT_BLOCK, ref3) >= 0) {
            isControl = true;
            break;
          }
          if ((ref4 = tokens[j][0]) === 'TERMINATOR' || ref4 === 'INDENT' || ref4 === 'OUTDENT') {
            break;
          }
        }
        // Add implicit call if appropriate
        if (!isControl && next[0] !== ',') {
          // For same line or indented block
          if (!next.newLine || (nextNext != null ? nextNext[0] : void 0) === 'INDENT') {
            // Insert opening paren
            callStart = this.generate('(', '(');
            tokens.splice(i + 1, 0, callStart);
            stack.push(['CALL', i + 1]);
            // Find where to end the call
            endIdx = this.detectEnd(i + 2, function(t) {
              var ref5;
              return ref5 = t[0], indexOf.call(IMPLICIT_END, ref5) >= 0;
            }, function(t, j) {
              return j;
            });
            // Insert closing paren
            callEnd = this.generate(')', ')');
            tokens.splice(endIdx, 0, callEnd);
            return 2;
          }
        }
      }
      // Check for implicit object
      // This happens with patterns like:
      //   func
      //     a: 1
      //     b: 2
      // or inline: {a: 1, b: 2}
      if (token[0] === ':' && (prev != null ? prev[0] : void 0) === 'IDENTIFIER') {
        // Look backwards to see if we need to open an object
        needsOpen = true;
// Check if we're already in an explicit object
        for (j = l = ref5 = i - 1; l >= 0; j = l += -1) {
          if (tokens[j][0] === '{') {
            needsOpen = false;
            break;
          }
          if ((ref6 = tokens[j][0]) === 'TERMINATOR' || ref6 === 'INDENT' || ref6 === '=' || ref6 === '(') {
            break;
          }
        }
        if (needsOpen) {
          // Find where to insert the opening brace
          insertIdx = i - 1;
          // Move back past the key
          while (insertIdx > 0 && ((ref7 = tokens[insertIdx - 1][0]) !== 'TERMINATOR' && ref7 !== 'INDENT' && ref7 !== '=' && ref7 !== '(' && ref7 !== ',')) {
            insertIdx -= 1;
          }
          // Insert opening brace
          openBrace = this.generate('{', '{');
          tokens.splice(insertIdx, 0, openBrace);
          stack.push(['OBJECT', insertIdx]);
          // Find where to close
          endIdx = this.detectEnd(i + 2, function(t) { // +2 because we inserted one token
            var ref8;
            return (ref8 = t[0]) === 'TERMINATOR' || ref8 === 'OUTDENT' || ref8 === ')' || ref8 === ']' || ref8 === '}';
          }, function(t, j) {
            return j;
          });
          // Insert closing brace
          closeBrace = this.generate('}', '}');
          tokens.splice(endIdx, 0, closeBrace);
          return 2;
        }
      }
      // Close implicit calls/objects when appropriate
      if (stack.length > 0 && (ref8 = token[0], indexOf.call(IMPLICIT_END, ref8) >= 0)) {
        while (stack.length > 0) {
          [type, startIdx] = stack[stack.length - 1];
          // Check if we should close this level
          if (type === 'CALL') {
            // Already handled by insertion above
            stack.pop();
          } else if (type === 'OBJECT') {
            // Already handled by insertion above
            stack.pop();
          } else {
            break;
          }
        }
      }
      return 1;
    });
  }

  // Add INDENT/OUTDENT for single-line blocks
  normalizeLines() {
    var SINGLE_LINERS;
    // Tokens that should have blocks after them
    SINGLE_LINERS = ['ELSE', '->', '=>', 'TRY', 'FINALLY', 'THEN', 'CATCH'];
    return this.scanTokens((token, i, tokens) => {
      var endIdx, indent, next, outdent, ref, ref1, ref2;
      if (ref = token[0], indexOf.call(SINGLE_LINERS, ref) < 0) {
        return 1;
      }
      next = tokens[i + 1];
      if (!next || ((ref1 = next[0]) === 'INDENT' || ref1 === 'TERMINATOR' || ref1 === 'OUTDENT')) {
        // Skip if already has indent or is end of line
        return 1;
      }
      if (token[0] === 'ELSE' && next[0] === 'IF') {
        // Special case: ELSE IF should not get wrapped
        return 1;
      }
      // Insert INDENT after this token
      indent = this.generate('INDENT', 2);
      tokens.splice(i + 1, 0, indent);
      // Find where to OUTDENT
      endIdx = this.detectEnd(i + 2, function(t) {
        var ref2;
        return (ref2 = t[0]) === 'TERMINATOR' || ref2 === 'OUTDENT' || ref2 === 'ELSE' || ref2 === 'CATCH' || ref2 === 'FINALLY';
      }, function(t, j) {
        return j;
      });
      // Insert OUTDENT
      outdent = this.generate('OUTDENT', 2);
      if (((ref2 = tokens[endIdx - 1]) != null ? ref2[0] : void 0) === 'TERMINATOR') {
        // Insert before the terminator
        tokens.splice(endIdx - 1, 0, outdent);
      } else {
        tokens.splice(endIdx, 0, outdent);
      }
      return 2;
    });
  }

};

export default Rewriter;

export {
  Rewriter
};
