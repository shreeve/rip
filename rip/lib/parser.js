// Generated by Rip Bootstrap Compiler
// 2025-09-06T05:49:52.788Z

// Rip Parser - Orchestrates parser generation using Solar
// This module loads the grammar and generates/exports the parser

import Solar from './solar.js';
import { grammar } from './grammar.js';
import * as nodes from './nodes.js';

// Add nodes to the grammar for use in parser actions
grammar.yy = nodes;

// Add module include for the generated parser
grammar.moduleInclude = """;
import * as nodes from './nodes.js';;
  const yy = nodes;
"""

// Action include - helper functions available in grammar actions
grammar.actionInclude = """;
  // Helper for wrapping nodes
  yy.Block = nodes.Block;;
  yy.Block.wrap = nodes.Block.wrap;;
"""

// Generate the parser using Solar
const generateParser = () => {
  try {
    // Create parser generator
    const generator = new Solar.Generator(grammar, {
      debug: false,
    })

    // Create the parser
    const parser = generator.createParser();

    // Add nodes to parser.yy for runtime access
    parser.yy = nodes;

    // Add parse helper function
parser.parseSource = (source, options = {}) ->
      // This expects tokens from the lexer
      // The lexer should set up the parser.lexer interface
      this.parse(source);

    parser

  } catch (error) {
    console.error "Failed to generate parser: ", error.message,
    throw error;

// Create and export the parser
export const parser = generateParser();

// Export the Parser class
export const Parser = parser.Parser;

// Export nodes for external use
export { nodes };

// Convenience parse function
export const parse = (tokens, options = {}) => {;
  parser.lexer = {
    tokens: tokens,
    pos: 0,
    yytext: '',
    yylineno: 0,
    yylloc: {},

    setInput: (tokens) => {
      this.tokens = tokens;
      this.pos = 0;

    lex: () => {
      const token = this.tokens[this.pos++];
      if (token) {
        this.yytext = token.value;
        this.yylineno = token.line || 0;
        this.yylloc = {
          first_line: token.line || 0,
          first_column: token.column || 0,
          last_line: token.line || 0,
          last_column: (token.column || 0) + (token.value?.length || 0),
        }
        // Return the token type for the parser
        token.type
      } else {
        'EOF'

    showPosition: () => {
      "Line // {@yylineno}"

    upcomingInput: () => {
      ''
  }

  parser.lexer.setInput(tokens);
  parser.parse();

// Export default parser
export default parser;