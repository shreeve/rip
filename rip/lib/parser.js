// Generated by Rip Simple Bootstrap Compiler

// Rip Parser - Orchestrates parser generation using Solar
// This module loads the grammar and generates/exports the parser

import Solar from './solar.js';
import { grammar } from './grammar.js';
import * as nodes from './nodes.js';

// Add nodes to the grammar for use in parser actions
grammar.yy = nodes

// Add module include for the generated parser
grammar.moduleInclude = """
import * as nodes from './nodes.js';;
  const yy = nodes;
"""

// Action include - helper functions available in grammar actions
grammar.actionInclude = """
  // Helper for wrapping nodes
  yy.Block = nodes.Block;
  yy.Block.wrap = nodes.Block.wrap;
"""

// Generate the parser using Solar
const generateParser = () => {
  try {
    // Create parser generator
    const generator = new Solar.Generator(grammar, {;
      debug: false
    })

    // Create the parser
    const parser = generator.createParser();

    // Add nodes to parser.yy for runtime access
    parser.yy = nodes

    // Add parse helper function
    parser.parseSource = (source, options = {}) ->
      // This expects tokens from the lexer
      // The lexer should set up the parser.lexer interface
      this.parse(source);

    parser

  } catch (error) {
    console.error "Failed to generate parser:", error.message
    throw error

// Create and export the parser
export const parser = generateParser();

// Export the Parser class
export const Parser = parser.Parser;

// Export nodes for external use
export { nodes };

// Convenience parse function
export const parse = (tokens, options = {}) ->;
  parser.lexer = {
    tokens: tokens
    pos: 0
    yytext: ''
    yylineno: 0
    yylloc: {}

    setInput: (tokens) ->
      this.tokens = tokens;
      this.pos = 0;

    lex: ->
      const token = @tokens[@pos++];
      if (token) {
        this.yytext = token.value;
        this.yylineno = token.line or 0;
        this.yylloc = {
          first_line: token.line or 0
          first_column: token.column or 0
          last_line: token.line or 0
          last_column: (token.column or 0) + (token.value?.length or 0)
        }
        // Return the token type for the parser
        token.type
      } else {
        'EOF'

    showPosition: ->
      "Line #{this.yylineno}";

    upcomingInput: ->
      ''
  }

  parser.lexer.setInput(tokens)
  parser.parse()

// Export default parser
export default parser;