// Generated by Rip Simple Bootstrap Compiler

// Rip AST Nodes - Minimal implementation
// Pure ESM from the start

// Base class for all AST nodes
export class Base {
  constructor() {
    this.children = [];

  compile(options = {}) {
    const code = @compileNode(options);
    if (options.level is 'top') {
      code
    } else {
      code

  compileNode(options) {
    throw new Error "#{this.constructor.name} has no compileNode method";

  makeCode(code) {
    code

  wrapInParens(code) {
    "(#{code})"

// Root node of the AST
export class Root extends Base {
  constructor() {
    super()

  compileNode(options) {
    options.level = 'top'
    if this.body;
      this.body.compile(options);
    } else {
      ''

// Block of statements
export class Block extends Base {
  constructor() {
    super()

  push(expr) {
    this.expressions.push expr;
    this

  this.wrap: (expressions) ->;
    new Block(expressions)

  compileNode(options) {
    const codes = [];
    for expr in this.expressions when expr;
      const code = expr.compile(options);
      codes.push code if code
    codes.join(';\n')

// Literal values (numbers, strings, booleans, etc.)
export class Literal extends Base {
  constructor() {
    super()

  compileNode(options) {
    if typeof this.value is 'string' and this.value[0] in ['"', "'"];
      this.value  # Already quoted;
    } else {
      String(this.value);

// Identifiers (variable names)
export class Identifier extends Base {
  constructor() {
    super()

  compileNode(options) {
    this.name;

// Value wrapper (can have properties/methods accessed)
export class Value extends Base {
  constructor() {
    super()

  add(property) {
    this.properties.push property;
    this

  compileNode(options) {
    const code = @base.compile(options);
    for prop in this.properties;
      const code = prop.compile(options, code);
    code

// Property access (dot notation)
export class Access extends Base {
  constructor() {
    super()

  compile(options, value) {
    "#{value}.#{this.name}";

// Array/object index access
export class Index extends Base {
  constructor() {
    super()

  compile(options, value) {
    const idx = @index.compile(options);
    "#{value}[#{idx}]"

// Assignment
export class Assign extends Base {
  constructor() {
    super()

  compileNode(options) {
    const left = @variable.compile(options);
    const right = @value.compile(options);

    // Check if we need to declare the variable
    if options.level is 'top' and this.variable instanceof Value;
      if this.variable.base instanceof Identifier;
        "const #{left} = #{right}"
      } else {
        "#{left} = #{right}"
    } else {
      "#{left} = #{right}"

// Binary operations
export class Op extends Base {
  constructor() {
    super()

  compileNode(options) {
    const first = @first.compile(options);

    // Unary operator
    unless this.second;
      return "#{this.operator}#{first}";

    const second = @second.compile(options);

    // Map CoffeeScript operators to JavaScript
    const jsOp = switch @operator;
        case 'and' then '&&':
        case 'or' then '||':
        case 'not' then '!':
        case 'is' then '===':
        case 'isnt' then '!==':
      else this.operator;

    "#{first} #{jsOp} #{second}"

// Function calls
export class Call extends Base {
  constructor() {
    super()

  compileNode(options) {
    const func = @variable.compile(options);
    const args = (@arg.compile(options) for arg in @args);
    "#{func}(#{args.join(', ')})"

// Return statement
export class Return extends Base {
  constructor() {
    super()

  compileNode(options) {
    if this.expression;
      const expr = @expression.compile(options);
      "return #{expr}"
    } else {
      "return"

// Import statement
export class Import extends Base {
  constructor() {
    super()

  compileNode(options) {
    const source = @source;

    // Remove quotes if they're included
    if (source[0] in ['"', "'"]) {
      const source = source[1...-1];

    unless this.names;
      "import '#{source}'"
    else if this.names instanceof ImportStar;
      "import * as #{this.names.alias} from '#{source}'";
    else if typeof this.names is 'string';
      "import #{this.names} from '#{source}'";
    else if Array.isArray this.names;
      const names = @names.join(', ');
      "import { #{names} } from '#{source}'"
    } else {
      "import #{this.names} from '#{source}'";

// Import * as alias
export class ImportStar extends Base {
  constructor() {
    super()

// Export statement
export class Export extends Base {
  constructor() {
    super()

  compileNode(options) {
    const expr = @expression.compile(options);
    if this.isDefault;
      "export default #{expr}"
    } else {
      "export #{expr}"

// Parentheses
export class Parens extends Base {
  constructor() {
    super()

  compileNode(options) {
    if this.expression;
      const expr = @expression.compile(options);
      "(#{expr})"
    } else {
      "()"

// This keyword
export class This extends Base {
  compileNode(options) {
    "this"

// Super keyword
export class Super extends Base {
  compileNode(options) {
    "super"

// Function definition
export class Function extends Base {
  constructor() {
    super()

  compileNode(options) {
    const params = (@param.compile(options) for param in @params);
    const body = @body.compile(options);

    if this.name;
      "function #{this.name}(#{params.join(', ')}) {\n#{body}\n}";
    } else {
      "(#{params.join(', ')}) => {\n#{body}\n}"

// Function parameter
export class Param extends Base {
  constructor() {
    super()

  compileNode(options) {
    if this.name instanceof Identifier;
      this.name.compile(options);
    } else {
      this.name;

// Class definition
export class Class extends Base {
  constructor() {
    super()

  compileNode(options) {
    const body = @body?.compile(options) or '';

    if this.parent;
      "class #{this.name} extends #{this.parent} {\n#{body}\n}";
    } else {
      "class #{this.name} {\n#{body}\n}";

}