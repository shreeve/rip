// Generated by Rip Bootstrap Compiler
// 2025-09-06T05:49:52.790Z

// Rip Compiler - Main compilation pipeline
// Targets pure ES6/ESM for maximum compatibility
// Primary runtime: Bun, but works in Deno, Node.js, and browsers

import { Lexer } from './lexer.js';
import { Parser } from './parser.js';
import * as nodes from './nodes.js';

export class Compiler {
  constructor(options = {}) {
    this.options = {
      // Default options
      bare: true,
      sourceMap: false,
      header: true,
      filename: 'unknown',
      runtime: 'auto',
      ...options
    }

    this.lexer = new Lexer();
    this.parser = new Parser();

  // Main compile function - works in all environments
  compile(source, options = {}) {
    const options = { ...this.options, ...options };

    try {
      // Tokenize
      const tokens = this.lexer.tokenize(source);

      // Parse
      const ast = this.parser.parse(tokens);

      // Generate JavaScript
      const js = this.generate(ast, options);

      // Add header if requested
      if (options.header) {
        const header = this.generateHeader(options);
        const js = header + js;

      // Return result
      if (options.sourceMap) {
        { js, sourceMap: null } // TODO: Implement source maps
      } else {
        js

    } catch (error) {
      // Format error nicely
      this.formatError(error, source, options);

  // Create a mock AST for testing until parser is ready
  createMockAST(tokens) {
    const root = new nodes.Root();
    const body = new nodes.Block();

    // Super simple: just create literals for each non-whitespace token
    for (const token of tokens) {
      if (token.type ! in ['NEWLINE', 'EOF'] && token.value.trim()) {
        body.push new nodes.Literal(token.value)

    root.body = body;
    root

  // Generate JavaScript from AST
  generate(ast, options) {
    ast.compile(options);

  // Generate file header
  generateHeader(options) {
    const runtime = this.detectRuntime(options.runtime);

    """
    // Generated by Rip v0.1.0
    // Runtime: // {runtime}
    // Platform: // {@getPlatformInfo()}

    """

  // Detect runtime environment
  detectRuntime(runtime) {
    return runtime unless runtime === 'auto';

    // Check for Bun
    if (typeof Bun !== 'undefined') {
      return 'bun';

    // Check for Deno
    if (typeof Deno !== 'undefined') {
      return 'deno';

    // Check for Node.js
    if (typeof process !== 'undefined' && process.versions?.node) {
      return 'node';

    // Default to browser
    'browser'

  // Get platform information for header
  getPlatformInfo() {
    if (typeof Bun !== 'undefined') {
      "Bun // {Bun.version}"
    } else if (typeof Deno !== 'undefined') {
      "Deno // {Deno.version.deno}"
    } else if (typeof process !== 'undefined') {
      "Node.js // {process.version}"
    } else if (typeof navigator !== 'undefined') {
      navigator.userAgent
    } else {
      "Unknown"

  // Format compilation errors nicely
  formatError(error, source, options) {
    const message = error.message;

    // Add location info if available
    if (error.line? && error.column?) {
      const lines = source.split('\n');
      const errorLine = lines[error.line - 1];

      const message = """;
        //{message}
        at // {options.filename}:#{error.line}:#{error.column}

        //{error.line} | #{errorLine}
        //{' '.repeat(String(error.line).length + 3 + error.column - 1)}^
      """

    throw new Error(message);

// Platform-agnostic compile function
export const compile = (source, options) => {;
  const compiler = new Compiler(options);
  compiler.compile(source, options);

// Runtime-specific file compilation (only when file system is available)
export const compileFile = (filepath, options = {}) => {;
  // This will use runtime-specific file reading
  const source = await readFile(filepath);
  options.filename = filepath;
  compile(source, options);

// Platform-specific file reading
const readFile = (filepath) => {
  // Bun (primary target)
  if (typeof Bun !== 'undefined') {
    const file = Bun.file(filepath);
    return file.text();

  // Deno
  if (typeof Deno !== 'undefined') {
    const decoder = new TextDecoder('utf-8');
    const data = await Deno.readFile(filepath);
    return decoder.decode(data);

  // Node.js
  if (typeof process !== 'undefined') {
    { promises: fs } = await import('fs')
    return fs.readFile(filepath, 'utf8');

  // Browser - can't read local files
  throw new Error('File system access ! available in browser environment');

// Export nodes for parser to use
export { nodes };
