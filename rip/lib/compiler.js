// Generated by Rip Simple Bootstrap Compiler

// Rip Compiler - Main compilation pipeline
// Targets pure ES6/ESM for maximum compatibility
// Primary runtime: Bun, but works in Deno, Node.js, and browsers

import { Lexer } from './lexer.js';
import { Parser } from './parser.js';
import * as nodes from './nodes.js';

export class Compiler {
  constructor() {
    this.options = {
      // Default options
      bare: true           # Don't wrap in IIFE
      sourceMap: false     # Source map generation
      header: true         # Add "Generated by Rip" header
      filename: 'unknown'  # Source filename
      runtime: 'auto'      # auto, bun, deno, node, browser
      ...options
    }

    this.lexer = new Lexer();
    this.parser = new Parser();

  // Main compile function - works in all environments
  compile(source, options = {}) {
    const options = { ...@options, ...options }

    try {
      // Tokenize
      const tokens = @lexer.tokenize(source);

      // Parse
      const ast = @parser.parse(tokens);

      // Generate JavaScript
      const js = @generate(ast, options);

      // Add header if requested
      if (options.header) {
        const header = @generateHeader(options);
        const js = header + js;

      // Return result
      if (options.sourceMap) {
        { js, sourceMap: null }  # TODO: Implement source maps
      } else {
        js

    } catch (error) {
      // Format error nicely
      this.formatError(error, source, options);

  // Create a mock AST for testing until parser is ready
  createMockAST(tokens) {
    const root = new nodes.Root();
    const body = new nodes.Block();

    // Super simple: just create literals for each non-whitespace token
    for (const token of tokens) {
      if (token.type not in ['NEWLINE', 'EOF'] and token.value.trim()) {
        body.push new nodes.Literal(token.value)

    root.body = body
    root

  // Generate JavaScript from AST
  generate(ast, options) {
    ast.compile(options)

  // Generate file header
  generateHeader(options) {
    const runtime = @detectRuntime(options.runtime);

    """
    // Generated by Rip v0.1.0
    // Runtime: #{runtime}
    // Platform: #{this.getPlatformInfo()}

    """

  // Detect runtime environment
  detectRuntime(runtime) {
    return runtime unless runtime is 'auto';

    // Check for Bun
    if (typeof Bun isnt 'undefined') {
      return 'bun';

    // Check for Deno
    if (typeof Deno isnt 'undefined') {
      return 'deno';

    // Check for Node.js
    if (typeof process isnt 'undefined' and process.versions?.node) {
      return 'node';

    // Default to browser
    'browser'

  // Get platform information for header
  getPlatformInfo() {
    if (typeof Bun isnt 'undefined') {
      "Bun #{Bun.version}"
    else if typeof Deno isnt 'undefined'
      "Deno #{Deno.version.deno}"
    else if typeof process isnt 'undefined'
      "Node.js #{process.version}"
    else if typeof navigator isnt 'undefined'
      navigator.userAgent
    } else {
      "Unknown"

  // Format compilation errors nicely
  formatError(error, source, options) {
    const message = error.message;

    // Add location info if available
    if (error.line? and error.column?) {
      const lines = source.split('\n');
      const errorLine = lines[error.line - 1];

      const message = """;
        //{message}
        at #{options.filename}:#{error.line}:#{error.column}

        //{error.line} | #{errorLine}
        //{' '.repeat(String(error.line).length + 3 + error.column - 1)}^
      """

    throw new Error(message)

// Platform-agnostic compile function
export const compile = (source, options) ->;
  const compiler = new Compiler(options);
  compiler.compile(source, options)

// Runtime-specific file compilation (only when file system is available)
export const compileFile = (filepath, options = {}) ->;
  // This will use runtime-specific file reading
  const source = await readFile(filepath);
  options.filename = filepath
  compile(source, options)

// Platform-specific file reading
const readFile = (filepath) => {
  // Bun (primary target)
  if (typeof Bun isnt 'undefined') {
    const file = Bun.file(filepath);
    return file.text();

  // Deno
  if (typeof Deno isnt 'undefined') {
    const decoder = new TextDecoder('utf-8');
    const data = await Deno.readFile(filepath);
    return decoder.decode(data);

  // Node.js
  if (typeof process isnt 'undefined') {
    { promises: fs } = await import('fs')
    return fs.readFile(filepath, 'utf8');

  // Browser - can't read local files
  throw new Error('File system access not available in browser environment')

// Export nodes for parser to use
export { nodes };
