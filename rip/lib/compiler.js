// Generated by CoffeeScript 2.7.0
// Minimal Rip Compiler
// Transforms our simple object AST to JavaScript
const Compiler = class Compiler {
  constructor() {
    this.indent = 0;
    this.code = [];
  }

  // Main compile function
  compile(ast) {
    var result;
    this.code = [];
    this.indent = 0;
    result = this.node(ast);
    return result;
  }

  // Compile any node based on its type
  node(n) {
    if (n == null) {
      return '';
    }
    switch (n.type) {
      // Literals
      case 'num':
        return n.val;
      case 'str':
        return this.string(n.val);
      case 'bool':
        return n.val;
      case 'null':
        return 'null';
      case 'undef':
        return 'undefined';
      case 'id':
        return n.name;
      case 'prop':
        return this.prop(n);
      case 'index':
        return this.index(n);
      // Operations
      case 'op':
        return this.op(n);
      case 'unary':
        return this.unary(n);
      case 'assign':
        return this.assign(n);
      // Functions
      case 'func':
        return this.func(n);
      case 'call':
        return this.call(n);
      case 'return':
        return this.return(n);
      // Control flow
      case 'if':
        return this.if(n);
      case 'while':
        return this.while(n);
      case 'for':
        return this.for(n);
      // Collections
      case 'array':
        return this.array(n);
      case 'object':
        return this.object(n);
      case 'access':
        return this.access(n);
      // Structure
      case 'block':
        return this.block(n);
      case 'root':
        return this.root(n);
      case 'stmt':
        return this.stmt(n);
      default:
        console.warn(`Unknown node type: ${n.type}`);
        return '';
    }
  }

  // String with proper escaping
  string(val) {
    // Handle quote style
    if (val.indexOf('"') >= 0 && val.indexOf("'") < 0) {
      return `'${val}'`;
    } else {
      return `\"${val.replace(/"/g, '\\"')}\"`;
    }
  }

  // Binary operations
  op(n) {
    var left, right;
    left = this.node(n.left);
    right = this.node(n.right);
    // Special cases
    switch (n.op) {
      case '**':
        return `Math.pow(${left}, ${right})`;
      case '//':
        return `Math.floor(${left} / ${right})`;
      case 'in':
        return `(${right}).includes(${left})`;
      case 'of':
        return `(${left} in ${right})`;
      case 'is':
        return `${left} === ${right}`;
      case 'isnt':
        return `${left} !== ${right}`;
      default:
        return `(${left} ${n.op} ${right})`;
    }
  }

  // Unary operations
  unary(n) {
    var expr;
    expr = this.node(n.expr);
    switch (n.op) {
      case 'not':
        return `!${expr}`;
      case 'typeof':
        return `typeof ${expr}`;
      default:
        return `${n.op}${expr}`;
    }
  }

  // Assignment
  assign(n) {
    var op, target, value;
    target = this.node(n.target);
    value = this.node(n.value);
    op = n.op || '=';
    // Add 'let' for first assignment (simple heuristic)
    if (op === '=' && n.target.type === 'id') {
      return `let ${target} = ${value}`;
    } else {
      return `${target} ${op} ${value}`;
    }
  }

  // Function definition
  func(n) {
    var body, params, ref;
    params = ((ref = n.params) != null ? ref.map((p) => {
      return this.node(p);
    }).join(', ') : void 0) || '';
    body = this.node(n.body);
    // Arrow function
    if (n.arrow) {
      if (n.body.type === 'block') {
        return `(${params}) => ${body}`;
      } else {
        return `(${params}) => ${body}`;
      }
    } else {
      // Regular function
      return `function(${params}) ${body}`;
    }
  }

  // Function call
  call(n) {
    var args, func, ref;
    func = this.node(n.func);
    args = ((ref = n.args) != null ? ref.map((a) => {
      return this.node(a);
    }).join(', ') : void 0) || '';
    return `${func}(${args})`;
  }

  // Property access
  prop(n) {
    var obj, propName;
    obj = this.node(n.obj);
    // prop is a node with type 'id' containing the name
    propName = n.prop.name;
    if (n.optional) {
      return `${obj}?.${propName}`;
    } else {
      return `${obj}.${propName}`;
    }
  }

  // Index access
  index(n) {
    var idx, obj;
    obj = this.node(n.obj);
    idx = this.node(n.index);
    if (n.optional) {
      return `${obj}?.[${idx}]`;
    } else {
      return `${obj}[${idx}]`;
    }
  }

  // Return statement
  return(n) {
    if (n.expr) {
      return `return ${this.node(n.expr)}`;
    } else {
      return "return";
    }
  }

  // If statement
  if(n) {
    var code, cond, else_, ref, then_;
    cond = this.node(n.cond);
    then_ = this.node(n.then);
    else_ = n.else ? this.node(n.else) : null;
    // Ternary for simple expressions
    if (n.expr && !((ref = n.else) != null ? ref.type : void 0) === 'if') {
      if (else_) {
        return `(${cond} ? ${then_} : ${else_})`;
      } else {
        return `(${cond} && ${then_})`;
      }
    } else {
      // Full if statement
      code = `if (${cond}) ${then_}`;
      if (else_) {
        code += ` else ${else_}`;
      }
      return code;
    }
  }

  // While loop
  while(n) {
    var body, cond;
    cond = this.node(n.cond);
    body = this.node(n.body);
    return `while (${cond}) ${body}`;
  }

  // For loop (simplified)
  for(n) {
    var body, iter, var_;
    // Handle for..in and for..of
    if (n.var && n.iterable) {
      var_ = this.node(n.var);
      iter = this.node(n.iterable);
      body = this.node(n.body);
      if (n.own) { // for own key of object
        return `for (const ${var_} in ${iter}) if (${iter}.hasOwnProperty(${var_})) ${body}`;
      } else if (n.of) {
        return `for (const ${var_} of ${iter}) ${body}`;
      } else {
        return `for (const ${var_} in ${iter}) ${body}`;
      }
    } else {
      // C-style for loop
      return `for (${this.node(n.init)}; ${this.node(n.cond)}; ${this.node(n.update)}) ${this.node(n.body)}`;
    }
  }

  // Array literal
  array(n) {
    var items, ref;
    items = ((ref = n.items) != null ? ref.map((i) => {
      return this.node(i);
    }).join(', ') : void 0) || '';
    return `[${items}]`;
  }

  // Object literal
  object(n) {
    var pairs, ref;
    pairs = ((ref = n.pairs) != null ? ref.map((p) => {
      var key, val;
      key = p.key.type === 'str' ? p.key.val : this.node(p.key);
      val = this.node(p.value);
      return `${key}: ${val}`;
    }).join(', ') : void 0) || '';
    return `{${pairs}}`;
  }

  // Property/index access
  access(n) {
    var obj, prop;
    obj = this.node(n.object);
    if (n.computed) {
      // obj[prop]
      prop = this.node(n.property);
      return `${obj}[${prop}]`;
    } else {
      // obj.prop
      prop = this.node(n.property);
      return `${obj}${prop}`;
    }
  }

  // Statement (adds semicolon if needed)
  stmt(n) {
    var code;
    code = this.node(n.expr);
    if (code && !code.match(/[{}]$/)) {
      return `${code};`;
    } else {
      return code;
    }
  }

  // Block of statements
  block(n) {
    var stmts;
    if (!n.stmts || n.stmts.length === 0) {
      return '{}';
    } else {
      stmts = n.stmts.map((s) => {
        return this.stmt(s);
      }).filter(function(s) {
        return s;
      }).join('\n');
      return `{\n${this.indented(stmts)}\n}`;
    }
  }

  // Root/program
  root(n) {
    var ref, stmts;
    // Each statement is directly a node, not wrapped in stmt
    stmts = ((ref = n.stmts) != null ? ref.map((s) => {
      var code;
      code = this.node(s);
      // Add semicolon if needed
      if (code && !code.match(/[{}]$/)) {
        return `${code};`;
      } else {
        return code;
      }
    }).filter(function(s) {
      return s;
    }).join('\n') : void 0) || '';
    return stmts;
  }

  // Helper for indentation
  indented(code) {
    return code.split('\n').map(function(line) {
      return '  ' + line;
    }).join('\n');
  }

};

export default Compiler;

export {
  Compiler
};
