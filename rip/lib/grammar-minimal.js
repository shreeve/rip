// Generated by CoffeeScript 2.7.0
// Minimal Rip Grammar for Solar Parser Generator
// Start with just enough to write real programs

// Helper function for creating grammar rules




// The grammar object that Solar expects  
const grammar = {
  
  // Parser options
  options: {
    debug: false
  },
  
  // Operator precedence (simplified from CoffeeScript)
  operators: [["right", "="], ["left", "or", "||"], ["left", "and", "&&"], ["left", "==", "!=", "is", "isnt"], ["left", "<", ">", "<=", ">="], ["left", "+", "-"], ["left", "*", "/", "%"], ["right", "!"], ["left", "."], ["left", "CALL"]],
  
  // Minimal BNF grammar rules
  bnf: {
    
    // Program root
    Root: [["", "-> new yy.Root(new yy.Block())"], ["Body", "-> new yy.Root($1)"]],
    
    // Body is a list of lines
    Body: [["Line", "-> yy.Block.wrap([$1])"], ["Body TERMINATOR Line", "-> $1.push($3)"], ["Body TERMINATOR", "-> $1"]],
    
    // Lines can be expressions or statements
    Line: [["Expression"], ["Statement"]],
    
    // Basic statements
    Statement: [["Return"], ["Import"], ["Export"]],
    
    // Expressions
    Expression: [["Value"], ["Assign"], ["Operation"], ["Code"], ["If"]],
    
    // Values
    Value: [["Assignable"], ["Literal", "-> new yy.Value($1)"], ["Parenthetical"], ["Range"], ["This"], ["Invocation", "-> new yy.Value($1)"]],
    
    // Literals
    Literal: [["NUMBER", "-> new yy.NumberLiteral($1)"], ["STRING", "-> new yy.StringLiteral($1)"], ["BOOL", "-> new yy.BooleanLiteral($1)"], ["NULL", "-> new yy.NullLiteral()"], ["UNDEFINED", "-> new yy.UndefinedLiteral()"]],
    
    // Identifiers
    Identifier: [["IDENTIFIER", "-> new yy.IdentifierLiteral($1)"]],
    
    // Assignable (can be on left side of =)
    Assignable: [["Identifier", "-> new yy.Value($1)"], ["Value . Property", "-> $1.add(new yy.Access($3))"], ["Value [ Expression ]", "-> $1.add(new yy.Index($3))"], ["ThisProperty"]],
    
    // Property access
    Property: [["PROPERTY", "-> new yy.PropertyName($1)"]],
    
    // Assignment
    Assign: [["Assignable = Expression", "-> new yy.Assign($1, $3)"], ["Assignable = TERMINATOR Expression", "-> new yy.Assign($1, $4)"], ["Assignable = INDENT Expression OUTDENT", "-> new yy.Assign($1, $4)"]],
    
    // Function invocation
    Invocation: [["Value Arguments", "-> new yy.Call($1, $2)"], ["Invocation Arguments", "-> new yy.Call($1, $2)"], ["SUPER Arguments", "-> new yy.SuperCall($2)"]],
    
    // Arguments
    Arguments: [["( )", "-> []"], ["( ArgList )", "-> $2"]],
    
    // Argument list
    ArgList: [["Arg", "-> [$1]"], ["ArgList , Arg", "-> $1.concat($3)"]],
    Arg: [["Expression"], ["Splat"]],
    
    // Splat operator
    Splat: [["Expression ...", "-> new yy.Splat($1)"]],
    
    // Code (functions)
    Code: [["-> Block", "-> new yy.Code([], $2)"], ["=> Block", "-> new yy.Code([], $2, '=>')"], ["( ParamList ) -> Block", "-> new yy.Code($2, $5)"], ["( ParamList ) => Block", "-> new yy.Code($2, $5, '=>')"]],
    
    // Parameters
    ParamList: [["", "-> []"], ["Param", "-> [$1]"], ["ParamList , Param", "-> $1.concat($3)"]],
    Param: [["Identifier", "-> new yy.Param($1)"], ["Identifier = Expression", "-> new yy.Param($1, $3)"], ["Identifier ...", "-> new yy.Param($1, null, true)"]],
    
    // Blocks
    Block: [["INDENT Body OUTDENT", "-> $2"], ["Expression", "-> yy.Block.wrap([$1])"]],
    
    // Operations
    Operation: [["Expression + Expression", "-> new yy.Op('+', $1, $3)"], ["Expression - Expression", "-> new yy.Op('-', $1, $3)"], ["Expression * Expression", "-> new yy.Op('*', $1, $3)"], ["Expression / Expression", "-> new yy.Op('/', $1, $3)"], ["Expression % Expression", "-> new yy.Op('%', $1, $3)"], ["Expression == Expression", "-> new yy.Op('==', $1, $3)"], ["Expression != Expression", "-> new yy.Op('!=', $1, $3)"], ["Expression < Expression", "-> new yy.Op('<', $1, $3)"], ["Expression > Expression", "-> new yy.Op('>', $1, $3)"], ["Expression <= Expression", "-> new yy.Op('<=', $1, $3)"], ["Expression >= Expression", "-> new yy.Op('>=', $1, $3)"], ["Expression and Expression", "-> new yy.Op('&&', $1, $3)"], ["Expression or Expression", "-> new yy.Op('||', $1, $3)"], ["Expression is Expression", "-> new yy.Op('==', $1, $3)"], ["Expression isnt Expression", "-> new yy.Op('!=', $1, $3)"], ["! Expression", "-> new yy.Op('!', $2)"], ["not Expression", "-> new yy.Op('!', $2)"]],
    
    // Parenthetical
    Parenthetical: [["( Expression )", "-> new yy.Parens($2)"], ["( INDENT Expression OUTDENT )", "-> new yy.Parens($3)"]],
    
    // Ranges
    Range: [["[ Expression .. Expression ]", "-> new yy.Range($2, $4)"], ["[ Expression ... Expression ]", "-> new yy.Range($2, $4, 'exclusive')"]],
    
    // This
    This: [["THIS", "-> new yy.Value(new yy.ThisLiteral())"], ["@", "-> new yy.Value(new yy.ThisLiteral())"]],
    ThisProperty: [["@ Property", "-> new yy.Value(new yy.ThisLiteral(), [new yy.Access($2)])"]],
    
    // If statement
    If: [["IF Expression Block", "-> new yy.If($2, $3)"], ["IF Expression Block ELSE Block", "-> new yy.If($2, $3, null, {elseBody: $5})"], ["Expression IF Expression", "-> new yy.If($3, yy.Block.wrap([$1]), null, {postfix: true})"], ["Expression UNLESS Expression", "-> new yy.If($3, yy.Block.wrap([$1]), null, {postfix: true, invert: true})"]],
    
    // Return
    Return: [["RETURN Expression", "-> new yy.Return($2)"], ["RETURN", "-> new yy.Return()"]],
    
    // Import
    Import: [["IMPORT STRING", "-> new yy.ImportDeclaration(null, $2)"], ["IMPORT Identifier FROM STRING", "-> new yy.ImportDeclaration(new yy.ImportClause($2), $4)"], ["IMPORT { ImportSpecifierList } FROM STRING", "-> new yy.ImportDeclaration(new yy.ImportClause(null, new yy.ImportSpecifierList($3)), $7)"]],
    ImportSpecifierList: [["ImportSpecifier", "-> [$1]"], ["ImportSpecifierList , ImportSpecifier", "-> $1.concat($3)"]],
    ImportSpecifier: [["Identifier", "-> new yy.ImportSpecifier($1)"], ["Identifier AS Identifier", "-> new yy.ImportSpecifier($1, $3)"]],
    
    // Export
    Export: [["EXPORT Expression", "-> new yy.ExportNamedDeclaration($2)"], ["EXPORT DEFAULT Expression", "-> new yy.ExportDefaultDeclaration($3)"], ["EXPORT { ExportSpecifierList }", "-> new yy.ExportNamedDeclaration(new yy.ExportSpecifierList($3))"]],
    ExportSpecifierList: [["ExportSpecifier", "-> [$1]"], ["ExportSpecifierList , ExportSpecifier", "-> $1.concat($3)"]],
    ExportSpecifier: [["Identifier", "-> new yy.ExportSpecifier($1)"], ["Identifier AS Identifier", "-> new yy.ExportSpecifier($1, $3)"]]
  },
  
  // Start symbol
  start: "Root"
};

export default grammar;
