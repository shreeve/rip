// Generated by CoffeeScript 2.7.0
// Minimal Rip Lexer
// Just enough to tokenize our minimal grammar
const Lexer = class Lexer {
  constructor() {
    this.reset();
  }

  reset() {
    this.tokens = [];
    this.indents = [];
    this.ends = [];
    this.currentIndent = 0;
    this.line = 1;
    this.column = 1;
    this.pos = 0;
    return this.chunk = "";
  }

  tokenize(code) {
    var consumed;
    this.reset();
    this.code = this.clean(code);
    while (this.chunk = this.code.slice(this.pos)) {
      consumed = this.identifierToken() || this.numberToken() || this.stringToken() || this.commentToken() || this.whitespaceToken() || this.lineToken() || this.literalToken();
      this.pos += consumed;
    }
    this.closeIndentation();
    this.tokens.push(["EOF", "", this.line, this.column]);
    return this.tokens;
  }

  // Clean the source code
  clean(code) {
    // Remove carriage returns and trailing spaces
    code = code.replace(/\r/g, "");
    code = code.replace(/\s+$/gm, "");
    if (!code.endsWith("\n")) {
      // Ensure file ends with newline
      code += "\n";
    }
    return code;
  }

  // Match identifiers and keywords
  identifierToken() {
    var match, prev, tag, value, word;
    if (!(match = /^[a-zA-Z_$][a-zA-Z0-9_$]*/.exec(this.chunk))) {
      return 0;
    }
    word = match[0];
    tag = (function() {
      var ref;
      switch (word) {
        // Keywords
        case "if":
          return "IF";
        case "else":
          return "ELSE";
        case "unless":
          return "UNLESS";
        case "return":
          return "RETURN";
        case "import":
          return "IMPORT";
        case "export":
          return "EXPORT";
        case "from":
          return "FROM";
        case "as":
          return "AS";
        case "default":
          return "DEFAULT";
        case "super":
          return "SUPER";
        case "this":
          return "THIS";
        case "class":
          return "CLASS";
        case "extends":
          return "EXTENDS";
        case "new":
          return "NEW";
        case "typeof":
          return "TYPEOF";
        case "instanceof":
          return "INSTANCEOF";
        case "in":
          return "IN";
        case "of":
          return "OF";
        // Boolean literals
        case "true":
        case "yes":
        case "on":
          return "BOOL";
        case "false":
        case "no":
        case "off":
          return "BOOL";
        case "null":
          return "NULL";
        case "undefined":
          return "UNDEFINED";
        // CoffeeScript aliases
        case "and":
          return "and";
        case "or":
          return "or";
        case "not":
          return "not";
        case "is":
          return "is";
        case "isnt":
          return "isnt";
        default:
          // Check if it's a property after dot
          prev = this.tokens[this.tokens.length - 1];
          if (prev && ((ref = prev[0]) === "." || ref === "?.")) {
            return "PROPERTY";
          } else {
            return "IDENTIFIER";
          }
      }
    }).call(this);
    // For boolean literals, normalize the value
    value = tag === "BOOL" ? word === "true" || word === "yes" || word === "on" ? "true" : "false" : word;
    this.token(tag, value);
    return word.length;
  }

  // Match numbers
  numberToken() {
    var match;
    if (!(match = /^(0b[01]+|0o[0-7]+|0x[\da-fA-F]+|\d+(\.\d+)?([eE][+-]?\d+)?)/.exec(this.chunk))) {
      return 0;
    }
    this.token("NUMBER", match[0]);
    return match[0].length;
  }

  // Match strings (single and double quotes)
  stringToken() {
    var content, match, quote, regex;
    if (!(match = /^(['"])/.exec(this.chunk))) {
      return 0;
    }
    quote = match[0];
    regex = quote === "'" ? /^'([^'\\]|\\.)*'/ : /^"([^"\\]|\\.)*"/;
    if (!(match = regex.exec(this.chunk))) {
      return 0;
    }
    // Extract string content without quotes
    content = match[0].slice(1, -1);
    // Basic escape sequence handling
    content = content.replace(/\\n/g, "\n");
    content = content.replace(/\\t/g, "\t");
    content = content.replace(/\\r/g, "\r");
    content = content.replace(/\\\\/g, "\\");
    content = content.replace(/\\'/g, "'");
    content = content.replace(/\\"/g, '"');
    this.token("STRING", '"' + content + '"');
    return match[0].length;
  }

  // Match comments
  commentToken() {
    var lines, match;
    // Single line comment
    if (match = /^#[^\n]*/.exec(this.chunk)) {
      // Skip comment, don't create token
      return match[0].length;
    }
    // Block comment
    if (match = /^###([\s\S]*?)###/.exec(this.chunk)) {
      // Skip comment, don't create token
      lines = match[0].split("\n").length - 1;
      this.line += lines;
      return match[0].length;
    }
    return 0;
  }

  // Match whitespace (but not newlines)
  whitespaceToken() {
    var match;
    if (!(match = /^[ \t]+/.exec(this.chunk))) {
      return 0;
    }
    // Mark previous token as spaced
    if (this.tokens.length > 0) {
      this.tokens[this.tokens.length - 1].spaced = true;
    }
    this.column += match[0].length;
    return match[0].length;
  }

  // Match newlines and handle indentation
  lineToken() {
    var char, diff, i, indent, lastIndent, len, match, size;
    if (!(match = /^(\n[ \t]*)/.exec(this.chunk))) {
      return 0;
    }
    this.line++;
    indent = match[0].substring(1);
    this.column = indent.length + 1;
    // Calculate indent level (convert tabs to spaces)
    size = 0;
    for (i = 0, len = indent.length; i < len; i++) {
      char = indent[i];
      size += char === "\t" ? 4 : 1;
    }
    // Handle indent changes
    if (size > this.currentIndent) {
      diff = size - this.currentIndent;
      this.currentIndent = size;
      this.indents.push(diff);
      this.token("INDENT", diff);
    } else if (size < this.currentIndent) {
      while (size < this.currentIndent && this.indents.length > 0) {
        lastIndent = this.indents.pop();
        this.currentIndent -= lastIndent;
        this.token("OUTDENT", lastIndent);
      }
      this.token("TERMINATOR", "\n");
    } else {
      this.token("TERMINATOR", "\n");
    }
    return match[0].length;
  }

  // Match literal tokens (operators and punctuation)
  literalToken() {
    var char, match, tag;
    // Two-character operators (including compound assignments)
    if (match = /^(->|=>|==|!=|<=|>=|&&|\|\||\.\.|\.\.\.|[+\-*\/]=)/.exec(this.chunk)) {
      tag = (function() {
        switch (match[0]) {
          case "->":
            return "->";
          case "=>":
            return "=>";
          case "==":
            return "==";
          case "!=":
            return "!=";
          case "<=":
            return "<=";
          case ">=":
            return ">=";
          case "&&":
            return "&&";
          case "||":
            return "||";
          case "..":
            return "..";
          case "...":
            return "...";
          case "+=":
            return "+=";
          case "-=":
            return "-=";
          case "*=":
            return "*=";
          case "/=":
            return "/=";
          default:
            return match[0];
        }
      })();
      this.token(tag, match[0]);
      return match[0].length;
    }
    // Single character tokens
    char = this.chunk[0];
    tag = (function() {
      switch (char) {
        case "(":
          return "(";
        case ")":
          return ")";
        case "[":
          return "[";
        case "]":
          return "]";
        case "{":
          return "{";
        case "}":
          return "}";
        case ",":
          return ",";
        case ".":
          return ".";
        case ":":
          return ":";
        case ";":
          return "TERMINATOR";
        case "+":
          return "+";
        case "-":
          return "-";
        case "*":
          return "*";
        case "/":
          return "/";
        case "%":
          return "%";
        case "=":
          return "=";
        case "<":
          return "<";
        case ">":
          return ">";
        case "!":
          return "!";
        case "@":
          return "@";
        default:
          return null;
      }
    })();
    if (tag) {
      this.token(tag, char);
      return 1;
    }
    // Unknown character
    throw new Error(`Unexpected character '${char}' at line ${this.line}, column ${this.column}`);
  }

  // Close all open indentations at end of file
  closeIndentation() {
    var results;
    results = [];
    while (this.indents.length > 0) {
      this.indents.pop();
      results.push(this.token("OUTDENT", 0));
    }
    return results;
  }

  // Add a token to the stream
  token(tag, value) {
    return this.tokens.push([tag, value, this.line, this.column]);
  }

};



export default Lexer;
export { Lexer };