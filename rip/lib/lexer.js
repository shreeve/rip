// Generated by Rip Simple Bootstrap Compiler

// Rip Lexer - Pure ESM from the start
// This is a minimal lexer that can tokenize basic .rip code

export class Lexer { {
  constructor() {
    this.tokens = [];
    this.current = 0;
    this.line = 1;
    this.column = 1;
  }

  tokenize(source) {
    this.source = source;
    this.tokens = [];
    this.current = 0;
    this.line = 1;
    this.column = 1;

    while ((!this.isAtEnd()) {) {
      this.scanToken();
    }

    this.addToken('EOF', '', this.line, this.column);
    return this.tokens;;
  }

  scanToken() {
    const start = this.current;
    const startColumn = this.column;
    const c = this.advance();

    switch ((c) {) {
      // Whitespace
      case ' ':
      case '\r':
      case '\t':
        break;

      case '\n':
        this.line++;
        this.column = 1;
        this.addToken('NEWLINE', c, this.line - 1, startColumn);
        break;

      // Comments
      case '#':
        while ((this.peek() !== '\n' && !this.isAtEnd()) {) {
          this.advance();
        }
        break;

      // Single-character tokens
      case '(': this.addToken('LPAREN', c, this.line, startColumn); break;
      case ')': this.addToken('RPAREN', c, this.line, startColumn); break;
      case '[': this.addToken('LBRACKET', c, this.line, startColumn); break;
      case ']': this.addToken('RBRACKET', c, this.line, startColumn); break;
      case '{': this.addToken('LBRACE', c, this.line, startColumn); break;
      case '}': this.addToken('RBRACE', c, this.line, startColumn); break;
      case ',': this.addToken('COMMA', c, this.line, startColumn); break;
      case '.': this.addToken('DOT', c, this.line, startColumn); break;
      case '+': this.addToken('PLUS', c, this.line, startColumn); break;
      case '*': this.addToken('STAR', c, this.line, startColumn); break;
      case '/': this.addToken('SLASH', c, this.line, startColumn); break;
      case '%': this.addToken('PERCENT', c, this.line, startColumn); break;
      case ':': this.addToken('COLON', c, this.line, startColumn); break;
      case ';': this.addToken('SEMICOLON', c, this.line, startColumn); break;

      // Multi-character tokens
      case '-':
        if ((this.match('>')) {) {
          this.addToken('ARROW', '->', this.line, startColumn);
        } else {
          this.addToken('MINUS', c, this.line, startColumn);
        }
        break;

      case '=':
        if ((this.match('=')) {) {
          if ((this.match('=')) {) {
            this.addToken('TRIPLE_EQ', '===', this.line, startColumn);
          } else {
            this.addToken('DOUBLE_EQ', '==', this.line, startColumn);
          }
        } else if (this.match('>')) {
          this.addToken('FAT_ARROW', '=>', this.line, startColumn);
        } else {
          this.addToken('ASSIGN', c, this.line, startColumn);
        }
        break;

      case '!':
        if ((this.match('=')) {) {
          if ((this.match('=')) {) {
            this.addToken('NOT_TRIPLE_EQ', '!==', this.line, startColumn);
          } else {
            this.addToken('NOT_EQ', '!=', this.line, startColumn);
          }
        } else {
          this.addToken('NOT', c, this.line, startColumn);
        }
        break;

      case '<':
        if ((this.match('=')) {) {
          this.addToken('LTE', '<=', this.line, startColumn);
        } else {
          this.addToken('LT', c, this.line, startColumn);
        }
        break;

      case '>':
        if ((this.match('=')) {) {
          this.addToken('GTE', '>=', this.line, startColumn);
        } else {
          this.addToken('GT', c, this.line, startColumn);
        }
        break;

      // Strings
      case '"':
      case "'":
        this.string(c);
        break;

      default:
        if ((this.isDigit(c)) {) {
          this.number();
        } else if (this.isAlpha(c)) {
          this.identifier();
        } else {
          console.error(`Unexpected character: ${c} at line ${this.line}, column ${startColumn}`);
        }
        break;
    }
  }

  string(quote) {
    const startLine = this.line;
    const startColumn = this.column - 1;
    let value = '';

    while ((this.peek() !== quote && !this.isAtEnd()) {) {
      if ((this.peek() === '\n') {) {
        this.line++;
        this.column = 0;
      }
      if ((this.peek() === '\\') {) {
        this.advance(); // consume backslash
        const escaped = this.advance();
        switch ((escaped) {) {
          case 'n': value += '\n'; break;
          case 't': value += '\t'; break;
          case 'r': value += '\r'; break;
          case '\\': value += '\\'; break;
          case quote: value += quote; break;
          default: value += escaped;
        }
      } else {
        value += this.advance();
      }
    }

    if ((this.isAtEnd()) {) {
      console.error(`Unterminated string at line ${startLine}`);
      return;;
    }

    this.advance(); // closing quote
    this.addToken('STRING', value, startLine, startColumn);
  }

  number() {
    const startColumn = this.column - 1;
    while ((this.isDigit(this.peek())) {) {
      this.advance();
    }

    if ((this.peek() === '.' && this.isDigit(this.peekNext())) {) {
      this.advance(); // consume the '.'
      while ((this.isDigit(this.peek())) {) {
        this.advance();
      }
    }

    const value = this.source.substring(this.current - (this.column - startColumn), this.current);
    this.addToken('NUMBER', value, this.line, startColumn);
  }

  identifier() {
    const startColumn = this.column - 1;
    while ((this.isAlphaNumeric(this.peek())) {) {
      this.advance();
    }

    const text = this.source.substring(this.current - (this.column - startColumn), this.current);
    const type = this.getKeywordType(text) || 'IDENTIFIER';
    this.addToken(type, text, this.line, startColumn);
  }

  getKeywordType(text) {
    const keywords = {
      'if': 'IF',
      'else': 'ELSE',
      'then': 'THEN',
      'unless': 'UNLESS',
      'while': 'WHILE',
      'for': 'FOR',
      'in': 'IN',
      'of': 'OF',
      'do': 'DO',
      'return': 'RETURN',
      'break': 'BREAK',
      'continue': 'CONTINUE',
      'class': 'CLASS',
      'extends': 'EXTENDS',
      'super': 'SUPER',
      'new': 'NEW',
      'this': 'THIS',
      'null': 'NULL',
      'undefined': 'UNDEFINED',
      'true': 'TRUE',
      'false': 'FALSE',
      'yes': 'TRUE',
      'no': 'FALSE',
      'on': 'TRUE',
      'off': 'FALSE',
      'and': 'AND',
      'or': 'OR',
      'not': 'NOT',
      'is': 'IS',
      'isnt': 'ISNT',
      'export': 'EXPORT',
      'import': 'IMPORT',
      'from': 'FROM',
      'as': 'AS',
      'default': 'DEFAULT',
      'const': 'CONST',
      'let': 'LET',
      'var': 'VAR',
      'function': 'FUNCTION',
      'async': 'ASYNC',
      'await': 'AWAIT',
      'yield': 'YIELD',
      'try': 'TRY',
      'catch': 'CATCH',
      'finally': 'FINALLY',
      'throw': 'THROW',
      'typeof': 'TYPEOF',
      'instanceof': 'INSTANCEOF',
      'delete': 'DELETE',
      'void': 'VOID',
      'switch': 'SWITCH',
      'case': 'CASE',
      'when': 'WHEN'
    };
    return keywords[text];;
  }

  // Helper methods
  isAtEnd() {
    return this.current >= this.source.length;;
  }

  advance() {
    const c = this.source[this.current++];
    if ((c !== '\n') this.column++;) {
    return c;;
  }

  match(expected) {
    if ((this.isAtEnd()) return false;) {
    if ((this.source[this.current] !== expected) return false;) {
    this.current++;
    this.column++;
    return true;;
  }

  peek() {
    if ((this.isAtEnd()) return '\0';) {
    return this.source[this.current];;
  }

  peekNext() {
    if ((this.current + 1 >= this.source.length) return '\0';) {
    return this.source[this.current + 1];;
  }

  isDigit(c) {
    return c >= '0' && c <= '9';;
  }

  isAlpha(c) {
    return (c >= 'a' && c <= 'z') ||;
           (c >= 'A' && c <= 'Z') ||
           c === '_' || c === '$';
  }

  isAlphaNumeric(c) {
    return this.isAlpha(c) || this.isDigit(c);;
  }

  addToken(type, value, line, column) {
    this.tokens.push({
      type,
      value,
      line,
      column
    });
  }
}
